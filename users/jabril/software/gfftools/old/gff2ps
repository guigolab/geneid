#!/bin/sh
######################################################################
#                               gff2ps                               #
######################################################################
#
#     Converting GFF files to PostScript.
#
#     Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
#                                 Roderic GUIGO SERRA       
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
######################################################################
#
# Creation Date: 01.03.1999
# Last Update:
#         $Id: gff2ps,v 1.17 1999-06-19 21:12:31 jabril Exp $	
#
# Autor : Josep Francesc ABRIL FERRANDO
# e-mail: jabril@imim.es
#
# ( ./gff2ps -vC mygffcustomfile -- samples/data.gff > samples/.ps ) > & samples/report.
#

 CMDLine=$0" "$*
# CMDLine=`history | gawk '{last=$0}END{print last}' -`
# CMDLine=`history | gawk '{$1=$2="";last[NR]=$0}END{print last[NR-1]}' -`

##############################################################
#################### PROGRAM DEFINITIONS #####################
# 
# Defining Default Values...
#
Defaults () {
 # 
 # Constants: 
  PROGRAM="gff2ps"
  VERSION="v1.1"
  SHCREATION="01.03.1999"
  SHREVISION="01.06.1999"
  PSPROGRAM="gffPSplot"
  PSVERSION="v1.0"
  PSCREATION="01.06.1999"
  PSREVISION="01.06.1999"
  AUTHOR="Josep Francesc ABRIL FERRANDO"
  EMAIL="jabril@imim.es"
  MAIL="%                  Dept. Informatica Medica
%          Institut Municipal d'Investigacio Medica
%                   C./ Doctor Aiguader 80
%                  08003 - BARCELONA (SPAIN)"
  USAGE=$PROGRAM" [-h][-H <option>] gff_file"
  COLORS="    black | verydarkgrey | darkgrey | grey | lightgrey | verylightgrey | white 
       verydarkgreen | darkgreen | green | lightgreen | verylightgreen 
   verydarkskyblue | darkskyblue | skyblue | lightskyblue | verylightskyblue 
          verydarkblue | darkblue | blue | lightblue | verylightblue 
         verydarkcyan | darkcyan | cyan | lightcyan | verylightcyan 
     verydarkviolet | darkviolet | violet | lightviolet | verylightviolet 
            verydarkred | darkred | red | lightred | verylightred 
     verydarkorange | darkorange | orange | lightorange | verylightorange 
     verydarkyellow | darkyellow | yellow | lightyellow | verylightyellow 
        verydarkbrown | darkbrown | brown | lightbrown | verylightbrown"
 # 
 # Default User-Defined Options: 
  CFDIR=`pwd`
  if [ $GFFDIR ]
    then
      if [ -d "$GFFDIR" ]                  ###### Environment variable for working directory.
        then
          CFDIR="$GFFDIR"
        fi
    fi
  bgcolor="white"
  fgcolor="black"
  v01=0; n01="load_customfile"
  v02=""; n02="customfile_name"
  if [ $GFF_CUSTOM_FILE ]         ###### Environment variable for default custom file name.
    then
      v03="$CFDIR/$GFF_CUSTOM_FILE"
    else
      v03="$CFDIR/.gff2psrc"
    fi
    n03="customfile_name_default"
  v04=0; n04="exist_default_customfile"
  v04_1=0; n04_1="create_default_customfile"
  v05=0; n05="print_report"
  v06="Landscape"; n06="page_orientation"
  v07="a4"; n07="page_size"
  v08=1; n08="page_number"
  v09=1; n09="blocks_x_page"
  v10=0; n10="nucleotides_x_line"
  v11=1; n11="show_blocks_top-bottom"
# Layout Properties
  c01="1cm"; m01="margin_left"
  c02="1cm"; m02="margin_right"
  c03="1cm"; m03="margin_upper"
  c04="1cm"; m04="margin_bottom"
  c05="FGcolor"; m05="foreground_color"
  c06="BGcolor"; m06="background_color"
  c07=5; m07="max_blocks_x_page"
  c08="on"; m08="strand_show_forward"
  c09="on"; m09="strand_show_reverse"
  c10="on"; m10="strand_show_independent"
  c11=$c05; m11="text_color"
  c12="none"; m12="label"
  c13="0.25cm"; m13="default_scale_width"
  c14="1cm";    m14="default_track_width"
  c15="1cm";    m15="default_track_spacing_width"
  c16="0.25cm"; m16="default_block_spacing_width"
}

#
# Defining Help...
#
Help () {
#  echo ""
#  echo "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
#  echo "         1         2         3         4         5         6         7         8"
  echo ""
  echo "NAME           $PROGRAM"
  echo "VERSION        $VERSION"
  echo ""
  echo "Creation DATE: $SHCREATION"
  echo "Last REVISION: $SHREVISION"
  echo ""
  echo "SYNOPSIS"
  echo ""
  echo "      $USAGE"
  echo ""
  echo "DESCRIPTION"
  echo ""
  echo "       This program draws color-filled DotPlots"
  echo "       from files with gff-formatted data fields."
  echo "   "
  echo ""
  echo "OPTIONS"
  echo ""
  echo "     -h  Shows this help."
  echo "     -H <option> Shows only help for the especified option."
  echo "     -v Verbose mode, a report is sent to standard error."
  echo "     -p Switches page orientation to Portrait (default is Landscape)."
  echo "     -P <\#> Sets how many pages are needed to split your output (default is one)."
  echo "     -B <\#> Sets blocks per page (default is one)."
  echo "     -N <\#> Sets nucleotides per line (default is the largest sequence position from input gff-files)."
  echo "     -b Blocks from left to right and from top to bottom (default is top to bottom first)."
  echo "     -d Write (or rewrite if exist) default customfile \".gff2psrc\"."
  echo "     -D <default_custom_filename> Create a new default customfile with the given filename."
  echo "     -C <custom_filename>  Load given custom file and append to default custom file (.gff2psrc)."
  echo ""
  echo "ENVIRONMENT VARIABLES"
  echo ""
  echo "     You can specify the $PROGRAM path where it can find the default files with the shell variable GFFDIR."
  echo "     You can also define the default custom filename you will like with the variable GFF_CUSTOM_FILE, program default filename for custom file is \".gff2psrc\"."
  echo ""
  echo "COMMENTS"
  echo ""
  echo "  * Colors Defined are:"
  echo ""
  echo "$COLORS"
  echo ""
  echo "BUGS"
  echo ""
  echo "  Please, report bugs to:"
  echo "       $AUTHOR"
  echo "       e-mail: $EMAIL"
  echo "       Mail  : "
  gawk 'BEGIN{tt=ARGV[1];ARGV[1]="";gsub("\%\%","",tt);printf tt;print}' "$MAIL"
  echo ""
  return
}

ShowHelpLine () {
 Help | gawk 'BEGIN{
  IGNORECASE=1; flg=0; srch=ARGV[1]; ARGV[1]=""
  gsub("-","",srch); srch="\ -"srch"\ " }
  { if ($0~srch) { print $0; flg=1 } }
  END{ if (!flg) printf "\n\tERROR: Option %s is not defined,\n\t\tmake sure which option you need help.\n",srch }' $1 
 echo ""
 return
}

##############################################################
################# POSTSCRIPT MAIN FUNCTIONS ##################
#
# Printing %%Prolog Constant Definitions...
#
MAINPSCPR () {
cat <<'@@@EndCopyRight@@@'
% 
%    $Id: gff2ps,v 1.17 1999-06-19 21:12:31 jabril Exp $
% 
%          Converting GFF files to PostScript plots.
%
%          Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
%                                      Roderic GUIGO SERRA       
%
%    This program is free software; you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation; either version 2 of the License, or
%    (at your option) any later version.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program; if not, write to the Free Software
%    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
%
% ------------------------------------------------------------------------
@@@EndCopyRight@@@
}

MAINPSSETUP () {
cat <<'@@@EndProlog@@@'
%
%%BeginSetup
%
% true setpacking
true setstrokeadjust
0.125 setlinewidth
0 setlinejoin
0 setlinecap
%
/bdf { bind def } bind def
/xdf { exch def } bdf
/cm { 28.35 mul } bdf
/in { 72    mul } bdf
%
% Fixed Color Variables (CMYK)
% -----------------------------
%
/colordict 80 dict def colordict begin % 52 colors + 28 definitions
/black            { 0.00 0.00 0.00 1.00 } def /verydarkgrey     { 0.00 0.00 0.00 0.90 } def
/darkgrey         { 0.00 0.00 0.00 0.75 } def /grey             { 0.00 0.00 0.00 0.50 } def
/lightgrey        { 0.00 0.00 0.00 0.25 } def /verylightgrey    { 0.00 0.00 0.00 0.10 } def
/white            { 0.00 0.00 0.00 0.00 } def /verydarkgreen    { 0.65 0.00 0.95 0.40 } def
/darkgreen        { 0.90 0.00 0.90 0.10 } def /green            { 1.00 0.00 1.00 0.00 } def
/lightgreen       { 0.50 0.00 1.00 0.00 } def /verylightgreen   { 0.25 0.00 0.75 0.00 } def
/verydarkskyblue  { 0.95 0.15 0.00 0.40 } def /darkskyblue      { 1.00 0.25 0.00 0.15 } def
/skyblue          { 1.00 0.25 0.00 0.00 } def /lightskyblue     { 0.80 0.20 0.10 0.00 } def
/verylightskyblue { 0.60 0.15 0.15 0.00 } def /verydarkblue     { 1.00 1.00 0.00 0.40 } def
/darkblue         { 1.00 1.00 0.00 0.10 } def /blue             { 1.00 1.00 0.00 0.00 } def
/lightblue        { 0.80 0.80 0.00 0.00 } def /verylightblue    { 0.50 0.50 0.00 0.00 } def
/verydarkcyan     { 0.65 0.15 0.00 0.25 } def /darkcyan         { 0.65 0.15 0.00 0.00 } def
/cyan             { 1.00 0.00 0.00 0.00 } def /lightcyan        { 0.50 0.00 0.00 0.00 } def
/verylightcyan    { 0.25 0.00 0.00 0.00 } def /verydarkviolet   { 0.40 0.80 0.20 0.00 } def
/darkviolet       { 0.45 0.85 0.00 0.00 } def /violet           { 0.30 0.60 0.00 0.00 } def
/lightviolet      { 0.15 0.55 0.00 0.00 } def /verylightviolet  { 0.05 0.45 0.00 0.00 } def
/verydarkred      { 0.00 0.90 0.90 0.30 } def /darkred          { 0.00 0.80 0.90 0.10 } def
/red              { 0.00 1.00 1.00 0.00 } def /lightred         { 0.05 0.80 0.90 0.00 } def
/verylightred     { 0.15 0.40 0.60 0.00 } def /verydarkorange   { 0.00 0.60 1.00 0.00 } def
/darkorange       { 0.00 0.55 0.90 0.00 } def /orange           { 0.00 0.50 0.70 0.00 } def
/lightorange      { 0.00 0.30 0.85 0.00 } def /verylightorange  { 0.00 0.30 0.55 0.00 } def
/verydarkyellow   { 0.00 0.10 0.85 0.25 } def /darkyellow       { 0.00 0.10 0.85 0.00 } def
/yellow           { 0.00 0.00 1.00 0.00 } def /lightyellow      { 0.00 0.00 0.50 0.00 } def
/verylightyellow  { 0.00 0.00 0.25 0.00 } def /verydarkbrown    { 0.00 0.85 1.00 0.70 } def
/darkbrown        { 0.00 0.75 1.00 0.60 } def /brown            { 0.00 0.70 1.00 0.40 } def
/lightbrown       { 0.30 0.60 0.70 0.00 } def /verylightbrown   { 0.15 0.45 0.55 0.00 } def
end % colordict
%
%  Paper Sizes  (in points)  <--- Probably it is better to generate each time.
% --------------------------
%
/pagedict 14 dict def pagedict begin % Portrait { minor-axes:X major-axes:Y }
/pga2          { 1190 1684 } def /pga3          {  842 1190 } def
/pga4          {  595  842 } def /pga5          {  420  595 } def
/pgb4          {  708 1003 } def /pgb5          {  516  729 } def
/pgexecutive   {  540  720 } def /pgledger      { 1224  792 } def
/pglegal       {  612 1008 } def /pgletter      {  612  792 } def
/pgtabloid     {  792 1224 } def /pguserdefined {  595 2448 } def
end % pagedict
%
%  Defining CONSTANTS
% --------------------
%
/tflg false def     % test flag
%
/VUpOS 0.25 cm def  % offset defines non printable
/VDnOS 0.25 cm def  % paper area for pages (printer outlimits).
/HLtOS 0.25 cm def
/HRtOS 0.25 cm def
%
%  Defining VARIABLES
% --------------------
%
@@@EndProlog@@@
}
#### End of MAINPSSETUP function

#
# Printing Main PostScript Routines...
#
MAINPSPROCS () { 
cat <<'@@@MAINProcs@@@'
% /pgXsc { pglim pop 100 div } def
% /pgYsc { pglim exch pop 100 div } def
%%EndSetup
%
%%BeginProlog
%
%%BeginProcSet: Page_Layout 1.0 0
% checking if margins are within the defined offset
flglscape {
 UpM HLtOS lt { /UpM HLtOS def } if % Checking margins for flglscape mode
 DnM HRtOS lt { /DnM HRtOS def } if
 LtM VDnOS lt { /LtM VDnOS def } if
 RtM VUpOS lt { /RtM VUpOS def } if
 } {
  UpM VUpOS lt { /UpM VUpOS def } if % Checking margins for portrait mode
  DnM VDnOS lt { /DnM VDnOS def } if
  LtM HLtOS lt { /LtM HLtOS def } if
  RtM HRtOS lt { /RtM HRtOS def } if
  } ifelse
% defining pagelimits and X - Y scales (Xlim Ylim)
/pglim { Dpage pop LtM RtM add sub Dpage exch pop UpM DnM add sub } def
%
% Defining starting point on page.
/XORI LtM def
/YORI UpM def
% Defining page layout.
/XSTitl pglim pop XOriTitl 2 mul sub def
/XSBlck pglim pop def
/YSBlck pglim exch pop YSTitl BlckSp NBlck mul add YOriTitl add sub NBlck div def
%
/XOriBlck 0 def
/Nuc_Offset XOriBlck def
/YOriBlck YOriTitl YSTitl BlckSp add add def
/Y YOriBlck def
/XSPlot { XSBlck FLftLbl { XLftLbl sub } if FRgtLbl { XRgtLbl sub } if } def
/XOriPlot { XOriBlck FLftLbl { XLftLbl add } if } def
/Xscale XSPlot MaxNuclPage div def
/Yscale tracksize def
%
/up   YSBlck def
/down YSBlck def
%
/is2tck LnBth 0 gt LnFwd 0 gt LnRvs 0 gt and LnFwd 0 eq LnRvs 0 eq and or and def % true if must plot two tickmark lines
/YSLine YSBlck LnTot div def
%
% /LnTot LnFwd LnBth LnRvs add add def
% /putuptck LnFwd 0 gt LnFwd LnRvs add 0 eq or def
% /putdntck LnBth 0 gt LnFwd LnBth add 0 eq or def
% /TmpYSB YSBlck TkMrkW is2tck { 2 mul } if sub def  % Adjusting plot area size with tickmarks.
% /YSFwd LnFwd LnTot div TmpYSB mul def
% /YOriFwd YOriBlck def
% /YSBth LnBth LnTot div TmpYSB mul def
% /YOriBth YOriFwd YSFwd add putuptck { TkMrkW add } if def
% /YSRvs LnRvs LnTot div TmpYSB mul def
% /YOriRvs YOriBth YSBth add putdntck { TkMrkW add } if def
%
%%EndProcSet:   Page_Layout 1.0 0
%
%%BeginProcSet: functions 1.0 0
/min { 2 copy gt { exch } if pop } bdf 
/max { 2 copy lt { exch } if pop } bdf
/Xscm { Xscale mul } bdf /Xscme { Xscm exch } bdf
/Yscm { Yscale mul } bdf /Yscme { Yscm exch } bdf
/ChkLimits { 3 copy pop 5 2 roll dup dup 5 1 roll 3 1 roll lt 3 1 roll gt or { pop false } { true } ifelse } def 
/nucdif { 2 copy exch sub } bdf
%%EndProcSet:   functions 1.0 0
%
%%BeginProcSet: text_functions 1.0 0
/sfont { findfont exch scalefont setfont } bdf
/stringheight  { gsave newpath 0 0 moveto (0) false charpath flattenpath pathbbox exch pop exch sub exch pop 0.95 mul grestore } bdf
/ct { gsave 0 translate sfont scmyk dup stringwidth pop 2 div neg stringheight 2 div moveto show grestore } bdf
/ctr { gsave 0 translate sfont scmyk dup stringwidth pop 2 div neg stringheight 1.65 mul neg moveto show grestore } bdf
%%EndProcSet:   text_functions 1.0 0
%
%%BeginProcSet: painting_functions 1.0 0
/scmyk { setcmykcolor } bdf
/dotted { [ 1 ] 0 setdash } def
/bbox { 4 copy 3 1 roll exch 6 2 roll 8 -2 roll moveto lineto lineto lineto closepath } bdf
/tbbox { tflg { gsave setlinewidth scmyk stroke grestore } { pop pop } ifelse } def
/scolor { colordict exch get exec scmyk } bdf
%
colordict begin % adding definitions and functions
 /lup { /ku xdf /yu xdf /mu xdf /cu xdf } bdf
 /lmd { /km xdf /ym xdf /mm xdf /cm xdf } bdf
 /ldn { /kd xdf /yd xdf /md xdf /cd xdf } bdf
 /load2col { lup ldn /dk ku kd sub def /dy yu yd sub def /dm mu md sub def /dc cu cd sub def } bdf
 /load3col { lup lmd ldn /uk ku km sub def /uy yu ym sub def /um mu mm sub def /uc cu cm sub def /dk km kd sub def /dy ym yd sub def /dm mm md sub def /dc cm cd sub def } bdf
 /col2 { 2 dict begin /p xdf /pcd { p mul add } bdf cd dc pcd md dm pcd yd dy pcd kd dk pcd scmyk end } bdf
 /col3 { 3 dict begin /p xdf /pcd { p 2 mul mul add } bdf /pcu { p 0.5 sub 2 mul mul add } bdf p 0.5 le { cd dc pcd md dm pcd yd dy pcd kd dk pcd } { cm uc pcu mm um pcu ym uy pcu km uk pcu } ifelse scmyk end } bdf
 /rainbow { 1 dict begin /p xdf p 0.1 le { p 0.2 div 0.5 add 1 0 0 scmyk } { p 0.4 le { 1 1 p 0.1 sub 0.3 div sub 0 0 scmyk } { p 0.6 le { 1 0 p 0.4 sub 0.2 div 0 scmyk } { p 0.8 le { 1 p 0.6 sub 0.2 div sub 0 1 0  scmyk } { 0 p 0.8 sub 0.2 div 1 0 scmyk } ifelse } ifelse } ifelse } ifelse end } bdf
end % colordict
%%EndProcSet:   painting_functions 1.0 0
%
%%BeginProcSet: tickmarks 1.4 0
% Rule.ps ---> rules and scales
/tmdct 22 dict def tmdct begin
 /ShowGrid 0 def % 0 - none : 1 - MinTicks : 2 - MaxTicks : 3 - Both
 /Gridup true def /Griddn true def /flgup true def
 /TkMrkHW TkMrkW  2 div def
 /TkMrkDW TkMrkW 10 div def
 /TkFont { TkMrkHW /Helvetica } def
 /MaxWidthT { gsave MaxNuclPage 10 string cvs TkFont sfont stringwidth pop 2 mul grestore } bdf
 /CheckCloser { 3 copy pop MaxWidthT sub 3 1 roll MaxWidthT add 3 1 roll dup dup 5 1 roll 3 1 roll lt 3 1 roll gt or 4 1 roll 3 copy dup 3 1 roll ne 3 1 roll ne and 5 -1 roll and { pop false } { true } ifelse } bdf
 /ctextick { gsave TkFont sfont dup stringheight 2 div exch stringwidth pop 2 Xscm div neg Xscm exch 2 copy neg translate 2 mul exch 2 mul neg exch gsave 0 0 bbox BGcolor scmyk gsave tflg { FGcolor scmyk } if 2 setlinewidth stroke grestore fill grestore 0 0 moveto FGcolor scmyk show grestore } bdf
 /bltextick { gsave TkFont sfont dup stringwidth pop 2 Xscm div neg Xscm TkMrkHW 2 copy flgup { TkMrkDW add translate } { 2 mul translate 1 -1 scale } ifelse exch 2 mul neg exch gsave 0 0 bbox BGcolor scmyk gsave tflg { FGcolor scmyk } if 2 setlinewidth stroke grestore fill grestore 0 0 moveto FGcolor scmyk show grestore } bdf
 /tonormtick { 0 eq { dup dup 0 ne { MinTick mod } if sub exch dup dup 0 ne { MinTick mod } if sub exch } { dup dup 0 ne { MaxTick mod } if sub exch dup dup 0 ne { MaxTick mod } if sub exch } ifelse } bdf
 /Mkg { 0 0 moveto lineto FGcolor scmyk dotted stroke } bdf
 /MkVGrid { gsave setlinewidth Gridup flgup not { not } if { 0 up Mkg } if Griddn flgup not { not } if { 0 down neg Mkg } if  grestore } bdf
 /MkAtick { setlinewidth 0 TkMrkHW neg moveto 0 TkMrkHW lineto FGcolor scmyk stroke } bdf
 /MkBtick { gsave dup Xscm 0 translate ShowGrid 2 eq ShowGrid 3 eq or { 0.25 MkVGrid } if 1 MkAtick CheckCloser { 10 string cvs ctextick } if grestore } bdf
 /MkCtick { setlinewidth 0 0 moveto 0 TkMrkHW 3 -1 roll { TkMrkDW sub } if lineto FGcolor scmyk stroke } bdf
 /MkDtick { gsave dup Xscm 0 translate CheckCloser { 10 string cvs bltextick } if ShowGrid 2 eq ShowGrid 3 eq or { 0.25 MkVGrid } if false 1 MkCtick grestore } bdf
 /baseline { gsave Xscm TkMrkDW moveto Xscm TkMrkDW lineto TkMrkDW 2 mul setlinewidth FGcolor scmyk stroke grestore } bdf
 /r { /Gridup true def /Griddn true def /flgup true def 0 exch TkMrkW add translate gsave 0 translate 1 -1 scale 5 { 2 copy } repeat pop neg Xscm 0 translate 0 tonormtick MinTick exch { ChkLimits { gsave Xscm 0 translate 0.25 MkAtick ShowGrid 1 eq ShowGrid 3 eq or { 0 MkVGrid } if grestore } if } for 1 tonormtick MaxTick exch { ChkLimits { MkBtick } if } for 2 { dup dup 0 ne { MaxTick mod } if 0 ne { MkBtick } { pop } ifelse } repeat grestore } bdf
 /x { 6 { 2 copy } repeat pop neg Xscm 0 translate baseline 0 tonormtick MinTick exch { ChkLimits { gsave Xscm 0 translate true 0.25 MkCtick ShowGrid 1 eq ShowGrid 3 eq or { 0 MkVGrid } if grestore } if } for 1 tonormtick MaxTick exch { ChkLimits { MkDtick } if } for 2 { dup dup 0 ne { MaxTick mod } if 0 ne { MkDtick } { pop } ifelse } repeat } bdf 
 /s { /Gridup false def /Griddn true def /flgup true def 0 exch translate gsave 0 translate 1 -1 scale x grestore } bdf
 /z { /Gridup true def /Griddn false def /flgup false def 0 exch TkMrkHW add translate gsave 0 translate 1 1 scale x grestore } bdf
end % tmdct
%%EndProcSet:   tickmarks 1.4 0
%
%%BeginProcSet: objects 1.1 0
/shpdct 46 dict def shpdct begin
 /LY { tracksize 1.5 mul } bdf
 /ShFont { TkMrkW 2 div /Helvetica } def
 /RWTS { LY 1.5 mul } bdf
 /mtrx matrix def
 /cpt { moveto { lineto } repeat closepath } bdf
 /hline { 0 0 moveto 1 0 lineto closepath } bdf
 /fline { hline tracksize sc mul setlinewidth } bdf
 /harw {  0.0  0.0  0.0  -1.0  0.745 -1.0  0.745 -1.1  0.75 -1.1  5  1.0  0.0  cpt } bdf
 /farw {  0.75   0.6  0.745  0.6  0.745  0.5  0.0   0.5  0.0  -0.5
          0.745 -0.5  0.745 -0.6  0.75 -0.6                        8  1.0  0.0  cpt } bdf
 /hend {  0.0  0.0  -1.0   0.0 -1.0   1.0                        3  0.75 0.0  cpt } bdf
 /fend {  0.5  1.0   0.5   0.0 -0.5   0.0 -0.5   1.0             4  0.75 0.0  cpt } bdf
 /hbox {  1.0  0.0   1.0  -1.0  0.0  -1.0                        3  0.0  0.0  cpt } bdf
 /fbox {  0.0  0.5   1.0   0.5  1.0  -0.5                        3  0.0 -0.5  cpt } bdf
 /hcir {  0.5 -0.5   0.5   0   360 arc closepath } bdf
 /fcir {  0.5  0.0   0.5   0   360 arc closepath } bdf
%%% /getcol { colordict begin /ct xdf /s end } bdf
% must define frame colors /frm0 /frm1 /frm2...
 /getfrcol { dup 0 eq { pop frm0 } { dup 1 eq { pop frm1 } { 2 eq { frm2 } if } ifelse } ifelse } bdf
 /cmdln { 0 moveto sqdif 2 div 0 lineto scmyk stroke } bdf
 /lnfill { gsave RWTS setlinewidth sqdif 2 div cmdln 0 cmdln grestore } bdf
 /frmfill { frm getfrcol rmd getfrcol lnfill } bdf
 /rnbfill { 1 dict begin gsave /incr sqdif 100 div def 0 incr sqdif { dup dup incr add 0 exch 0 moveto lineto dup 0 gt { sqdif div } if rainbow RWTS setlinewidth stroke } for grestore end } bdf 
% /getvar { /ftlbl xdf /sc xdf /rmd xdf /frm xdf strnd (-) eq { exch } if 2 copy exch sub /sqdif exch Xscm def /sqdsc sqdif Xscale div def /seqend exch Xscm def /seqori exch Xscm def /cmod xdf } bdf
 /getvar { /ftlbl xdf /cmod xdf /sc xdf /rmd xdf /frm xdf nucdif /sqdif exch Xscm def /sqend exch def /sqori exch def /seqend sqend Xscm def /seqori sqori Xscm def } bdf
 /setcolmod { colordict begin cmod cvx exec dup 1 eq { pop scmyk fill } { dup 2 eq { pop lnfill } { dup 3 eq { pop frmfill } { dup 4 eq { pop rnbfill } { 0 eq { BGcolor scmyk fill } if } ifelse } ifelse } ifelse } ifelse end } bdf
 /shwpos { flpos { sqend sqori strnd (-) eq { exch } if sqdif exch 0 2 { gsave tracksize 1 mul moveto 10 string cvs gsave strnd (-) eq { -1 -1 scale -45 } { 45 } ifelse rotate ShFont sfont FGcolor scmyk show grestore grestore } repeat } if } bdf
 /frshared { strnd (-) eq { -1 -1 scale } if 0.5 setlinewidth gsave /svmtrix mtrx currentmatrix def LY sc mul sqdif flglscape { exch } if scale cvx exec svmtrix setmatrix gsave FGcolor scmyk stroke grestore clip setcolmod grestore shwpos pop } bdf
 /f { gsave getvar strnd (-) eq { seqend } { seqori } ifelse 0 translate frshared grestore } bdf
 /gpuline { gsave 0 0
 moveto grdif 0 rlineto /red scolor 1 setlinewidth stroke grestore } bdf
 /shgplbl { FgpLbl { gsave grori tracksize 1 mul strnd (-) ne { neg } if translate gpuline grlbl FGcolor 8 /Helvetica grdif 2 div strnd (-) eq { ct } { ctr } ifelse grestore } if } bdf 
 /g_end { end exit } bdf 
%
% functions for vectors-like data-sets
%
 /resizetrack tracksize 0.95 mul def
 /vtoffset vectoffset 2 div Xscm def
 /clrselc { colordict begin dup 2 eq { pop load2col /clrproc { {col2} } def } { dup 3 eq { pop load3col /clrproc { {col3} } def } { dup 0 eq { pop white black load2col /clrproc { {col2} } def } { dup 4 eq { pop /clrproc { {rainbow} } def } { 1 eq { white 8 4 roll load2col /clrproc { {col2} } def } if } ifelse } ifelse } ifelse } ifelse } bdf % no end for closing dict because grdct must be closed by calling function
 /v { gsave Xscm dup vtoffset sub exch vtoffset add 0 moveto 0 lineto resizetrack setlinewidth clrproc exec stroke grestore } bdf
 /v_end { end exit } bdf   % end is for grdct dict
end % shpdct
%%EndProcSet:   objects 1.1 0
%
%%BeginProcSet: blocks 1.0 0
%
% /blckdct 16 dict def blckdct begin
 /pbox { XOriBlck YOriBlck 10 sub XSBlck YSBlck 20 add bbox clip tflg not { newpath } { 1 setlinewidth FGcolor scmyk stroke } ifelse } bdf
 /bline { Fbline { gsave FGcolor scmyk 0 0 moveto XSPlot 0 lineto stroke grestore } if } bdf
 /shsrclbl { FLftLbl { gsave srclbl FGcolor 10 /Courier XLftLbl 2 div neg ct grestore } if } bdf
 /srcbndbox { tracksize spcrsize add 2 mul dup -5 exch neg XSPlot 10 add 4 -1 roll bbox clip tflg not { newpath } { 1 setlinewidth FGcolor scmyk stroke } ifelse } bdf
 /source { /strnd xdf /nxtspacer exch spcrsize mul def 2 dict begin /Yscl exch tracksize mul def /srclbl xdf /Y Y strnd (-) eq { nxtspacer add } { Yscl add } ifelse def 0 Y translate gsave XOriPlot 0 translate 1 -1 scale bline shsrclbl srcbndbox Nuc_Offset Xscm neg 0 translate } bdf
 /s_end { grestore /Y Y strnd (-) eq { Yscl add } { nxtspacer add } ifelse def end } bdf
%
 /gp { gsave shpdct begin nucdif /grdif exch Xscm def /grend exch Xscm def /grori exch Xscm def /grlbl xdf shgplbl { currentfile token { exec } { exit } ifelse } loop grestore } bdf
%
 /ov { gsave vctdct begin exch Xscm exch translate { currentfile token { exec } { exit } ifelse } loop end grestore } bdf
%
 /tm { /Y Y TkMrkW add def tmdct begin /ShowGrid xdf exec end } bdf
%
% /b_end { end grestore } bdf
% end
%%EndProcSet:   blocks 1.0 0
%
%%BeginProcSet: main_function_calls 1.0 0
%
% /block { gsave blckdct begin /Y YOriBlck def /blcknum xdf pbox } bdf
/block { gsave /Y YOriBlck def /blcknum xdf pbox } bdf
/b_end { grestore } bdf
%
%%EndProcSet:   main_function_calls 1.0 0
%%EndProlog
@@@MAINProcs@@@
} 
#### End of MAINPSPROCS function

#
# PostScript end of file... 
# 
MAINPSTRAILER () {
cat <<'@@@EndTrailer@@@'
%%Trailer
%
%%EOF
@@@EndTrailer@@@
} 
#### End of MAINPSTRAILER function

##############################################################
####################### PROGRAM FUNCTIONS ####################
#
# Testing parameters passed by User: Colors.
#
CheckColor () {
  gawk 'BEGIN{
    color=ARGV[1]
    if (color!~/^BG$|^FG$|^black$|^white$|^(very)?(light|dark)?(grey|green|(sky)?blue|cyan|violet|red|orange|yellow|brown)$/) {
      printf "\n<<<<ERROR>>>> \" %s \" is not a defined color.\n", color | "cat 1>&2"
      printf "              Default \" black \" is asigned to option.\n" | "cat 1>&2"
      printf "              You can choose one of this colors:\n" | "cat 1>&2"
      print ARGV[3] | "cat 1>&2"
      print "" | "cat 1>&2"
      color=ARGV[2]
      }
    print color
    ARGV[1]=ARGV[2]=ARGV[3]=""
    }' $1 $2 "$COLORS"
  return 0
}

#
# Testing parameters passed by User: Integer Numbers.
#
CheckInt () {
  if [ `expr $1 : '[0-9]*'` -eq `expr $1 : '.*'` ]
    then echo "1"; return 0
    else 
      echo "<<<<ERROR>>>> \" $1 \" is not an integer value." 1>&2
      echo "              You must especify an integer value to -$W_OPTION" 1>&2
      echo "              Program will take value from defaults..." 1>&2
      echo "" 1>&2
      echo "0";return 1
    fi
  return 1
}

#
# Testing if exist Custom File.
#
ExistCustomfile () {
  if [ ! -f "$1" ]
    then echo "0"
      echo "Report: Default Custom File does not exist." 1>&2
#     echo "        Program is going to write a Local Custom File." 1>&2 
    else echo "1" # exist_default_customfile
      echo "Warning: Default Custom File exist." 1>&2
#     echo "         Program is going to overwrite your Local Custom File." 1>&2
    fi
  echo "          Custom_Filename: $1" 1>&2
  return 0
}
###################################################################
################## MAIN GFF2PS SHELL SCRIPT #######################
#
###################################################################
################## Choosing Options for GFF2PS ####################
#
# Resetting default program variables.
#
Defaults

#
# Checking if default custom file exists
#  else switch on flag to create.
#
echo "" 1>&2
echo "Report: You have typed the following command line:" 1>&2
echo "" 1>&2
echo $CMDLine 1>&2
echo "" 1>&2

#
# When no options, no parameters and 
#  no inputstream are given, print USAGE.
#
if [ $# -eq 0 ] 
  then
    echo; echo $USAGE; echo; exit 1
  fi

#
# Asking for Help, output it to screen. 
#
case $1 in
  -h) Help; exit 2;;
  -H) echo; echo $PROGRAM" : Option Definition Help."; echo;
      if [ $# -gt 1 ]; 
        then shift; fi;
      for temp in $@;
        do ShowHelpLine $temp; done;
      exit 2;;
  esac

#
# Processing all options and parameters passed to program.
#
while getopts :dD:C:vpP:B:N:bHh W_OPTION
  do
    case $W_OPTION in
      H|h) Help; exit 2;;
      d) v04_1=1;;                    # create_default_customfile (.gff2psrc) or rewrite
      D) v04_1=1;                     # create_default_customfile or rename_it if exist
         v03="$CFDIR/$OPTARG";;
      C) if [ ! -f $CFDIR/$OPTARG ];    # load_customfile customfile_name
           then v01=0;
             echo "Error: Custom File $OPTARG does not exist...Not Loaded." 1>&2 ;
           else v01=1;
	         echo "Report: Adding $OPTARG Custom File to Default Custom File." 1>&2 ;
             v02="$CFDIR/$OPTARG";
           fi;;
      v) v05=1;;                      # print_report
      p) v06="Portrait";;               # page_orientation
      P) v08=$OPTARG;;                  # page_number
      B) v09=$OPTARG;;                  # blocks_x_page
      N) v10=$OPTARG;;                  # nucleotides_x_line
      b) v11=0;;                      # show_blocks_top-bottom
       :) ShowHelpLine $1; exit 2;;
      \?) ShowHelpLine $1; exit 2;;
    esac # case $W_OPTION
  done   # while getopts

#
# Shifting all options tested before,
# without removing files passed to shell...
#
 incr=1
 while [ $OPTIND -gt $incr ]
   do shift; incr=`expr $incr + 1`; done

#
# Defining PLOToptions STRING for GNU awk programs.
#
 v04=`ExistCustomfile "$v03"`
   P="BACKGROUND_COLOR:="$bgcolor"::FOREGROUND_COLOR:="$fgcolor"::"$n04_1":="$v04_1"::"
 P=$P$n01":="$v01"::"$n02":="$v02"::"$n03":="$v03"::"$n04":="$v04"::"$n05":="$v05"::"
 P=$P$n06":="$v06"::"$n07":="$v07"::"$n08":="$v08"::"$n09":="$v09"::"$n10":="$v10"::"
 P=$P$n11":="$v11"::"
 P=$P$m01":="$c01"::"$m02":="$c02"::"$m03":="$c03"::"$m04":="$c04"::"$m05":="$c05"::"
 P=$P$m06":="$c06"::"$m07":="$c07"::"$m08":="$c08"::"$m09":="$c09"::"$m10":="$c10"::"
 P=$P$m11":="$c11"::"$m12":="$c12"::"$m13":="$c13"::"$m14":="$c14"::"$m15":="$c15"::"
 P=$P$m16":="$c16
 PLOToptions=$P
 if [ $v05 -eq 1 ]
   then
     echo "" 1>&2
     echo "********************************************" 1>&2
     echo ">>>>> Option String Passed to Program <<<<<<" 1>&2
     echo "********************************************" 1>&2
     echo "" 1>&2
     echo $PLOToptions 1>&2
     echo "" 1>&2
   fi

###################################################################
############### CONVERTING GFF TO POSTSCRIPT ######################
#
# Printing PostScript Header...
#
gawk 'BEGIN{ 
 # Find actual date...
 "date" | getline d
 split(d,dt," ")
 date = dt[3] "." dt[2] "." dt[6] " " substr(dt[4],1,5)
 # Finding logged user...
 "whoami" | getline usr
 # Printing PostScript Header...
 bigchain=        "%%\!PS-Adobe-2.0\n"
 bigchain=bigchain"%%%%Title: %s\n"
 bigchain=bigchain"%%\n%%%%User: %s\n"
 bigchain=bigchain"%%%%Date: %s\n"
 bigchain=bigchain"%%\n%%%%Program: %s\n"
 bigchain=bigchain"%%%%Version: %s\n"
 bigchain=bigchain"%%%%CreationDate: %s\n"
 bigchain=bigchain"%%%%LastRevision: %s\n"
 bigchain=bigchain"%%%%Author : %s\n"
 bigchain=bigchain"%%%%e-mail : %s\n"
 bigchain=bigchain"%%%%Mail Adress:\n%s\n%%\n"
 if (ARGV[1]!~"##dflt##") title=ARGV[1]
 else title="GFF to PostScript"
 printf bigchain, title, usr, date, ARGV[2], ARGV[3], ARGV[4], ARGV[5], ARGV[6], ARGV[7], ARGV[8]
 printf "%%\n%% ------------------------------------------------------------------------\n"
 printf "%%                           %s - %s\n",ARGV[2], ARGV[3]
 printf "%% ------------------------------------------------------------------------\n"
  for (i=1;i<=8;i++) ARGV[i]=""
}' "##dflt##" "$PSPROGRAM" "$PSVERSION" "$PSCREATION" "$PSREVISION" "$AUTHOR" "$EMAIL" "$MAIL"

#
# Printing PostScript Setup Constants...
#
  MAINPSCPR
  echo "%%Orientation: "$v06 # "page_orientation"
  echo "%%BoundingBox:  0  0  842   595"
  MAINPSSETUP

#
# Main GFF2PS GNU awk Program...
#
# (cat <<'@@@EndPROGRAM@@@') |
# @@@EndPROGRAM@@@
# gawk -v CUSTOMFILE=$v03 -f - "$@"
#
(echo $PLOToptions"::DCF:=$CFDIR/.gff2psrc"; MAINPSPROCS) |
gawk 'BEGIN{
  ############ INITIALITATION ############

  # gff data structure
  seqname  = 1;
  source   = 2;
  feature  = 3;
  start    = 4;
  end      = 5;
  score    = 6;
  strand   = 7;
  frame    = 8;
  group    = 9;

  # gff strand codification
  strands["+"]=strands["."]=strands["-"]=1;
  wstr[1]="+";wstr[2]=".";wstr[3]="-";

  # Find actual date...
  "date" | getline d
  split(d,dt," ")
  date = dt[3] "." dt[2] "." dt[6] " " substr(dt[4],1,5)
  # Finding logged user...
  "whoami" | getline usr
  # Finding current process...
  "echo $$" | getline IDP

  # Loading PSMainProgram. Line 0 is the Command Line Parameter String.
  psline=0
  while ((getline < ARGV[1])>0) PSMAIN[psline++]=$0;
  ARGV[1]=""

 ############## Defining pre-variables by CommandLine ############ 
 PARAM=PSMAIN[0]
 npar=split(PARAM,parm,"::") 
 for (r=1;r<=npar;r++) {
   split(parm[r],elem,":=")
   if (elem[2]!="##dflt##") {
     if (elem[1]~/COLOR\$/) {
       ecolor=elem[2]
       if (ChkColor(ecolor)) {
         if (ecolor~/^BG\$|(##DEFAULT##)/) { elem[2]=Var["BACKGROUND_COLOR"] }
         else if (ecolor~/^FG\$/) { elem[2]=Var["FOREGROUND_COLOR"] }
         }
       else { elem[2]=Var["BACKGROUND_COLOR"] }
       }
     Var[elem[1]]=elem[2]
     }
   }
  for (v in Var) printf "VAR: %-25s :: Value: %s\n", v, Var[v] | "cat 1>&2" 

# Layout Properties
  Default["load_customfile"]=Var["load_customfile"]  # in this case we need to force variables.
  Default["customfile_name"]=Var["customfile_name"]  # in this case we need to force variables.
  Default["customfile_name_default"]=Var["DCF"]      # DCF="$CFDIR/.gff2psrc"
#  Default["exist_default_customfile"]="0"  # only as a Var
#  Default["create_default_customfile"]="0" # only as a Var
#  Default["print_report"]="0"              # only as a Var
  Default["page_size"]="a4"               # Var["page_size"]
  Default["page_orientation"]="Landscape" # Var["page_orientation"] : Landscape (default), Portrait.
  Default["margin_left"]="1cm"            # cm, in, pt
  Default["margin_right"]="1cm"           #
  Default["margin_upper"]="1cm"           #
  Default["margin_bottom"]="1cm"          #
  Default["foreground_color"]="FGcolor"
  Default["background_color"]="BGcolor"
  Default["nucleotides_x_line"]=0 # Var["nucleotides_x_line"] : Default=0,gets the seqlenght from data
  Default["blocks_x_page"]=1      # Var["blocks_x_page"] : Default=1
  # Default["max_blocks_x_page"]=5  # You can change on .gff2psrc file.
  Default["show_blocks_top-bottom"]=1 # Var["show_blocks_top-bottom"] : 1->TopBottom, 2->LeftRight.
  Default["page_number"]=1        # Var["page_number"] : Default=1
  Default["strand_show_forward"]="on"     #
  Default["strand_show_reverse"]="on"     #
  Default["strand_show_independent"]="on" #
# General Properties
  Default["text_color"]=Default["foreground_color"]
  Default["default_scale_width"]="0.25cm"
  Default["default_track_width"]="1cm"
  Default["default_track_spacing_width"]="1cm"
  Default["default_block_spacing_width"]="0.25cm"
  Default["label"]="none"
# Features Properties
  FT_PROP["fill_shape_mode"]="default" # none(BGcolor), default(FGcolor 1color), 1_color, 2_color, frame-remainder, rainbow
  FT_PROP["fill_vector_mode"]="default" # none(0 BGcolor grad), default(0 black grad), rainbow(1), 1_color(BGcolor color 2), 2_color(color1 color2 2), 3_color(col1 col2 col3 2)
  FT_PROP["label"]="default" # none , default , "user-def"
  FT_PROP["color"]=Default["foreground_color"] # 1color(color),2color(color..color),3color(color..color..color)
  FT_PROP["shape"]="box" #box, arrow, end_arrow, circle # still not implemented: vector, spike, block
  FT_PROP["vert_align"]="baseline" #center,baseline # still not implemented: reverse
  FT_PROP["layer"]=0     # now is implemented, first sorting for feature lines is made on FT_PROP["layer"]
  FT_PROP["join"]="on"
  FT_PROP["show"]="on"
# Group Properties
  GR_PROP["label"]="default"        # none , default , "user-def"
  GR_PROP["range"]="0:1"             # range of lower-upper scores
  #  GR_PROP["vert_align"]="center" # center or baseline
  GR_PROP["join_align"]="center"
  GR_PROP["join_color"]=Default["foreground_color"]
  GR_PROP["join_linetype"]="solid"
  GR_PROP["join_show"]="off"
# Lines (Method-Source) Properties
  SO_PROP["label"]="default"     # none , default , "user-def"
  SO_PROP["vert_align"]="center" # center or baseline
  SO_PROP["baseline_align"]="center"
  SO_PROP["baseline_color"]=Default["foreground_color"]
  SO_PROP["baseline_linetype"]="dotted"
  SO_PROP["baseline_show"]="off"
  SO_PROP["bbox_color"]=Default["foreground_color"]
  SO_PROP["bbox_show"]="off"
  SO_PROP["track_scale"]=1
  SO_PROP["track_spacing_scale"]=0.5
  SO_PROP["rule_scale"]="nucleotide"
  SO_PROP["rule_rel"]="none"
  SO_PROP["rule_abs"]="none"
# Default[""]=

 # Data for upper-case to lower-case function #lcase()#
 CM["A"]="a";CM["B"]="b";CM["C"]="c";CM["D"]="d";CM["E"]="e";
 CM["F"]="f";CM["G"]="g";CM["H"]="h";CM["I"]="i";CM["J"]="j";
 CM["K"]="k";CM["L"]="l";CM["M"]="m";CM["N"]="n";CM["O"]="o";
 CM["P"]="p";CM["Q"]="q";CM["R"]="r";CM["S"]="s";CM["T"]="t";
 CM["U"]="u";CM["V"]="v";CM["W"]="w";CM["X"]="x";CM["Y"]="y";
 CM["Z"]="z";CM["Ñ"]="ñ";CM["Ç"]="ç"

 # Initialization for some vars.
 BigLINE="########################################";
 MINSCORE=0.10;
 MAXSCORE=1.00;
 FIRST_POS=0;
 LAST_POS=0;
 nordcnt=ordcnt=0

 if (Var["print_report"]) 
   printf "\n%s\nInput File...\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
 }
{ ############ READING .GFF FILES  ############

  # skips those comment lines (starting with "#") or empty lines
  #
  is_EOF=0
  while ($0~/^(\#)+/ || NF==0 ) { 
    if (Var["print_report"]) 
      printf "%10s :: Not Read :: %s\n", NR, $0 | "cat 1>&2"
    if (getline<=0) { is_EOF=1; break }
    }

 if (!is_EOF) {

  # Printing Input Lines
  #
  if (Var["print_report"]) 
   printf "%10s : %s\n", NR, $0 | "cat 1>&2"

  # getting source order from file...
  #
  if (($strand=="+" || $strand=="-") && !($source in sources)) {
    order["strand",ordcnt]=$source; ordcnt++ } # order for sources input.
  else if ($strand=="." && !($source in sources)) {
    order["none",nordcnt]=$source; nordcnt++ }

  # read gff element within source and strand
  #
  sources[$source]++;                       # field 2 (source) counter
  if ($group=="") $group=".";               # empty group defined as default (none==".")
  GP_ary[$group]++;                         # field 9 (group) counter
#   The same as ng[sc,s] 
#   GP_SO[$source,$strand,$group]++;          # groups per source and strand
  FT_ary[$feature]++;                       # field 3 (gff-feature) counter
#   FT_GP[$source,$strand,$group,$feature]++; # features per group, source and strand
  n[$source,$strand]++;                     # elements per source and strand

  $feature=lcase($feature);
  element[$source,$strand,n[$source,$strand],feature] = $feature; 
  element[$source,$strand,n[$source,$strand],start]   = $start;
  element[$source,$strand,n[$source,$strand],end]     = $end;
  element[$source,$strand,n[$source,$strand],frame]   = $frame;  
  element[$source,$strand,n[$source,$strand],score]   = $score;  
  element[$source,$strand,n[$source,$strand],group]   = $group; 
  if ($NF>group) {
    for (i=(group+1);i<=$NF;i++) {
      if ($i~"Label")
        element[$source,$strand,n[$source,$strand],$i]= $(i+1);  
    }
  }

  if (FIRST_POS>$start) FIRST_POS=$start;
  if (LAST_POS<$end) LAST_POS=$end;

  # recompute scores between MINSCORE and MAXSCORE
  #
  if ($score < MINSCORE)
    element[$source,$strand,n[$source,$strand],score]  = MINSCORE;
  else if ($score > MAXSCORE)
    element[$source,$strand,n[$source,$strand],score]  = MAXSCORE;

  # place gff element in sort array by acceptor position
  #
  ns=n[$source,$strand]-1;
  while ($start < element[$source,$strand,S[$source,$strand,ns],start]) {
    S[$source,$strand,ns+1]=S[$source,$strand,ns];
    ns--;
  }
  S[$source,$strand,ns+1]=n[$source,$strand]

 } # if (!is_EOF)

}
END{

  # Printing elements sorted
  #
  if (Var["print_report"]) {
   printf "\n%s\ngff elements are sorted...\n%s\n",BigLINE,BigLINE | "cat 1>&2"
   for (sc in sources) 
    for (s in strands) {
      printf "\nSOURCE: %s\nSTRAND: %s\n",sc,s | "cat 1>&2"
      if (n[sc,s]>0)
        for (i=1;i<=n[sc,s];i++) {
          printf "%10s %s\n", S[sc,s,i],showelemS(sc,s,S[sc,s,i]) | "cat 1>&2"
        
        }
      else
        printf "%10s This block is empty ##\n", "##" | "cat 1>&2"
      }
   close("cat 1>&2")
   }

  ########## Defining Object Properties ##########
  #
  # Variable definition hierarchy:
  # Program Defaults < Default Custom File < Custom File < Command Line.
  #
  CreateProps(0)
  if (Var["exist_default_customfile"]) {
    if (Var["print_report"]) printf "\n%s\nReading Default Custom File...\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    RCFile(Var["customfile_name_default"])
    }
  if (Default["load_customfile"]) {
    if (Var["print_report"]) printf "\n%s\nReading Custom File...........\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    RCFile(Default["customfile_name"])
    }

  # Calculating Page Number, Blocks and NucxLine
  #
  PORI=Nuc_round(FIRST_POS,0) # floor
  PEND=Nuc_round(LAST_POS,1)  # ceiling
  # Zoom must be defined here
  if (PORI!=0) PDIF=PEND-PORI+1
  else PDIF=PEND-PORI

  P=Default["page_number"]
  B=Default["blocks_x_page"]

  if (Default["nucleotides_x_line"]==0) {
    if (B>1 || P>1) POFFSET=Nuc_round((PDIF/(B*P)),1)
    else POFFSET=PDIF
    }
  else POFFSET=Default["nucleotides_x_line"]
  if (POFFSET>PDIF) POFFSET=PDIF # necessary if it is defined a Zoom.

  B1= PDIF%POFFSET!=0 ? ((PDIF-(PDIF%POFFSET))/POFFSET)+1 : ((PDIF-(PDIF%POFFSET))/POFFSET)
  P = B1%B!=0 ? ((B1-(B1%B))/B)+1 : ((B1-(B1%B))/B)
  
  if (Default["show_blocks_top-bottom"]) BOFFSET=POFFSET
  else BOFFSET=POFFSET*P

  printf "\n%s\nPostScript Page Definitions...\n%s\n",BigLINE,BigLINE | "cat 1>&2"  
  printf "\npage_number %s\nblocks_x_page %s\nnucleotides_x_line %s\nshow_blocks_top-bottom %s\n",Default["page_number"],Default["blocks_x_page"],Default["nucleotides_x_line"],Default["show_blocks_top-bottom"] | "cat 1>&2"  
  printf "\nPORI %s\nPEND %s\nP %s\nB %s\nPOFFSET %s\nBOFFSET %s\n\n",PORI,PEND,P,B,POFFSET,BOFFSET | "cat 1>&2"  

  # Calculating Block scale factor.
  #
  StrSize=0; NStSize=0; # for strands...
  aS=calcpt(Default["default_track_width"]);
  bS=calcpt(Default["default_track_spacing_width"]);
  for (ws in order) {
    split(ws,wsb,SUBSEP)
    if (wsb[1]=="strand")
      StrSize=StrSize+(aS*PLOT_FT[order[ws],":","track_scale"])+(bS*PLOT_FT[order[ws],":","track_spacing_scale"])
    else if (wsb[1]=="none")
      NStSize=NStSize+(aS*PLOT_FT[order[ws],":","track_scale"])+(bS*PLOT_FT[order[ws],":","track_spacing_scale"])
    }
  if (OnOff(Default["strand_show_forward"])) StrSizeFwd=StrSize; else StrSizeFwd=0
  if (OnOff(Default["strand_show_reverse"])) StrSizeRvs=StrSize; else StrSizeRvs=0
  if (!OnOff(Default["strand_show_independent"])) NStSize=0
  SclSize=0 # for scales...
  
  # Default["default_scale_width"]
  BSize=StrSizeFwd+StrSizeRvs+NStSize+SclSize # (cms)

  # PostScript Variables Setup.
  #
  defPSvars()

  # PostScript Main Procs.
  #
  for (i=1;i<psline;i++) print PSMAIN[i]; 

  # Pages MAIN LOOP.
  #
  for (pages=1;pages<=P;pages++) {
    BORI=PORI
    startPSpage(pages,pages,BORI,POFFSET)  # PostSCript PageSetup.

    for (blocks=1;blocks<=B;blocks++) {
      printf "%%\n%% Block Num: %s Page: %s\n%%\n",blocks,pages
      printf "%s block\n", blocks
      BEND=BORI+POFFSET
  # make groups. assumes elements sorted by increasing acceptor position
  #
  cntstr_fwd=cntstr_bth=cntstr_rvs=0
  printf "\n%s\nPostScript Code...\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
  for (sc in sources) {
    for (s in strands) {
      for (i=1;i<=n[sc,s];i++) {
        start_=element[sc,s,S[sc,s,i],start];
        end_=element[sc,s,S[sc,s,i],end];

	    tgr=element[sc,s,S[sc,s,i],group];
	    if (!grouping[sc,s,tgr,start]) {
	      grouping[sc,s,tgr,start]=element[sc,s,S[sc,s,i],start];
	      ng[sc,s]++;
	      group_[sc,s,ng[sc,s]]=tgr
          }
        if (grouping[sc,s,tgr,end]<element[sc,s,S[sc,s,i],end])
          grouping[sc,s,tgr,end]= element[sc,s,S[sc,s,i],end];

       # only goes on when features are inside page limits.
       if (ChkLimits(start_,BORI,end_,(BEND))) {
        feature_=element[sc,s,S[sc,s,i],feature];
        score_=element[sc,s,S[sc,s,i],score];

        # for gene mode. try to recompute relative frame and remainder
        frame_[sc,s,tgr]= element[sc,s,S[sc,s,i],frame];

        if (feature_=="First" || feature_=="Single") 
          frame_[sc,s,tgr]=0;
        else if (feature_=="Internal" || feature_=="Terminal" )
          frame_[sc,s,tgr]=remainder_[sc,s,tgr];

        remainder_[sc,s,tgr]=(3-(end_-(start_+frame_[sc,s,tgr])+1)%3)%3;

        printf "%s %s %s : %s \/%s %d %d %d %d %4.2f (%s) (%s) f\n", sc,s,i, PLOT_FT[feature_,":","layer"], Set_feat_Shape(feature_,sc), start_, end_, frame_[sc,s,tgr] ,remainder_[sc,s,tgr], score_, Set_feat_Clr(feature_), Plot_Lbl(feature_) | "cat 1>&2"
        grouping[sc,s,tgr,group,blocks,pages] = sprintf("%s%s \/%s %d %d %d %d %4.2f (%s) (%s) f\n", grouping[sc,s,tgr,group,blocks,pages], PLOT_FT[feature_,":","layer"], Set_feat_Shape(feature_,sc), start_, end_, frame_[sc,s,tgr] ,remainder_[sc,s,tgr], score_, Set_feat_Clr(feature_), Plot_Lbl(feature_))
        plot_group[tgr,blocks,pages]=1
       } # if ChkLimits
      }  # for i
        printf "\n" | "cat 1>&2"
    }    # for s
    # Percent of plot area for each strand
    # if (ng[sc,"+"]>0) cntstr_fwd+=PLOT_FT[sc,":","track_scale"]
    # if (ng[sc,"."]>0) cntstr_bth+=PLOT_FT[sc,":","track_scale"]
    # if (ng[sc,"-"]>0) cntstr_rvs+=PLOT_FT[sc,":","track_scale"]
  }      # for sc
    # cntstr_TOT=cntstr_fwd+cntstr_bth+cntstr_rvs
    #  printf "/LnFwd %s def %% groups for each strand\n/LnBth %s def\n/LnRvs %s def\n", cntstr_fwd/cntstr_TOT, cntstr_bth/cntstr_TOT, cntstr_rvs/cntstr_TOT

  # PostScript Drawing strands, sources, groups, features
  #
  # make plotlines. Put non-overlapping groups into the same plotting line.
  #
  if (Var["print_report"]) printf "\n%s\nPrinting Lines......\nPage: %s Block: %s\nNuc_Ori: %s - Nuc_End: %s\n%s\n\n",BigLINE,pages,blocks,BORI,BEND,BigLINE | "cat 1>&2"
  for (stp=1;stp<=3;stp++) { # for s in strand
    prtrule=0
    s=wstr[stp]
    if (s=="+" || s=="-") lastcnt=ordcnt
    else { lastcnt=nordcnt; prtrule=1 }
    printf "------ Source: --- Strand: %s Counter: %s\n", s, lastcnt | "cat 1>&2" 
    if (prtrule) printf "%s %s XOriPlot Y {r} 2 tm\n",BORI,BEND
    printf "%% ------------------ Strand(%s) Begin\n",s
    for (srcord=0;srcord<lastcnt;srcord++) { # for sc in sources
      if (s=="-") { ngcnt=lastcnt-(srcord+1); sc=order["strand",ngcnt] }
      else {
        if (s=="+") sc=order["strand",srcord]
        else sc=order["none",srcord]      # (s==".")
        }
      printf "------ Source: %10s Strand: %s Counter: %s\n", sc, s, srcord | "cat 1>&2" 
      # if (n[sc,s]>0) 
      printf "(%s) %s %s (%s) source\n", sc"("s")", PLOT_FT[sc,":","track_scale"], PLOT_FT[sc,":","track_spacing_scale"],s
      scnt=0
      for (i=1;i<=ng[sc,s];i++) {
        scnt++
        g=group_[sc,s,i];
        for (j=1;j<=nl[sc,s] && grouping[sc,s,g,start] < endline[sc,s,j];j++);
        nl[sc,s] = j==nl[sc,s]+1 ? j : nl[sc,s];
        endline[sc,s,j]=grouping[sc,s,g,end];
	    # plot group in file
        if (Var["print_report"])
          printf "GROUP : %-10s : %s %10d %10d \n", g, s, grouping[sc,s,g,start], grouping[sc,s,g,end] | " sort +6 | cat 1>&2";
        if (PLOT_FT[g,":","label"]=="default") labl=g
        else labl=PLOT_FT[g,":","label"]
        if (plot_group[g,blocks,pages]==1) {
          printf "(%s) %s %s gp \n", checklbl(labl), grouping[sc,s,g,start], grouping[sc,s,g,end]
          printf "%s", grouping[sc,s,g,group,blocks,pages] | "sort +0nr +6nr +2n +3nr"
          close("sort +0nr +6nr +2n +3nr")
          printf "g_end\n"
          } # if plot_group
        } # for ng[]
        # if (n[sc,s]>0) 
        printf "s_end\n"
      }   # for sources
      printf "%% ------------------ Strand(%s) End\n",s
      if (prtrule && scnt>0) printf "%s %s XOriPlot Y {r} 2 tm\n",BORI,BEND
    }     # for strands
  if (Var["print_report"]) close(" sort +6 | cat 1>&2")

  # Closing Pages MAIN LOOP.
  #
    printf "b_end\n"
    BORI+=BOFFSET
    } # for blocks
  endPSpage(pages,pages)     # PostSCript Page Trailer.
  PORI+=POFFSET
  } # for pages

  # If not exist, create custom file (.gff2psrc)
  #
  if (Var["create_default_customfile"]) { 
    printf "\n%s\nCustom File:\n%s\n\n%s\n\n", BigLINE,BigLINE, Default["customfile_name_default"] | "cat 1>&2"
    if (Var["exist_default_customfile"]) {
      printf "Warning: I am going to rewrite your Default Custom File.\n" | "cat 1>&2"
      printf "         Moving last Default Custom File to %s.old\n",Default["customfile_name_default"] | "cat 1>&2"
      system("cp -v " Default["customfile_name_default"] " " Default["customfile_name_default"] ".old")
      }
    else {
      printf "Warning: Writing Default Custom File %s.\n",Default["customfile_name_default"] | "cat 1>&2"
      }
    CreateProps(2)
    }
  else {
    printf "\n%s%s\nWarning: Defaults were taken from program defaults,\n",BigLINE,BigLINE | "cat 1>&2"
    printf "         if you want to force program to write default file,\n" | "cat 1>&2"
    printf "         you must pass the command-line option -d to the program.\n" | "cat 1>&2"
    printf "         Default custom-file name: %s\n\n",Default["customfile_name_default"] | "cat 1>&2"
    printf "         ...See help for -d and -D <filename> options...\n" | "cat 1>&2"
    printf "%s%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    }

  # Object Properties Report...
  #
  if (Var["print_report"]) {
    printf "\n%s\nObject Properties Defined....\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    CreateProps(1)    }

}
function lcase(string,    chr) { for (chr in CM) gsub(chr,CM[chr],string); return string }
function min(a,b) { if (a<=b) return a; else return b }
function max(a,b) { if (a>=b) return a; else return b }
function ChkLimits(o,O,e,E) { if (e<=O || o>=E) return 0; else return 1 } # start_,BORI,end_,BEND
function OnOff(v) { if (lcase(v)~/^1$|^(on)$|^(y)(es)?$|^(t)(rue)?$/) return 1; else return 0 }
function ChkColor(ncolor) {
 if (ncolor~/^FG$|^black$|^white$|^(very)?(light|dark)?(grey|green|(sky)?blue|cyan|violet|red|orange|yellow|brown)$/)
   return 1
 else return 0 } # also when ncolor == ^BG$|(##DEFAULT##)
function checklbl(chain) {   gsub(/[\(]/,"\\050",chain); gsub(/[\)]/,"\\051",chain);
 gsub(/[\<]/,"\\074",chain); gsub(/[\>]/,"\\076",chain); gsub(/[\/]/,"\\057",chain);
 gsub(/[\%]/,"\\045",chain); gsub(/[\[]/,"\\133",chain); gsub(/[\]]/,"\\135",chain);
 gsub(/[\{]/,"\\173",chain); gsub(/[\}]/,"\\175",chain); return chain }
function chkpo(v) { if (v=="Portrait") return "false"; else return "true" }
function chkps(v,    vv) {
 vv=lcase(v)
 if (vv~/^(a)(2|3|4|5)$|^(b)(4|5)$|^executive$|^(le)(tter|gal|dger)$|^tabloid$|^userdefined$/)
   return vv
 else return "a4" }
function chkun(st,    t,p) {
 t=lcase(st);
 if (gsub(/cm(s)?/,"",t)>0) { p=t" cm"; return p }
 else {
   if (gsub(/in(ch)?(s)?/,"",t)>0) { p=t" in"; return p }
   else {
     if (gsub(/pt(s)?/,"",t)>0) return t
     else return "1 cm" }}}
function calcpt(st,    t,p) { # return points
 t=lcase(st);
 if (gsub(/cm(s)?/,"",t)>0) { p=t*28.35; return p }
 else {
   if (gsub(/in(ch)?(s)?/,"",t)>0) { p=t*72; return p }
   else {
     if (gsub(/pt(s)?/,"",t)>0) return t
     else return 0 }}}
function Nuc_round(nm,flg,    sign,nmp,i,mlt,smm,t) { # flg=0 then floor; flg=1 then ceiling.
 sign=nm<0?-1:1;
 if (sign==-1) { nm=-nm; flg=!(flg) }
 nmp=nm; for (i=1;nmp>10;i++) { nmp=nmp/10 };
 if (nm>=1000) mlt=2; else mlt=1;
 if (flg) {
   if (nm>0) {
     if (nm%10^(i-mlt)==0) smm=0; else smm=1;
	 t=nm>=100?sign*((int(nmp*10^(mlt-1))+smm)*10^(i-mlt)):sign*100 }
   else t=0 }
 else { if (nm>0) t=nm>=100?sign*((int(nmp*10^(mlt-1)))*10^(i-mlt)):0; else t=0 }
 return t }
#
function tick(nm) { # Still not adapted.
 end1=ESQ1-OSQ1; if (end1==0) end1=10000
 # end2=ESQ2-OSQ2; if (end2==0) end2=10000
 wy=max(end1,end2);
 y=wy/nm;
 ylog=(log(y)/log(10));
 yfloor=int(ylog);
 y1=y/(10^yfloor);
 y2=int(y1);
 t=y2*(10^yfloor);
 return t }
#
function Plot_Lbl(gff_feat) {
 if (PLOT_FT[gff_feat,":","label"]=="none") lbl=" ";
 else if (PLOT_FT[gff_feat,":","label"]=="default") lbl=gff_feat;
 else lbl=PLOT_FT[gff_feat,":","label"];
 return checklbl(lbl) }
function Set_feat_Clr(gff_feat,    clrmode,color1,color2) { # remaining to add vector definition colors.
 clrmode=0; color1=""; color2=""; # "none" or not defined
 k=split(PLOT_FT[gff_feat,":","color"],clm,"..");
 if (PLOT_FT[gff_feat,":","fill_shape_mode"]=="default") { clrmode=1; color1="FGcolor " }
 else if (PLOT_FT[gff_feat,":","fill_shape_mode"]=="1_color") { 
   clrmode=1; color1=PLOT_FT[gff_feat,":","color"]" " }
 else if (PLOT_FT[gff_feat,":","fill_shape_mode"]=="2_color") {
   clrmode=2; color1=clm[1]" "; if (k>=2) color2=clm[2]" "; else color2="FGcolor " }
 else if (PLOT_FT[gff_feat,":","fill_shape_mode"]=="frame-remainder") { clrmode=3 }
 else if (PLOT_FT[gff_feat,":","fill_shape_mode"]=="rainbow") { clrmode=4 }
 tmp=color1""color2""clrmode
 return tmp }
function Set_feat_Shape(gff_feat,src    ,shp,pos,tmp) {
 if (PLOT_FT[gff_feat,":","shape"]=="box") shp="box";
 else if (PLOT_FT[gff_feat,":","shape"]=="arrow") shp="arw";
 else if (PLOT_FT[gff_feat,":","shape"]=="end_arrow") shp="end";
 else if (PLOT_FT[gff_feat,":","shape"]=="circle") shp="cir";
 else shp="line";
  # else if (PLOT_FT[gff_feat,":","shape"]==" vector, spike, block ")
 if (PLOT_FT[src,":","vert_align"]=="center") pos="f";
 else if (PLOT_FT[src,":","vert_align"]=="baseline") pos="h";
 tmp=pos""shp;
 return tmp }
function showelemS(s,p,q,  string){
  string=" : ";
  string=string" "element[s,p,q,feature]" ";
  string=string" "element[s,p,q,start]" ";
  string=string" "element[s,p,q,end]" ";
  string=string" "element[s,p,q,frame]" ";
  string=string" "element[s,p,q,group];
  return string }
function showelem(a,b,     c,string){ c=n[a,b]; string=showelemS(s,p,q); return string }
function CreateProps(flag,    STRING,prop,dffeat,feat,gpfeat,sofeat) {
  ############ Create Properties Index for Objects ############ 
  STRING="#\n# L ######PAGE LAYOUT \& PROGRAM OPTIONS######\n#\n"
  if (flag==1) { 
    printf STRING | "cat 1>&2"
    for (dffeat in Default)
      printf "%s=%s\n", dffeat, Default[dffeat] | "sort 1>&2"
    }
  else if (flag==2) { 
    printf STRING > Default["customfile_name_default"]
    for (dffeat in Default)
      printf "%s=%s\n", dffeat, Default[dffeat] > Default["customfile_name_default"]
    }
  STRING="#\n# F ############GENOMIC FEATURES############\n#\n"
  if (flag==1) {
    close("sort 1>&2"); close("cat 1>&2")
    printf STRING | "cat 1>&2"
    }
  else if (flag==2) {
    close(Var["customfile_name_default"])
    printf STRING >> Default["customfile_name_default"]
    }
  for (feat in FT_ary) {
    for (prop in FT_PROP) {
      if (flag==0) PLOT_FT[feat,":",prop]=FT_PROP[prop]
      else if (flag==1)
	    printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] | "sort 1>&2"
      else if (flag==2)
	    printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] >> Default["customfile_name_default"]
      }
    if (flag==1)
      printf "# %s:%s=%s\n#\n", feat, "feature_number", FT_ary[feat] | "cat 1>&2"
    }
  STRING="#\n# G ############GROUP FEATURES############\n#\n"
  if (flag==1) { 
    close("sort 1>&2"); close("cat 1>&2")
    printf STRING | "cat 1>&2"
    }
  else if (flag==2) {
    close(Var["customfile_name_default"])
    printf STRING >> Default["customfile_name_default"]
    }
  for (gpfeat in GP_ary) {
    for (prop in GR_PROP) {
      if (flag==0) PLOT_FT[gpfeat,":",prop]=GR_PROP[prop]
      else if (flag==1)
	    printf "%s:%s=%s\n", gpfeat, prop, PLOT_FT[gpfeat,":",prop] | "sort 1>&2"
      else if (flag==2)
	    printf "%s:%s=%s\n", gpfeat, prop, PLOT_FT[gpfeat,":",prop] >> Default["customfile_name_default"] 
      }
    if (flag==1)
      printf "# %s:%s=%s\n#\n", gpfeat, "feature_number", GP_ary[gpfeat] | "cat 1>&2"
    # else if (flag==2)
    #   printf "# %s:%s=%s\n#\n", gpfeat, "feature_number", GP_ary[gpfeat] >> Default["customfile_name_default"]
    }
  STRING="#\n# S ############SOURCE FEATURES############\n#\n"
  if (flag==1) { 
    close("sort 1>&2"); close("cat 1>&2")
    printf STRING | "cat 1>&2"
    }
  else if (flag==2) {
    close(Var["customfile_name_default"])
    printf STRING >> Default["customfile_name_default"]
    }
  for (sofeat in sources) {
    for (prop in SO_PROP) {
      if (flag==0) PLOT_FT[sofeat,":",prop]=SO_PROP[prop]
      else if (flag==1)
	    printf "%s:%s=%s\n", sofeat, prop, PLOT_FT[sofeat,":",prop] | "sort 1>&2"
      else if (flag==2)
	    printf "%s:%s=%s\n", sofeat, prop, PLOT_FT[sofeat,":",prop] >> Default["customfile_name_default"]
      }
    if (flag==1)
      printf "# %s:%s=%s\n#\n", sofeat, "group_number", sources[sofeat] | "cat 1>&2"
    # else if (flag==2)
    #  printf "# %s:%s=%s\n#\n", sofeat, "group_number", sources[sofeat] >> Default["customfile_name_default"]
    }
  if (flag==1) { close("sort 1>&2"); close("cat 1>&2") }
  else if (flag==2) close(Default["customfile_name_default"])
 }
function RCFile(file,    STRING,nothere,first,gffirst,second,ft_type,feat) { ############ Read CustomFile
  STRING="Match between: %s & %s : %s=%s\n"
  while ((getline < file) > 0 ) {
   if ( $1!~/^(\#)+/ && NF>0 ) { 
    nothere=0;global=0
    split($0,defs,"=")
    split(defs[1],nwfeat,":")
    first=nwfeat[1]
    if (first=="*") { first=".*"; global=1 }
    gffirst=lcase(first)
    second=nwfeat[2]
    if (ft_type=="F") {
      for (feat in FT_ary) {
        if (match(feat,gffirst)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) {
            PLOT_FT[feat,":",second]=defs[2]
            nothere=1
            }
          if (Var["print_report"])
            printf "Feature "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      # print ">>>New Feature>>>" $0
      if (nothere==0 && !global) {
        FT_ary[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["print_report"])
          printf "No Match found - New Feature: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="G") {
      for (feat in GP_ary) { 
        if (match(feat,first)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) {
            PLOT_FT[feat,":",second]=defs[2]
            nothere=1
            }
          if (Var["print_report"])
            printf "Group "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      # print ">>>New Feature>>>" $0
      if (nothere==0 && !global) {
        GP_ary[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["print_report"])
          printf "No Match found - New Feature: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="S") {
      for (feat in sources) {
        if (match(feat,first)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) { 
            PLOT_FT[feat,":",second]=defs[2]
	        nothere=1
            }
          if (Var["print_report"])
            printf "Source "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      # print ">>>New Feature>>>" $0
      if (nothere==0 && !global) {
        sources[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["print_report"])
          printf "No Match found - New Feature: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="L") {
      if (defs[1] in Default) {
        PLOT_LY[defs[1]]=defs[2]
        if (Var["print_report"])
            printf "Layout "STRING,defs[1],first,defs[1],defs[2] | "cat 1>&2"
        }
      }
   }# if not empty or comment line 
   else 
     if ( $1~/^(\#)$/ && $2~/^[LFGS]$/) ft_type=$2
  } # while getline
  close(file) 
  # if (first==".*") { for (props in PLOT_FT) if ( }   
  #
  # Modifying Vars
  #
  if (Var["print_report"]) printf "\n%s\nCommand-Line Modified options...........\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
  for (lytdef in Default) {
    dft=Default[lytdef]
    if (dft==Var[lytdef] && PLOT_LY[lytdef]!="") Default[lytdef]=PLOT_LY[lytdef]
      else Default[lytdef]=Var[lytdef]
    if (Var["print_report"]) printf "%s : Default Value=%s Custom File=%s Command-Line=%s : Using=%s\n", lytdef,dft,PLOT_LY[lytdef],Var[lytdef],Default[lytdef] | "sort | cat 1>&2"
    }
    if (OnOff(PLOT_LY["load_customfile"])) Default["load_customfile"]=PLOT_LY["load_customfile"]
  close("sort | cat 1>&2")
 }
function defPSvars(){
 printf "%% BG \& FG colors\n";
 printf "/BGcolor { colordict begin %s end } def\n", Var["BACKGROUND_COLOR"];
 printf "/FGcolor { colordict begin %s end } def\n", Var["FOREGROUND_COLOR"];
 printf "%% page orientation flag\n";
 printf "/flglscape %s def\n", chkpo(Default["page_orientation"]);
 printf "%%%% page size in points used for plot % pgA4 == 595  842\n";
 printf "/Dpage { pagedict begin pg%s flglscape { exch } if end } bdf\n", chkps(Default["page_size"]);
 printf "%% margins (1 cm) (Up Down Left Right - margins are XY independent)\n";
 printf "/UpM %s def\n", chkun(Default["margin_upper"]);
 printf "/DnM %s def\n", chkun(Default["margin_bottom"]);
 printf "/LtM %s def\n", chkun(Default["margin_left"]);
 printf "/RtM %s def\n%%\n", chkun(Default["margin_right"]);
 printf "/TkMrkW %s def %% Defining tickmark-width.\n", chkun(Default["default_scale_width"]);
 printf "/BlckSp %s def %% Defining blocks-spacing\n%%\n", chkun(Default["default_block_spacing_width"]);
 printf "/SeqLen %s def\n", PDIF; 
 printf "/XNucOffSet %s def\n", PORI; 
 printf "/NPages %s def\n", P; 
 printf "/NBlck %s def\n", B; 
 printf "/MaxNuclPage %s def\n", POFFSET;
 printf "/MaxTick 100 def\n";
 printf "/MinTick  10 def\n%%\n";
 printf "/tracksize %s def\n", chkun(Default["default_track_width"]);
 printf "/spcrsize  %s def\n", chkun(Default["default_track_spacing_width"]);
 printf "/LnTot  %s def\n", BSize;     # size in points (size is relative here)
 printf "/LnFwd %s def\n", StrSizeFwd; # if they are 0 then not showed
 # printf "/FwdFlg %s def\n", OnOff(Default["strand_show_forward"]);
 printf "/LnRvs %s def\n", StrSizeRvs;
 # printf "/RvsFlg %s def\n", OnOff(Default["strand_show_reverse"]);
 printf "/LnBth %s def\n", NStSize;
 # printf "/BthFlg %s def\n", OnOff(Default["strand_show_independent"]);
 printf "/vectoffset 10 def\n";
 printf "/flpos true def %% flag for showing Seq Xpos for all elements.\n%%\n";
 printf "/Fbline true def %% flag for showing baseline for each method.\n";
 printf "/FgpLbl true def %% flag for showing baseline for each group.\n%%\n";
 printf "/XLftLbl 4 cm  def\n";
 printf "/FLftLbl true  def\n";
 printf "/XRgtLbl 4 cm  def\n";
 printf "/FRgtLbl true  def\n%%\n";
 printf "/XOriTitl 1 cm def\n";
 printf "/YOriTitl 0 cm def\n";
 printf "/YSTitl 1 cm def\n";
 printf "/FlgTitl true def\n";
 printf "%%\n" }
function startPSpage(num,tot,ns,ne){
 printf "%%%%Page: %s %s\n",num,num;
 printf "%%%%BeginPageSetup\n%%\n";
 printf "%% Saving current page settings\n";
 printf "/pgsave save def\n";
 printf "%% Defining pagenumber\n";
 printf "/PageNumber (Page %s/%s) def\n",num,tot;
 printf "%% Defining page variables\n";
 printf "/Y YOriBlck def\n";
 printf "/Nuc_Offset %s def\n",ns;
 printf "%% Setting BGcolor for sheet \n";
 printf "Dpage flglscape { exch } if 0 0 bbox FGcolor 1 tbbox BGcolor scmyk fill\n";
 printf "%% setting coordinate axes for page orientation\n";
 printf "flglscape\n";
 printf " { 90 rotate 1 -1 scale XORI YORI translate }                  %% (0,0) - Ori for landscape pages\n";
 printf " { XORI Dpage exch pop YORI sub translate 1 -1 scale } ifelse  %% (0,0) - Ori for portrait pages\n";
 printf "%% If testing output print bounding_boxes for page elements\n";
 printf "%%tflg { TB } if\n%%\n%% /FGcolor scolor\n%%\n";
 printf "%% Header\n%%\n";
 printf "%%%%EndPageSetup\n";
 printf "%%\n" }
function endPSpage(num,tot){
 printf "%%\ngrestoreall\npgsave restore\nshowpage\n%%\n%% PageEND: %s %s\n",num,tot;
 printf "%%\n" }
' - "$@"
#### Main GFF2APLOT GNU awk Program DONE.

#
# PostScript end of page (Trailer)
# 
  MAINPSTRAILER

#
##################### EOF #####################
#
exit 0
