#!/bin/sh
######################################################################
#                               gff2ps                               #
######################################################################
#
#     Converting GFF files to PostScript.
#
#     Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
#                                 Roderic GUIGO SERRA       
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
######################################################################
#
# Creation Date: 01.03.1999
# Last Update:
#         $Id: gff2ps,v 1.12 1999-06-08 12:24:28 jabril Exp $	
#
# Autor : Josep Francesc ABRIL FERRANDO
# e-mail: jabril@imim.es
#
# ( ./gff2ps -vC mygffcustomfile -- samples/data.gff > samples/.ps ) > & samples/report.
#

CMDLine=$0" "$*
##############################################################
#################### PROGRAM DEFINITIONS #####################
# 
# Defining Default Values...
#
Defaults () {
 # 
 # Constants: 
  PROGRAM="gff2ps"
  VERSION="v1.1"
  SHCREATION="01.03.1999"
  SHREVISION="01.06.1999"
  PSPROGRAM="gffPSplot"
  PSVERSION="v1.0"
  PSCREATION="01.06.1999"
  PSREVISION="01.06.1999"
  AUTHOR="Josep Francesc ABRIL FERRANDO"
  EMAIL="jabril@imim.es"
  MAIL="%%                  Dept. Informatica Medica
%%          Institut Municipal d'Investigacio Medica
%%                   C./ Doctor Aiguader 80
%%                  08003 - BARCELONA (SPAIN)"
  USAGE=$PROGRAM" [-h][-H <option>] gff_file"
  COLORS="    black | verydarkgrey | darkgrey | grey | lightgrey | verylightgrey | white 
       verydarkgreen | darkgreen | green | lightgreen | verylightgreen 
   verydarkskyblue | darkskyblue | skyblue | lightskyblue | verylightskyblue 
          verydarkblue | darkblue | blue | lightblue | verylightblue 
         verydarkcyan | darkcyan | cyan | lightcyan | verylightcyan 
     verydarkviolet | darkviolet | violet | lightviolet | verylightviolet 
            verydarkred | darkred | red | lightred | verylightred 
     verydarkorange | darkorange | orange | lightorange | verylightorange 
     verydarkyellow | darkyellow | yellow | lightyellow | verylightyellow 
        verydarkbrown | darkbrown | brown | lightbrown | verylightbrown"
 # 
 # Default User-Defined Options: 
  CFDIR=`pwd`
  bgcolor="white"
  fgcolor="black"
  v01="0"; n01="Load_CustomFile"
  v02=" "; n02="CustomFile_Name"
  v03="$CFDIR/.gff2psrc"; n03="Default_CustomFile_Name"
  v04="0"; n04="Exist_Default_CustomFile"
  v05="0"; n05="Print_Report"
  v06="Landscape"; n06="page_orientation"
}

#
# Defining Help...
#
Help () {
#  echo ""
#  echo "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
#  echo "         1         2         3         4         5         6         7         8"
  echo ""
  echo "NAME           $PROGRAM"
  echo "VERSION        $VERSION"
  echo ""
  echo "Creation DATE: $SHCREATION"
  echo "Last REVISION: $SHREVISION"
  echo ""
  echo "SYNOPSIS"
  echo ""
  echo "      $USAGE"
  echo ""
  echo "DESCRIPTION"
  echo ""
  echo "       This program draws color-filled DotPlots"
  echo "       from files with gff-formatted data fields."
  echo "   "
  echo ""
  echo "OPTIONS"
  echo ""
  echo "     -h  Show this help."
  echo "     -H <option> Show only help for the especified option."
  echo ""
  echo "COMMENTS"
  echo ""
  echo "  * Colors Defined are:"
  echo ""
  echo "$COLORS"
  echo ""
  echo "BUGS"
  echo ""
  echo "  Please, report bugs to:"
  echo "       $AUTHOR"
  echo "       e-mail: $EMAIL"
  echo "       Mail  : "
  gawk 'BEGIN{tt=ARGV[1];ARGV[1]="";gsub("\%\%","",tt);printf tt;print}' "$MAIL"
  echo ""
  return
}

ShowHelpLine () {
 Help | gawk 'BEGIN{
  IGNORECASE=1; flg=0; srch=ARGV[1]; ARGV[1]=""
  gsub("-","",srch); srch="\ -"srch"\ " }
  { if ($0~srch) { print $0; flg=1 } }
  END{ if (!flg) printf "\n\tERROR: Option %s is not defined,\n\t\tmake sure which option you need help.\n",srch }' $1 
 echo ""
 return
}

##############################################################
################# POSTSCRIPT MAIN FUNCTIONS ##################
#
# Printing %%Prolog Constant Definitions...
#
MAINPSCPR () {
cat <<'@@@EndCopyRight@@@'
% 
% $Id: gff2ps,v 1.12 1999-06-08 12:24:28 jabril Exp $
% 
%          Converting GFF files to PostScript plots.
%
%          Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
%                                      Roderic GUIGO SERRA       
%
%    This program is free software; you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation; either version 2 of the License, or
%    (at your option) any later version.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program; if not, write to the Free Software
%    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
%
% ------------------------------------------------------------------------
@@@EndCopyRight@@@
}

MAINPSPROLOG () {
cat <<'@@@EndProlog@@@'
%
%%BeginSetup
%
% true setpacking
true setstrokeadjust
0.125 setlinewidth
0 setlinejoin
0 setlinecap
%
% Fixed Color Variables (CMYK)
% -----------------------------
/colordict 80 dict def colordict begin % 52 colors + 28 definitions
/black            { 0.00 0.00 0.00 1.00 } def /verydarkgrey     { 0.00 0.00 0.00 0.90 } def
/darkgrey         { 0.00 0.00 0.00 0.75 } def /grey             { 0.00 0.00 0.00 0.50 } def
/lightgrey        { 0.00 0.00 0.00 0.25 } def /verylightgrey    { 0.00 0.00 0.00 0.10 } def
/white            { 0.00 0.00 0.00 0.00 } def /verydarkgreen    { 0.65 0.00 0.95 0.40 } def
/darkgreen        { 0.90 0.00 0.90 0.10 } def /green            { 1.00 0.00 1.00 0.00 } def
/lightgreen       { 0.50 0.00 1.00 0.00 } def /verylightgreen   { 0.25 0.00 0.75 0.00 } def
/verydarkskyblue  { 0.95 0.15 0.00 0.40 } def /darkskyblue      { 1.00 0.25 0.00 0.15 } def
/skyblue          { 1.00 0.25 0.00 0.00 } def /lightskyblue     { 0.80 0.20 0.10 0.00 } def
/verylightskyblue { 0.60 0.15 0.15 0.00 } def /verydarkblue     { 1.00 1.00 0.00 0.40 } def
/darkblue         { 1.00 1.00 0.00 0.10 } def /blue             { 1.00 1.00 0.00 0.00 } def
/lightblue        { 0.80 0.80 0.00 0.00 } def /verylightblue    { 0.50 0.50 0.00 0.00 } def
/verydarkcyan     { 0.65 0.15 0.00 0.25 } def /darkcyan         { 0.65 0.15 0.00 0.00 } def
/cyan             { 1.00 0.00 0.00 0.00 } def /lightcyan        { 0.50 0.00 0.00 0.00 } def
/verylightcyan    { 0.25 0.00 0.00 0.00 } def /verydarkviolet   { 0.40 0.80 0.20 0.00 } def
/darkviolet       { 0.45 0.85 0.00 0.00 } def /violet           { 0.30 0.60 0.00 0.00 } def
/lightviolet      { 0.15 0.55 0.00 0.00 } def /verylightviolet  { 0.05 0.45 0.00 0.00 } def
/verydarkred      { 0.00 0.90 0.90 0.30 } def /darkred          { 0.00 0.80 0.90 0.10 } def
/red              { 0.00 1.00 1.00 0.00 } def /lightred         { 0.05 0.80 0.90 0.00 } def
/verylightred     { 0.15 0.40 0.60 0.00 } def /verydarkorange   { 0.00 0.60 1.00 0.00 } def
/darkorange       { 0.00 0.55 0.90 0.00 } def /orange           { 0.00 0.50 0.70 0.00 } def
/lightorange      { 0.00 0.30 0.85 0.00 } def /verylightorange  { 0.00 0.30 0.55 0.00 } def
/verydarkyellow   { 0.00 0.10 0.85 0.25 } def /darkyellow       { 0.00 0.10 0.85 0.00 } def
/yellow           { 0.00 0.00 1.00 0.00 } def /lightyellow      { 0.00 0.00 0.50 0.00 } def
/verylightyellow  { 0.00 0.00 0.25 0.00 } def /verydarkbrown    { 0.00 0.85 1.00 0.70 } def
/darkbrown        { 0.00 0.75 1.00 0.60 } def /brown            { 0.00 0.70 1.00 0.40 } def
/lightbrown       { 0.30 0.60 0.70 0.00 } def /verylightbrown   { 0.15 0.45 0.55 0.00 } def
end % colordict
%
%  Paper Sizes  (in points) 
% --------------------------
/pagedict 14 dict def pagedict begin % Portrait { minor-axes:X major-axes:Y }
/pgA2          { 1190 1684 } def /pgA3          {  842 1190 } def
/pgA4          {  595  842 } def /pgA5          {  420  595 } def
/pgB4          {  708 1003 } def /pgB5          {  516  729 } def
/pgExecutive   {  540  720 } def /pgLedger      { 1224  792 } def
/pgLegal       {  612 1008 } def /pgLetter      {  612  792 } def
/pgTabloid     {  792 1224 } def /pgUserDefined {  595 2448 } def
end % pagedict
%
%   1 cm   = 28.35 points
%   1 inch = 72.00 points
/bdf { bind def } bind def
/xdf { exch def } bdf
/cm { 28.35 mul } bdf
%
%  Defining CONSTANTS
% --------------------
/TkMrkW 0.25 cm def                  % Defining tickmark-width.
/tflg false def                      % test flag
%
%  Defining VARIABLES
% --------------------
%
%  Page Layout
%%%% BG & FG colors
/BGcolor { colordict begin white end } def
/FGcolor { colordict begin black end } def 
%%%% page orientation flag
/flglscape true def
%%%% page size in points used for plot % pgA4 == 595  842
/Dpage { pagedict begin pgA4 flglscape { exch } if end } bdf
%%%% offset defines non printable paper area on portrait pages
/VUpOS 0.25 cm def
/VDnOS 0.25 cm def
/HLtOS 0.25 cm def
/HRtOS 0.25 cm def
%%%% margins (1 cm) (Up Down Left Right - margins are XY independent)
/UpM 1 cm def
/DnM 1 cm def
/LtM 1 cm def
/RtM 1 cm def
%%%% checking if margins are within the defined offset
flglscape {
 UpM HLtOS lt { /UpM HLtOS def } if % Checking margins for flglscape mode
 DnM HRtOS lt { /DnM HRtOS def } if
 LtM VDnOS lt { /LtM VDnOS def } if
 RtM VUpOS lt { /RtM VUpOS def } if
 } {
  UpM VUpOS lt { /UpM VUpOS def } if % Checking margins for portrait mode
  DnM VDnOS lt { /DnM VDnOS def } if
  LtM HLtOS lt { /LtM HLtOS def } if
  RtM HRtOS lt { /RtM HRtOS def } if
  } ifelse
%%%%  defining pagelimits and X - Y scales (Xlim Ylim)
/pglim { Dpage pop LtM RtM add sub Dpage exch pop UpM DnM add sub } def
% /pgXsc { pglim pop 100 div } def
% /pgYsc { pglim exch pop 100 div } def
%%%% Defining starting point on page.
/XORI LtM def
/YORI UpM def
%%%% Defining page layout.
/XOriTitl 1 cm def
/YOriTitl 0 cm def
/XSTitl pglim pop XOriTitl 2 mul sub def
/YSTitl 1 cm def
/FlgTitl true def
/BlckSp 0.25 cm def
/NBlck  1 def
/XSBlck pglim pop def
/YSBlck pglim exch pop YSTitl BlckSp NBlck mul add YOriTitl add sub NBlck div def
/XOriBlck 0 def
/YOriBlck YOriTitl YSTitl BlckSp add add def
/Y YOriBlck def
/XLftLbl 4 cm  def
/FLftLbl true  def
/XRgtLbl 4 cm  def
/FRgtLbl true  def
/XSPlot { XSBlck FLftLbl { XLftLbl sub } if FRgtLbl { XRgtLbl sub } if } def
/XOriPlot { XOriBlck FLftLbl { XLftLbl add } if } def
%
%  Newer vars
%
/spcrsize 5 def
/tracksize 10 def
/vectoffset 10 def
%
/Fbline true def % flag for showing baseline for each method.
/FgpLbl true def % flag for showing baseline for each group.
/down YSBlck def
/up   YSBlck def
/MaxNuclPage 1000 def
/Xscale XSPlot MaxNuclPage div def
/Yscale tracksize def
/MaxTick 100 def
/MinTick  10 def
%
@@@EndProlog@@@
}
#### End of MAINPSPROLOG function

#
# Printing Main PostScript Routines...
#
MAINPSPROCS () { 
cat <<'@@@MAINProcs@@@'
%
%  Calculating some variables
% ----------------------------
/LnTot LnFwd LnBth LnRvs add add def
/is2tck LnBth 0 gt LnFwd 0 gt LnRvs 0 gt and LnFwd 0 eq LnRvs 0 eq and or and def % true if must plot two tickmark lines
/putuptck LnFwd 0 gt LnFwd LnRvs add 0 eq or def
/putdntck LnBth 0 gt LnFwd LnBth add 0 eq or def
/TmpYSB YSBlck TkMrkW is2tck { 2 mul } if sub def  % Adjusting plot area size with tickmarks.
/YSLine YSBlck LnTot div def
/YSFwd LnFwd LnTot div TmpYSB mul def
/YOriFwd YOriBlck def
/YSBth LnBth LnTot div TmpYSB mul def
/YOriBth YOriFwd YSFwd add putuptck { TkMrkW add } if def
/YSRvs LnRvs LnTot div TmpYSB mul def
/YOriRvs YOriBth YSBth add putdntck { TkMrkW add } if def
%
%%EndSetup
%
%%BeginProlog
%
%%BeginProcSet: functions 1.0 0
/min { 2 copy gt { exch } if pop } bdf 
/max { 2 copy lt { exch } if pop } bdf
/Xscm { Xscale mul } bdf /Xscme { Xscm exch } bdf
/Yscm { Yscale mul } bdf /Yscme { Yscm exch } bdf
/ChkLimits { 3 copy pop 5 2 roll dup dup 5 1 roll 3 1 roll lt 3 1 roll gt or { pop false } { true } ifelse } def % or%%EndProcSet:   functions 1.0 0
%
%%BeginProcSet: text_functions 1.0 0
/sfont { findfont exch scalefont setfont } bdf
/stringheight  { gsave newpath 0 0 moveto (0) false charpath flattenpath pathbbox exch pop exch sub exch pop 0.95 mul grestore } bdf
/ct { gsave 0 translate sfont scmyk dup stringwidth pop 2 div neg stringheight 2 div moveto show grestore } bdf
%%EndProcSet:   text_functions 1.0 0
%
%%BeginProcSet: painting_functions 1.0 0
/scmyk { setcmykcolor } bdf
/scolor { colordict exch get exec scmyk } bdf 
colordict begin % adding definitions and functions
 /lup { /ku xdf /yu xdf /mu xdf /cu xdf } bdf
 /lmd { /km xdf /ym xdf /mm xdf /cm xdf } bdf
 /ldn { /kd xdf /yd xdf /md xdf /cd xdf } bdf
 /load2col { lup ldn /dk ku kd sub def /dy yu yd sub def /dm mu md sub def /dc cu cd sub def } bdf
 /load3col { lup lmd ldn /uk ku km sub def /uy yu ym sub def /um mu mm sub def /uc cu cm sub def /dk km kd sub def /dy ym yd sub def /dm mm md sub def /dc cm cd sub def } bdf
 /col2 { 2 dict begin /p xdf /pcd { p mul add } bdf cd dc pcd md dm pcd yd dy pcd kd dk pcd scmyk end } bdf
 /col3 { 3 dict begin /p xdf /pcd { p 2 mul mul add } bdf /pcu { p 0.5 sub 2 mul mul add } bdf p 0.5 le { cd dc pcd md dm pcd yd dy pcd kd dk pcd } { cm uc pcu mm um pcu ym uy pcu km uk pcu } ifelse scmyk end } bdf
 /rainbow { 1 dict begin /p xdf p 0.1 le { p 0.2 div 0.5 add 1 0 0 scmyk } { p 0.4 le { 1 1 p 0.1 sub 0.3 div sub 0 0 scmyk } { p 0.6 le { 1 0 p 0.4 sub 0.2 div 0 scmyk } { p 0.8 le { 1 p 0.6 sub 0.2 div sub 0 1 0  scmyk } { 0 p 0.8 sub 0.2 div 1 0 scmyk } ifelse } ifelse } ifelse } ifelse end } bdf
end % colordict
%%EndProcSet:   painting_functions 1.0 0
%
%%BeginProcSet: drawing_functions 1.0 0
/dotted { [ 1 ] 0 setdash } def
/bbox { 4 copy 3 1 roll exch 6 2 roll 8 -2 roll moveto lineto lineto lineto closepath } bdf
/tbbox { tflg { gsave setlinewidth scmyk stroke grestore } { pop pop } ifelse } def
%%EndProcSet:   drawing_functions 1.0 0
%
%%BeginProcSet: tickmarks 1.4 0
% Rule.ps ---> rules and scales
/tmdct 22 dict def tmdct begin
 /ShowGrid 0 def % 0 - none : 1 - MinTicks : 2 - MaxTicks : 3 - Both
 /Gridup true def /Griddn true def /flgup true def
 /TkMrkHW TkMrkW  2 div def
 /TkMrkDW TkMrkW 10 div def
 /TkFont { TkMrkHW /Helvetica } def
 /MaxWidthT { gsave MaxNuclPage 10 string cvs TkFont sfont stringwidth pop 2 mul grestore } bdf
 /CheckCloser { 3 copy pop MaxWidthT sub 3 1 roll MaxWidthT add 3 1 roll dup dup 5 1 roll 3 1 roll lt 3 1 roll gt or 4 1 roll 3 copy dup 3 1 roll ne 3 1 roll ne and 5 -1 roll and { pop false } { true } ifelse } bdf
 /ctextick { gsave TkFont sfont dup stringheight 2 div exch stringwidth pop 2 Xscm div neg Xscm exch 2 copy neg translate 2 mul exch 2 mul neg exch gsave 0 0 bbox BGcolor scmyk gsave tflg { FGcolor scmyk } if 2 setlinewidth stroke grestore fill grestore 0 0 moveto FGcolor scmyk show grestore } bdf
 /bltextick { gsave TkFont sfont dup stringwidth pop 2 Xscm div neg Xscm TkMrkHW 2 copy flgup { TkMrkDW add translate } { 2 mul translate 1 -1 scale } ifelse exch 2 mul neg exch gsave 0 0 bbox BGcolor scmyk gsave tflg { FGcolor scmyk } if 2 setlinewidth stroke grestore fill grestore 0 0 moveto FGcolor scmyk show grestore } bdf
 /tonormtick { 0 eq { dup dup 0 ne { MinTick mod } if sub exch dup dup 0 ne { MinTick mod } if sub exch } { dup dup 0 ne { MaxTick mod } if sub exch dup dup 0 ne { MaxTick mod } if sub exch } ifelse } bdf
 /Mkg { 0 0 moveto lineto FGcolor scmyk dotted stroke } bdf
 /MkVGrid { gsave setlinewidth Gridup flgup not { not } if { 0 up Mkg } if Griddn flgup not { not } if { 0 down neg Mkg } if  grestore } bdf
 /MkAtick { setlinewidth 0 TkMrkHW neg moveto 0 TkMrkHW lineto FGcolor scmyk stroke } bdf
 /MkBtick { gsave dup Xscm 0 translate ShowGrid 2 eq ShowGrid 3 eq or { 0.25 MkVGrid } if 1 MkAtick CheckCloser { 10 string cvs ctextick } if grestore } bdf
 /MkCtick { setlinewidth 0 0 moveto 0 TkMrkHW 3 -1 roll { TkMrkDW sub } if lineto FGcolor scmyk stroke } bdf
 /MkDtick { gsave dup Xscm 0 translate CheckCloser { 10 string cvs bltextick } if ShowGrid 2 eq ShowGrid 3 eq or { 0.25 MkVGrid } if false 1 MkCtick grestore } bdf
 /baseline { gsave Xscm TkMrkDW moveto Xscm TkMrkDW lineto TkMrkDW 2 mul setlinewidth FGcolor scmyk stroke grestore } bdf
 /r { /Gridup true def /Griddn true def /flgup true def gsave TkMrkHW add translate 1 -1 scale 5 { 2 copy } repeat pop neg Xscm 0 translate 0 tonormtick MinTick exch { ChkLimits { gsave Xscm 0 translate 0.25 MkAtick ShowGrid 1 eq ShowGrid 3 eq or { 0 MkVGrid } if grestore } if } for 1 tonormtick MaxTick exch { ChkLimits { MkBtick } if } for 2 { dup dup 0 ne { MaxTick mod } if 0 ne { MkBtick } { pop } ifelse } repeat grestore } bdf
 /x { 6 { 2 copy } repeat pop neg Xscm 0 translate baseline 0 tonormtick MinTick exch { ChkLimits { gsave Xscm 0 translate true 0.25 MkCtick ShowGrid 1 eq ShowGrid 3 eq or { 0 MkVGrid } if grestore } if } for 1 tonormtick MaxTick exch { ChkLimits { MkDtick } if } for 2 { dup dup 0 ne { MaxTick mod } if 0 ne { MkDtick } { pop } ifelse } repeat } bdf 
 /s { /Gridup false def /Griddn true def /flgup true def gsave translate 1 -1 scale x grestore } bdf
 /z { /Gridup true def /Griddn false def /flgup false def gsave TkMrkW add translate 1 1 scale x grestore } bdf
end % tmdct
%%EndProcSet:   tickmarks 1.4 0
%
%%BeginProcSet: objects 1.0 0
/shpdct 38 dict def shpdct begin
 /Line-Yscale 5 def
 /mtrx matrix def
 /cpt { moveto { lineto } repeat closepath } bdf
 /fline { 0 0 moveto 1 0 lineto closepath } bdf
 /hline { fline } bdf
 /harw {  0.0  0.0  -1.0  0.0  -1.0  0.75 -1.1  0.75 -1.1  0.75  5  0.0  1.0  cpt } bdf
 /farw {  0.6  0.75  0.6  0.75  0.5  0.75  0.5  0.0  -0.5  0.0
         -0.5  0.75 -0.6  0.75 -0.6  0.75                        8  0.0  1.0  cpt } bdf
 /hend {  0.0  0.0   0.0 -1.0   1.0 -1.0                         3  0.0  0.75  cpt } bdf
 /fend {  1.0  0.5   0.0  0.5   0.0 -0.5   1.0 -0.5              4  0.0  0.75 cpt } bdf
 /hbox {  0.0  1.0  -1.0  1.0  -1.0  0.0                         3  0.0  0.0  cpt } bdf
 /fbox {  0.5  0.0   0.5  1.0  -0.5  1.0                         3 -0.5  0.0  cpt } bdf
 /hcir { -0.5  0.5   0.5  0 360 arc closepath } bdf
 /fcir {  0.0  0.5   0.5  0 360 arc closepath } bdf
%%% /getcol { colordict begin /ct xdf /s end } bdf
% must define frame colors /frm0 /frm1 /frm2...
 /getfrcol { dup 0 eq { pop frm0 } { dup 1 eq { pop frm1 } { 2 eq { frm2 } if } ifelse } ifelse } bdf
 /cmdln { 0 moveto sqdif 2 div 0 lineto scmyk stroke } bdf
 /lnfill { gsave Line-Yscale setlinewidth sqdif cmdln 0 cmdln grestore } bdf
 /frmfill { frm getfrcol rmd getfrcol lnfill } bdf
 /rnbfill { 2 dict begin gsave Line-Yscale setlinewidth /incr sqdif 100 div def 0 incr sqdif { gsave dup dup incr add 0 exch 0 moveto lineto rainbow stroke grestore } for grestore end } bdf 
 /setcolmod { aload pop dup 1 eq { pop scmyk fill } { dup 2 eq { pop lnfill } { dup 3 eq { pop frmfill } { dup 4 eq { pop rnbfill } { 0 eq { BGcolor scmyk fill } if } ifelse } ifelse } ifelse } ifelse } bdf
% /setcolmod { colordict begin aload pop dup 1 eq { pop scolor fill } { dup 2 eq { pop lnfill } { dup 3 eq { pop frmfill } { dup 4 eq { pop rnbfill } { 0 eq { BGcolor scmyk fill } if } ifelse } ifelse } ifelse } ifelse end } bdf
 /getvar { /ftlbl xdf /sc xdf /rmd xdf /frm xdf strnd (-) eq { exch } if 2 copy exch sub dup /sqdif exch Xscm def /sqdsc exch Xscale div def /seqend exch Xscm def /seqori exch Xscm def } bdf
 /frshared { /svmtrix mtrx currentmatrix def Xscale sqdsc div Line-Yscale scale exec svmtrix setmatrix gsave BGcolor scmyk 1 setlinewidth stroke grestore clip setcolmod } bdf
 /f { gsave getvar strnd (-) eq { seqori 0 translate -1 -1 scale } { seqori 0 translate 1 1 scale } ifelse frshared grestore } bdf
 /gpuline { gsave grori 0.5 moveto grend 0.5 lineto /red scolor stroke grestore } bdf
 /shgplbl { FgpLbl { gsave gpuline grori 0.5 translate grlbl FGcolor 8 /Helvetica grdif 2 div ct grestore } if } bdf 
 /g_end { exit end } bdf 
end % shpdct
%%EndProcSet:   objects 1.0 0
%
%%BeginProcSet: vectors 1.6 0
% Objects.ps ---> vectors
/vctdct 6 dict def vctdct begin
 /resizetrack tracksize 0.95 mul def
 /vtoffset vectoffset 2 div Xscm def
 /clrselc { colordict begin dup 2 eq { pop load2col /clrproc { {col2} } def } { dup 3 eq { pop load3col /clrproc { {col3} } def } { dup 0 eq { pop white black load2col /clrproc { {col2} } def } { dup 4 eq { pop /clrproc { {rainbow} } def } { 1 eq { white 8 4 roll load2col /clrproc { {col2} } def } if } ifelse } ifelse } ifelse } ifelse } bdf % no end for closing dict because grdct must be closed by calling function
 /v { gsave Xscm dup vtoffset sub exch vtoffset add 0 moveto 0 lineto resizetrack setlinewidth clrproc exec stroke grestore } bdf
 /ovend { end exit } bdf   % end is for grdct dict
end % vctdct
%%EndProcSet:   vectors 1.5 0
%
%%BeginProcSet: main_function_calls 1.0 0
%
/tm { tmdct begin /ShowGrid xdf exec end } bdf
%
% /objects
/bline { Fbline { gsave FGcolor scmyk 0 0 moveto XSPlot 0 lineto stroke grestore } if } bdf
/shsrclbl { FLftLbl { gsave srclbl FGcolor 10 /Courier XLftLbl 2 div neg ct grestore } if } bdf 
/source { gsave 3 dict begin /nxtspacer exch spcrsize mul def /Yscl exch tracksize mul def /srclbl xdf /Y Y Yscl add def XOriPlot Y translate 1 -1 scale bline shsrclbl } bdf
/endsource { end grestore /Y Y nxtspacer add def } bdf
%
/gp { gsave shpdct begin /strnd xdf strnd (-) eq { exch } if 2 copy exch sub /grdif exch Xscm def /grend exch Xscm def /grori exch Xscm def /grlbl xdf shgplbl colordict begin { currentfile token { exec } { exit } ifelse } loop end grestore } bdf
%
/ov { gsave vctdct begin exch Xscm exch translate { currentfile token { exec } { exit } ifelse } loop end grestore } bdf
%
%%EndProcSet:   main_function_calls 1.0 0
%%EndProlog
@@@MAINProcs@@@
} 
#### End of MAINPSPROCS function

#
# PostScript end of page... 
# 
MAINPSTRAILER () {
cat <<'@@@EndTrailer@@@'
%%Trailer
%
%%EOF
@@@EndTrailer@@@
} 
#### End of MAINPSTRAILER function

##############################################################
####################### PROGRAM FUNCTIONS ####################
#
# Testing parameters passed by User: Colors.
#
CheckColor () {
  gawk 'BEGIN{
    color=ARGV[1]
    if (color!~/^BG$|^FG$|^black$|^white$|^(very)?(light|dark)?(grey|green|(sky)?blue|cyan|violet|red|orange|yellow|brown)$/) {
      printf "\n<<<<ERROR>>>> \" %s \" is not a defined color.\n", color | "cat 1>&2"
      printf "              Default \" black \" is asigned to option.\n" | "cat 1>&2"
      printf "              You can choose one of this colors:\n" | "cat 1>&2"
      print ARGV[3] | "cat 1>&2"
      print "" | "cat 1>&2"
      color=ARGV[2]
      }
    print color
    ARGV[1]=ARGV[2]=ARGV[3]=""
    }' $1 $2 "$COLORS"
  return 0
}

#
# Testing parameters passed by User: Integer Numbers.
#
CheckInt () {
  if [ `expr $1 : '[0-9]*'` -eq `expr $1 : '.*'` ]
    then echo "1"; return 0
    else 
      echo "<<<<ERROR>>>> \" $1 \" is not an integer value." 1>&2
      echo "              You must especify an integer value to -$W_OPTION" 1>&2
      echo "              Program will take value from defaults..." 1>&2
      echo "" 1>&2
      echo "0";return 1
    fi
  return 1
}

###################################################################
################## MAIN GFF2PS SHELL SCRIPT #######################
#
###################################################################
################## Choosing Options for GFF2PS ####################
#
# Resetting default program variables.
#
Defaults

#
# Checking if default custom file exists
#  else switch on flag to create.
#
echo "" 1>&2
echo "Report: You have typed the following command line:" 1>&2
echo "" 1>&2
echo $CMDLine 1>&2
echo "" 1>&2
if [ ! -f "$CFDIR/.gff2psrc" ]
  then v04="0"
       echo "Warning: Default Custom File does not exist." 1>&2 
       echo "         Program is going to write a Local Custom File." 1>&2 
  else v04="1" # Exist_Default_CustomFile
       echo "Report: Using Default Custom File ($CFDIR/.gff2psrc)." 1>&2 
  fi

#
# When no options, no parameters and 
#  no inputstream are given, print USAGE.
#
if [ $# -eq 0 ] 
  then
    echo; echo $USAGE; echo; exit 1
  fi

#
# Asking for Help, output it to screen. 
#
case $1 in
  -h) Help; exit 2;;
  -H) echo; echo $PROGRAM" : Option Definition Help."; echo;
      if [ $# -gt 1 ]; 
        then shift; fi;
      for temp in $@;
        do ShowHelpLine $temp; done;
      exit 2;;
  esac

#
# Processing all options and parameters passed to program.
#
while getopts :C:vpHh W_OPTION
  do
    case $W_OPTION in
      H|h) Help; exit 2;;
      C) if [ ! -f $CFDIR/$OPTARG ];    # Load_CustomFile CustomFile_Name
           then v01="0";
                echo "Error: Custom File $OPTARG does not exist...Not Loaded." 1>&2 ;
           else v01="1";
	        echo "Report: Adding $OPTARG Custom File to Default (.gff2psrc)." 1>&2 ;
                v02="$CFDIR/$OPTARG";
         fi;;
      v) v05="1";;                      # Print_Report
      p) v06="Portrait";;               # page_orientation
       :) ShowHelpLine $1; exit 2;;
      \?) ShowHelpLine $1; exit 2;;
    esac # case $W_OPTION
  done   # while getopts

#
# Shifting all options tested before,
# without removing files passed to shell...
#
 incr=1
 while [ $OPTIND -gt $incr ]
   do shift; incr=`expr $incr + 1`; done

#
# Defining PLOToptions STRING for GNU awk programs.
#
   P=$n01":="$v01"::"$n02":="$v02"::"$n03":="$v03"::"$n04":="$v04"::"$n05":="$v05
 PLOToptions=$P
 if [ $v05 -eq 1 ]
   then
     echo "" 1>&2
     echo "********************************************" 1>&2
     echo ">>>>> Option String Passed to Program <<<<<<" 1>&2
     echo "********************************************" 1>&2
     echo "" 1>&2
     echo $PLOToptions 1>&2
     echo "" 1>&2
   fi

###################################################################
############### CONVERTING GFF TO POSTSCRIPT ######################
#
# Printing PostScript Header...
#
gawk 'BEGIN{ 
 # Find actual date...
 "date" | getline d
 split(d,dt," ")
 date = dt[3] "." dt[2] "." dt[6] " " substr(dt[4],1,5)
 # Finding logged user...
 "whoami" | getline usr
 # Printing PostScript Header...
 bigchain=        "%%\!PS-Adobe-2.0\n"
 bigchain=bigchain"%%%%Title: %s\n"
 bigchain=bigchain"%%\n%%%%User: %s\n"
 bigchain=bigchain"%%%%Date: %s\n"
 bigchain=bigchain"%%\n%%%%Program: %s\n"
 bigchain=bigchain"%%%%Version: %s\n"
 bigchain=bigchain"%%%%CreationDate: %s\n"
 bigchain=bigchain"%%%%LastRevision: %s\n"
 bigchain=bigchain"%%%%Author : %s\n"
 bigchain=bigchain"%%%%e-mail : %s\n"
 bigchain=bigchain"%%%%Mail Adress:\n%s\n%%\n"
 if (ARGV[1]!~"##dflt##") title=ARGV[1]
 else title="GFF to PostScript"
 printf bigchain, title, usr, date, ARGV[2], ARGV[3], ARGV[4], ARGV[5], ARGV[6], ARGV[7], ARGV[8]
 printf "%%\n%% ------------------------------------------------------------------------\n"
 printf "%%                           %s - %s\n",ARGV[2], ARGV[3]
 printf "%% ------------------------------------------------------------------------\n"
  for (i=1;i<=8;i++) ARGV[i]=""
}' "##dflt##" "$PSPROGRAM" "$PSVERSION" "$PSCREATION" "$PSREVISION" "$AUTHOR" "$EMAIL" "$MAIL"

#
# Printing PostScript Prolog...
#
  MAINPSCPR
  echo "%%Orientation: "$v06 # "page_orientation"
  echo "%%BoundingBox:  0  0  842   595"
  MAINPSPROLOG

#
# Main GFF2PS GNU awk Program...
#
# (cat <<'@@@EndPROGRAM@@@') |
# @@@EndPROGRAM@@@
# gawk -v CUSTOMFILE=$CFDIR/.gff2aplot.rc -f - "$@"
#
(echo $PLOToptions; MAINPSPROCS) |
gawk 'BEGIN{
  ############ INITIALITATION ############

  # defaults
  MINSCORE=0.25;
  MAXSCORE=1.00;
  BigLINE="########################################"

  # gff data structure
  seqname  = 1;
  source   = 2;
  feature  = 3;
  start    = 4;
  end      = 5;
  score    = 6;
  strand   = 7;
  frame    = 8;
  group    = 9;

  # gff strand codification
  strands["+"]=strands["-"]=strands["."]=1;

  # Find actual date...
  "date" | getline d
  split(d,dt," ")
  date = dt[3] "." dt[2] "." dt[6] " " substr(dt[4],1,5)
  # Finding logged user...
  "whoami" | getline usr
  # Finding current process...
  "echo $$" | getline IDP

  # Loading PSMainProgram. Line 0 is the Command Line Parameter String.
  psline=0
  while ((getline < ARGV[1])>0) PSMAIN[psline++]=$0;
  ARGV[1]=""

 ############## Defining pre-variables by CommandLine ############ 
 PARAM=PSMAIN[0]
 npar=split(PARAM,parm,"::") 
 for (r=1;r<=npar;r++) {
   split(parm[r],elem,":=")
   if (elem[2]!="##dflt##") {
     if (elem[1]~/COLOR\$/) {
       ecolor=elem[2]
       if (ChkColor(ecolor)) {
         if (ecolor~/^BG\$|(##DEFAULT##)/) { elem[2]=Pre["BACKGROUND_COLOR"] }
         else if (ecolor~/^FG\$/) { elem[2]=Pre["FOREGROUND_COLOR"] }
         }
       else { elem[2]=Pre["BACKGROUND_COLOR"] }
       }
     Pre[elem[1]]=elem[2]
     }
   }
  for (v in Pre) Var[v]=Pre[v]
  for (v in Var) printf "VAR: %-25s :: Value: %s\n", v, Var[v] | "cat 1>&2" 

# Layout Properties
  Default["page_size"]="a4"
  Default["page_orientation"]=Var["page_orientation"]
  Default["margin_left"]="1cm"
  Default["margin_right"]="1cm"
  Default["margin_upper"]="1cm"
  Default["margin_bottom"]="1cm"
  Default["foreground_color"]="FGcolor"
  Default["background_color"]="BGcolor"
  Default["block_number"]=1
  Default["strand_show_forward"]="on"
  Default["strand_show_reverse"]="on"
  Default["strand_show_independent"]="on"
# General Properties
  Default["text_color"]=Default["foreground_color"]
  Default["label"]="none"
# Features Properties
  FT_PROP["fill_shape_mode"]="default" # none(BGcolor), default(FGcolor 1color), 1_color, 2_color, frame-remainder, rainbow
  FT_PROP["fill_vector_mode"]="default" # default(0 black grad), rainbow(1), 1_color(BGcolor color 2), 2_color(color1 color2 2), 3_color(col1 col2 col3 2)
  FT_PROP["label"]="default" # none , default , "user-def"
  FT_PROP["color"]=Default["foreground_color"] # 1color(color),2color(color..color),3color(color..color..color)
  FT_PROP["shape"]="box" #box, arrow, end_arrow, circle, vector, spike, block
  FT_PROP["vert_align"]="baseline" #center,baseline
  FT_PROP["layer"]=0
  FT_PROP["show"]="on"
# Group Properties
  GR_PROP["label"]="default" # none , default , "user-def"
  GR_PROP["rank"]="0:1" # rank of lower-upper scores
  #  GR_PROP["vert_align"]="center" # center or baseline
  GR_PROP["join_align"]="center"
  GR_PROP["join_color"]=Default["foreground_color"]
  GR_PROP["join_linetype"]="solid"
  GR_PROP["join_show"]="off"
# Lines (Method-Source) Properties
  SO_PROP["label"]="default" # none , default , "user-def"
  SO_PROP["vert_align"]="center" # center or baseline
  SO_PROP["baseline_align"]="center"
  SO_PROP["baseline_color"]=Default["foreground_color"]
  SO_PROP["baseline_linetype"]="dotted"
  SO_PROP["baseline_show"]="off"
  SO_PROP["bbox_color"]=Default["foreground_color"]
  SO_PROP["bbox_show"]="off"
  SO_PROP["scale"]=2
  SO_PROP["spacing_scale"]=0.5
  SO_PROP["rule_scale"]="nucleotide"
  SO_PROP["rule_rel"]="none"
  SO_PROP["rule_abs"]="none"
# Default[""]=

 # Data for upper-case to lower-case function #lcase()#
 CM["A"]="a";CM["B"]="b";CM["C"]="c";CM["D"]="d";CM["E"]="e";
 CM["F"]="f";CM["G"]="g";CM["H"]="h";CM["I"]="i";CM["J"]="j";
 CM["K"]="k";CM["L"]="l";CM["M"]="m";CM["N"]="n";CM["O"]="o";
 CM["P"]="p";CM["Q"]="q";CM["R"]="r";CM["S"]="s";CM["T"]="t";
 CM["U"]="u";CM["V"]="v";CM["W"]="w";CM["X"]="x";CM["Y"]="y";
 CM["Z"]="z";CM["Ñ"]="ñ";CM["Ç"]="ç"

 if (Var["Print_Report"]) 
   printf "\n%s\nInput File...\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
 }
{ ############ READING .GFF FILES  ############

  # skips those comment lines (starting with "#") or empty lines
  #
  is_EOF=0
  while ($0~/^(\#)+/ || NF==0 ) { 
    if (Var["Print_Report"]) 
      printf "%10s :: Not Read :: %s\n", NR, $0 | "cat 1>&2"
    if (getline<=0) { is_EOF=1; break }
    }

 if (!is_EOF) {

  # Printing Input Lines
  #
  if (Var["Print_Report"]) 
   printf "%10s : %s\n", NR, $0 | "cat 1>&2"

  # read gff element within source and strand
  #
  sources[$source]++;                       # field 2 (source) counter
  if ($group=="") $group=".";               # empty group defined as default (none==".")
  GP_ary[$group]++;                         # field 9 (group) counter
#   The same as ng[sc,s] 
#   GP_SO[$source,$strand,$group]++;          # groups per source and strand
  FT_ary[$feature]++;                       # field 3 (gff-feature) counter
#   FT_GP[$source,$strand,$group,$feature]++; # features per group, source and strand
  n[$source,$strand]++;                     # elements per source and strand
  $feature=lcase($feature);
  element[$source,$strand,n[$source,$strand],feature] = $feature; 
  element[$source,$strand,n[$source,$strand],start]   = $start;
  element[$source,$strand,n[$source,$strand],end]     = $end;
  element[$source,$strand,n[$source,$strand],frame]   = $frame;  
  element[$source,$strand,n[$source,$strand],score]   = $score;  
  element[$source,$strand,n[$source,$strand],group]   = $group; 
  if ($NF>group) {
    for (i=(group+1);i<=$NF;i++) {
      if ($i~"Label")
        element[$source,$strand,n[$source,$strand],$i]= $(i+1);  
    }
  }

  # recompute scores between MINSCORE and MAXSCORE
  #
  if ($score < MINSCORE)
    element[$source,$strand,n[$source,$strand],score]  = MINSCORE;
  else if ($score > MAXSCORE)
    element[$source,$strand,n[$source,$strand],score]  = MAXSCORE;

  # place gff element in sort array by acceptor position
  #
  ns=n[$source,$strand]-1;
  while ($start < element[$source,$strand,S[$source,$strand,ns],start]) {
    S[$source,$strand,ns+1]=S[$source,$strand,ns];
    ns--;
  }
  S[$source,$strand,ns+1]=n[$source,$strand]

 } # if (!is_EOF)

}
END{

  # Printing elements sorted
  #
  if (Var["Print_Report"]) {
   printf "\n%s\ngff elements are sorted...\n%s\n",BigLINE,BigLINE | "cat 1>&2"
   for (sc in sources) 
    for (s in strands) {
      printf "\nSOURCE: %s\nSTRAND: %s\n",sc,s | "cat 1>&2"
      if (n[sc,s]>0)
        for (i=1;i<=n[sc,s];i++) {
          printf "%10s %s\n", S[sc,s,i],showelemS(sc,s,S[sc,s,i]) | "cat 1>&2"
        
        }
      else
        printf "%10s This block is empty ##\n", "##" | "cat 1>&2"
      }
   close("cat 1>&2")
   }

  # Defining Object Properties
  #
  CreateProps(0)
  if (Var["Print_Report"]) printf "\n%s\nReading Default Custom File...\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
  if (Var["Exist_Default_CustomFile"]) RCFile(Var["Default_CustomFile_Name"])
  if (Var["Print_Report"]) printf "\n%s\nReading Custom File...........\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
  if (Var["Load_CustomFile"]) RCFile(Var["CustomFile_Name"])

  # make groups. assumes elements sorted by increasing acceptor position
  #
  cntstr_fwd=cntstr_bth=cntstr_rvs=0
  printf "\n%s\nPostScript Code...\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
  for (sc in sources) {
    for (s in strands) {
      for (i=1;i<=n[sc,s];i++) {
	    tgr=element[sc,s,S[sc,s,i],group];
	    if (!grouping[sc,s,tgr,start]) {
	      grouping[sc,s,tgr,start]=element[sc,s,S[sc,s,i],start];
	      ng[sc,s]++;
	      group_[sc,s,ng[sc,s]]=tgr
          }
        grouping[sc,s,tgr,end]= element[sc,s,S[sc,s,i],end];

        # for gene mode. try to recompute relative frame and remainder
        start_=element[sc,s,S[sc,s,i],start];
        end_=element[sc,s,S[sc,s,i],end];
        feature_=element[sc,s,S[sc,s,i],feature];
        score_=element[sc,s,S[sc,s,i],score];

        frame_[sc,s,tgr]= element[sc,s,S[sc,s,i],frame];

        if (feature_=="First" || feature_=="Single") 
          frame_[sc,s,tgr]=0;
        else if (feature_=="Internal" || feature_=="Terminal" )
          frame_[sc,s,tgr]=remainder_[sc,s,tgr];

        remainder_[sc,s,tgr]=(3-(end_-(start_+frame_[sc,s,tgr])+1)%3)%3;
mylbl=Plot_Lbl(feature_)
        printf "%s %s %s : [ %s ] { %s } %d %d %d %d %4.2f (%s) f\n", sc,s,i, Set_feat_Clr(feature_), Set_feat_Shape(feature_,sc), start_, end_, frame_[sc,s,tgr] ,remainder_[sc,s,tgr], score_, Plot_Lbl(feature_) | "cat 1>&2"
        grouping[sc,s,tgr,group] = sprintf("%s[ %s ] { %s } %d %d %d %d %4.2f (%s) f\n", grouping[sc,s,tgr,group], Set_feat_Clr(feature_), Set_feat_Shape(feature_,sc), start_, end_, frame_[sc,s,tgr] ,remainder_[sc,s,tgr], score_, Plot_Lbl(feature_))
      } # for i
        printf "\n" | "cat 1>&2"
    }   # for s
    # Percent of plot area for each strand
    if (ng[sc,"+"]>0) cntstr_fwd+=PLOT_FT[sc,":","scale"]
    if (ng[sc,"."]>0) cntstr_bth+=PLOT_FT[sc,":","scale"]
    if (ng[sc,"-"]>0) cntstr_rvs+=PLOT_FT[sc,":","scale"]
  }     # for sc
  cntstr_TOT=cntstr_fwd+cntstr_bth+cntstr_rvs
  printf "/LnFwd %s def %% groups for each strand\n/LnBth %s def\n/LnRvs %s def\n", cntstr_fwd/cntstr_TOT, cntstr_bth/cntstr_TOT, cntstr_rvs/cntstr_TOT

  # PostScript Main Procs.
  #
  for (i=1;i<psline;i++) print PSMAIN[i]; 

  # PostSCript PageSetup.
  #
  startPSpage(1,1)

  # PostScript Drawing strands, sources, groups, features
  #
  # make plotlines. Put non-overlapping groups into the same plotting line.
  #
  if (Var["Print_Report"]) printf "\n%s\nPrinting Lines...............\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
  for (s in strands) {
#    printf "(%s) setstrand\n", s
    for (sc in sources) {
      if (n[sc,s]>0) printf "(%s) %s %s source\n", sc, PLOT_FT[sc,":","scale"], PLOT_FT[sc,":","spacing_scale"]
      for (i=1;i<=ng[sc,s];i++) {
        g=group_[sc,s,i];
        for (j=1;j<=nl[sc,s] && grouping[sc,s,g,start] < endline[sc,s,j];j++);
        nl[sc,s] = j==nl[sc,s]+1 ? j : nl[sc,s];
        endline[sc,s,j]=grouping[sc,s,g,end];
	    # plot group in file
        if (Var["Print_Report"])
          printf "GROUP : %-10s : %s %10d %10d \n", g, s, grouping[sc,s,g,start], grouping[sc,s,g,end] | " sort +6 | cat 1>&2";
        if (PLOT_FT[g,":","label"]=="default") labl=g
        else labl=PLOT_FT[g,":","label"]
        printf "(%s) %s %s (%s) gp \n%sg_end\n", checklbl(labl), grouping[sc,s,g,start], grouping[sc,s,g,end], s, grouping[sc,s,g,group]
        } # for ng[]
        if (n[sc,s]>0) printf "endsource\n"
      }   # for sources
#    printf "clrstrand\n", s
    }     # for strands
  if (Var["Print_Report"]) close(" sort +6 | cat 1>&2")

  # PostSCript Page Trailer.
  #
  endPSpage()

  # If not exist, create custom file (.gff2psrc)
  #
  printf "\n%s\nCustom File:\n%s\n\n%s\n\n", BigLINE,BigLINE, Var["Default_CustomFile_Name"] | "cat 1>&2"
  if (!Var["Exist_Default_CustomFile"]) CreateProps(2)

  # Object Properties Report...
  #
  if (Var["Print_Report"]) {
    printf "\n%s\nDefining Object Properties..........\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    CreateProps(1)    }

}
function min(a,b) { if (a<=b) return a; else return b }
function max(a,b) { if (a>=b) return a; else return b }
function ChkXlim(o,e) { if (o>=ESQ1 || e<=OSQ1) return 0; else return 1 } # Still not adapted.
function ChkYlim(o,e) { if (o>=ESQ2 || e<=OSQ2) return 0; else return 1 } # Still not adapted.
function OnOff(value) { if (value~/^1$|^ON$|^Y(ES)?$|^T(RUE)?$/) return 1; else return 0 }
function ChkColor(ncolor) {
 if (ncolor~/^FG$|^black$|^white$|^(very)?(light|dark)?(grey|green|(sky)?blue|cyan|violet|red|orange|yellow|brown)$/)
   return 1
 else return 0 # also when ncolor == ^BG$|(##DEFAULT##)
 }
function tick(nm) { # Still not adapted.
 end1=ESQ1-OSQ1; if (end1==0) end1=10000
 end2=ESQ2-OSQ2; if (end2==0) end2=10000
 wy=max(end1,end2);
 y=wy/nm;
 ylog=(log(y)/log(10));
 yfloor=int(ylog);
 y1=y/(10^yfloor);
 y2=int(y1);
 t=y2*(10^yfloor);
 return t
 }
function lcase(string) {
  for (chr in CM) gsub(chr,CM[chr],string)
  return string
}
function checklbl(chain) {
 gsub(/[\(]/,"\\050",chain)
 gsub(/[\)]/,"\\051",chain)
 gsub(/[\<]/,"\\074",chain)
 gsub(/[\>]/,"\\076",chain)
 gsub(/[\_]/," ",chain)             
 return chain
}
function Plot_Lbl(gff_feat) {
  if (PLOT_FT[gff_feat,":","label"]=="none") lbl=" "
  else if (PLOT_FT[gff_feat,":","label"]=="default") lbl=gff_feat
  else lbl=PLOT_FT[gff_feat,":","label"]
  return checklbl(lbl)
}
function Set_feat_Clr(gff_feat) { # remaining to add vector definition colors.
  clrmode=0; color1=""; color2=""; # "none" or not defined
  k=split(PLOT_FT[gff_feat,":","color"],clm,"..")
  if (PLOT_FT[gff_feat,":","fill_shape_mode"]=="default") { clrmode=1; color1="FGcolor " }
  else if (PLOT_FT[gff_feat,":","fill_shape_mode"]=="1_color") { clrmode=1; color1=PLOT_FT[gff_feat,":","color"]" " }
  else if (PLOT_FT[gff_feat,":","fill_shape_mode"]=="2_color") { clrmode=2; color1=clm[1]" "; if (k>=2) color2=clm[2]" "; else color2="FGcolor " }
  else if (PLOT_FT[gff_feat,":","fill_shape_mode"]=="frame-remainder") { clrmode=3 }
  else if (PLOT_FT[gff_feat,":","fill_shape_mode"]=="rainbow") { clrmode=4 }
  tmp=color1""color2""clrmode
  return tmp
}
function Set_feat_Shape(gff_feat,src) {
 if (PLOT_FT[gff_feat,":","shape"]=="box") shp="box"
 else if (PLOT_FT[gff_feat,":","shape"]=="arrow") shp="arw"
 else if (PLOT_FT[gff_feat,":","shape"]=="end_arrow") shp="end"
 else if (PLOT_FT[gff_feat,":","shape"]=="circle") shp="cir"
 else shp="line"
  # else if (PLOT_FT[gff_feat,":","shape"]==" vector, spike, block ")
 if (PLOT_FT[src,":","vert_align"]=="center") pos="f"
 else if (PLOT_FT[src,":","vert_align"]=="baseline") pos="h"
 tmp=pos""shp
 return tmp
}
#function Plot_Feature(gff_feat) {
#  if (PLOT_FT[gff_feat,":","label"]=="default") lbl=gff_feat
#  else lbl=PLOT_FT[gff_feat,":","label"]
#  return sprintf("(%s) /%s /%s pf", checklbl(lbl), PLOT_FT[gff_feat,":","color"], PLOT_FT[gff_feat,":","shape"])
#  PLOT_FT[feat,":","layer"]
#  PLOT_FT[feat,":","show"]
#}
# function PRT_strand(st) {  # Plotting all elements of each strand.
#   printf "%s setstrand\n", st
#   for (sc in sources) {
#     printf "%s %s setsource\n", nl[sc,st],PLOT_FT[sc,":","scale"]
#     }
# }
function CreateProps(flag) {
  ############ Create Properties Index for Objects ############ 
  STRING="#\n# L ############PAGE LAYOUT############\n#\n"
  if (flag==1) { 
    printf STRING | "cat 1>&2"
    for (dffeat in Default)
      printf "%s=%s\n", dffeat, Default[dffeat] | "sort 1>&2"
    }
  else if (flag==2) { 
    printf STRING > Var["Default_CustomFile_Name"]
    for (dffeat in Default)
      printf "%s=%s\n", dffeat, Default[dffeat] > Var["Default_CustomFile_Name"]
    }
  STRING="#\n# F ############GENOMIC FEATURES############\n#\n"
  if (flag==1) {
    close("sort 1>&2"); close("cat 1>&2")
    printf STRING | "cat 1>&2"
    }
  else if (flag==2) {
    close(Var["Default_CustomFile_Name"])
    printf STRING >> Var["Default_CustomFile_Name"]
    }
  for (feat in FT_ary) {
    for (prop in FT_PROP) {
      if (flag==0) PLOT_FT[feat,":",prop]=FT_PROP[prop]
      else if (flag==1)
	    printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] | "sort 1>&2"
      else if (flag==2)
	    printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] >> Var["Default_CustomFile_Name"]
      }
    if (flag==1)
      printf "# %s:%s=%s\n#\n", feat, "feature_number", FT_ary[feat] | "cat 1>&2"
    # else if (flag==2)
    #   printf "# %s:%s=%s\n#\n", feat, "feature_number", FT_ary[feat] >> Var["Default_CustomFile_Name"]
    }
  STRING="#\n# G ############GROUP FEATURES############\n#\n"
  if (flag==1) { 
    close("sort 1>&2"); close("cat 1>&2")
    printf STRING | "cat 1>&2"
    }
  else if (flag==2) {
    close(Var["Default_CustomFile_Name"])
    printf STRING >> Var["Default_CustomFile_Name"]
    }
  for (gpfeat in GP_ary) {
    for (prop in GR_PROP) {
      if (flag==0) PLOT_FT[gpfeat,":",prop]=GR_PROP[prop]
      else if (flag==1)
	    printf "%s:%s=%s\n", gpfeat, prop, PLOT_FT[gpfeat,":",prop] | "sort 1>&2"
      else if (flag==2)
	    printf "%s:%s=%s\n", gpfeat, prop, PLOT_FT[gpfeat,":",prop] >> Var["Default_CustomFile_Name"] 
      }
    if (flag==1)
      printf "# %s:%s=%s\n#\n", gpfeat, "feature_number", GP_ary[gpfeat] | "cat 1>&2"
    # else if (flag==2)
    #   printf "# %s:%s=%s\n#\n", gpfeat, "feature_number", GP_ary[gpfeat] >> Var["Default_CustomFile_Name"]
    }
  STRING="#\n# S ############SOURCE FEATURES############\n#\n"
  if (flag==1) { 
    close("sort 1>&2"); close("cat 1>&2")
    printf STRING | "cat 1>&2"
    }
  else if (flag==2) {
    close(Var["Default_CustomFile_Name"])
    printf STRING >> Var["Default_CustomFile_Name"]
    }
  for (sofeat in sources) {
    for (prop in SO_PROP) {
      if (flag==0) PLOT_FT[sofeat,":",prop]=SO_PROP[prop]
      else if (flag==1)
	    printf "%s:%s=%s\n", sofeat, prop, PLOT_FT[sofeat,":",prop] | "sort 1>&2"
      else if (flag==2)
	    printf "%s:%s=%s\n", sofeat, prop, PLOT_FT[sofeat,":",prop] >> Var["Default_CustomFile_Name"]
      }
    if (flag==1)
      printf "# %s:%s=%s\n#\n", sofeat, "group_number", sources[sofeat] | "cat 1>&2"
    # else if (flag==2)
    #  printf "# %s:%s=%s\n#\n", sofeat, "group_number", sources[sofeat] >> Var["Default_CustomFile_Name"]
    }
    if (flag==1) { close("sort 1>&2"); close("cat 1>&2") }
    else if (flag==2) close(Var["Default_CustomFile_Name"])
}
function RCFile(file) { ############ Read CustomFile
  STRING="Match between: %s & %s : %s=%s\n"
  while ((getline < file) > 0 ) {
   if ( $1!~/^(\#)+/ && NF>0 ) { 
    nothere=0
    split($0,defs,"=")
    split(defs[1],nwfeat,":")
    first=nwfeat[1]
    if (first=="*") first=".*" 
    gffirst=lcase(first)
    second=nwfeat[2]
    if (ft_type=="F") {
      for (feat in FT_ary) {
        if (match(feat,gffirst)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) {
            PLOT_FT[feat,":",second]=defs[2]
            nothere=1
            }
          if (Var["Print_Report"])
            printf "Feature "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      # print ">>>New Feature>>>" $0
      if (nothere==0) {
        FT_ary[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["Print_Report"])
          printf "No Match found: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="G") {
      for (feat in GP_ary) { 
        if (match(feat,first)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) {
            PLOT_FT[feat,":",second]=defs[2]
            nothere=1
            }
          if (Var["Print_Report"])
            printf "Group "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      # print ">>>New Feature>>>" $0
      if (nothere==0) {
        GP_ary[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["Print_Report"])
          printf "No Match found: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="S") {
      for (feat in sources) {
        if (match(feat,first)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) { 
            PLOT_FT[feat,":",second]=defs[2]
	        nothere=1
            }
          if (Var["Print_Report"])
            printf "Source "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      # print ">>>New Feature>>>" $0
      if (nothere==0) {
        sources[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["Print_Report"])
          printf "No Match found: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="L") {
      if (defs[1] in PLOT_FT) {
        PLOT_FT[defs[1]]=defs[2]
        if (Var["Print_Report"])
            printf "Layout "STRING,def[1],first,(defs[1]":"second),defs[2] | "cat 1>&2"
        }
      }
   }# if not empty or comment line 
   else if ( $1~/^(\#)$/ && $2~/^[LFGS]$/) { 
     ft_type=$2
     }
  } # while getline
  close(file)  
}
function showelemS(s,p,q){
  string=" : "
  string=string" "element[s,p,q,feature]" "
  string=string" "element[s,p,q,start]" "
  string=string" "element[s,p,q,end]" "
  string=string" "element[s,p,q,frame]" "
  string=string" "element[s,p,q,group]
  return string
 }
function showelem(a,b){
  string=" : "
  string=string" "element[a,b,n[a,b],feature]" "
  string=string" "element[a,b,n[a,b],start]" "
  string=string" "element[a,b,n[a,b],end]" "
  string=string" "element[a,b,n[a,b],frame]" "
  string=string" "element[a,b,n[a,b],group]
  return string
 }
function startPSpage(num,tot){
 printf "%%%%Page: %s %s\n",num,num
 printf "%%%%BeginPageSetup\n%%\n"
 printf "%% Saving current page settings\n"
 printf "/pgsave save def\n"
 printf "%% Defining pagenumber\n"
 printf "/PageNumber (Page %s/%s) def\n",num,tot
 printf "%% Setting BGcolor for sheet \n"
 printf "Dpage flglscape { exch } if 0 0 bbox FGcolor 1 tbbox BGcolor scmyk fill\n"
 printf "%% setting coordinate axes for page orientation\n"
 printf "flglscape\n"
 printf " { 90 rotate 1 -1 scale XORI YORI translate }                  %% (0,0) - Ori for landscape pages\n"
 printf " { XORI Dpage exch pop YORI sub translate 1 -1 scale } ifelse  %% (0,0) - Ori for portrait pages\n"
 printf "%% If testing output print bounding_boxes for page elements\n"
 printf "%%tflg { TB } if\n%%\n%% /FGcolor scolor\n%%\n"
 printf "%% Header\n%%\n"
 printf "%%%%EndPageSetup\n%%\n"
 printf "0 1000 XOriPlot Y {s} 3 tm\n"
 }
function endPSpage(){
 printf "%%\n%%pgsave restore\ngrestoreall\nshowpage\n%%\n"
 }
' - "$@"
#### Main GFF2APLOT GNU awk Program DONE.

#
# PostScript end of page (Trailer)
# 
  MAINPSTRAILER

#
##################### EOF #####################
#
exit 0
