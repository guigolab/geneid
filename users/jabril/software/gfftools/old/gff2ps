#!/bin/sh
######################################################################
#                               gff2ps                               #
######################################################################
#
#     Converting GFF files to PostScript.
#
#     Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
#                                 Roderic GUIGO SERRA       
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
######################################################################
#
# Creation Date: 01.03.1999
# Last Update:
#         $Id: gff2ps,v 1.15 1999-06-16 15:58:04 jabril Exp $	
#
# Autor : Josep Francesc ABRIL FERRANDO
# e-mail: jabril@imim.es
#
# ( ./gff2ps -vC mygffcustomfile -- samples/data.gff > samples/.ps ) > & samples/report.
#

 CMDLine=$0" "$*
# CMDLine=`history | gawk '{last=$0}END{print last}' -`
# CMDLine=`history | gawk '{$1=$2="";last[NR]=$0}END{print last[NR-1]}' -`

##############################################################
#################### PROGRAM DEFINITIONS #####################
# 
# Defining Default Values...
#
Defaults () {
 # 
 # Constants: 
  PROGRAM="gff2ps"
  VERSION="v1.1"
  SHCREATION="01.03.1999"
  SHREVISION="01.06.1999"
  PSPROGRAM="gffPSplot"
  PSVERSION="v1.0"
  PSCREATION="01.06.1999"
  PSREVISION="01.06.1999"
  AUTHOR="Josep Francesc ABRIL FERRANDO"
  EMAIL="jabril@imim.es"
  MAIL="%%                  Dept. Informatica Medica
%%          Institut Municipal d'Investigacio Medica
%%                   C./ Doctor Aiguader 80
%%                  08003 - BARCELONA (SPAIN)"
  USAGE=$PROGRAM" [-h][-H <option>] gff_file"
  COLORS="    black | verydarkgrey | darkgrey | grey | lightgrey | verylightgrey | white 
       verydarkgreen | darkgreen | green | lightgreen | verylightgreen 
   verydarkskyblue | darkskyblue | skyblue | lightskyblue | verylightskyblue 
          verydarkblue | darkblue | blue | lightblue | verylightblue 
         verydarkcyan | darkcyan | cyan | lightcyan | verylightcyan 
     verydarkviolet | darkviolet | violet | lightviolet | verylightviolet 
            verydarkred | darkred | red | lightred | verylightred 
     verydarkorange | darkorange | orange | lightorange | verylightorange 
     verydarkyellow | darkyellow | yellow | lightyellow | verylightyellow 
        verydarkbrown | darkbrown | brown | lightbrown | verylightbrown"
 # 
 # Default User-Defined Options: 
  CFDIR=`pwd`
  if [ $GFFDIR ]
    then
      if [ -d "$GFFDIR" ]                  ###### Environment variable for working directory.
        then
          CFDIR="$GFFDIR"
        fi
    fi
  bgcolor="white"
  fgcolor="black"
  v01="0"; n01="load_customfile"
  v02=""; n02="customfile_name"
  if [ $GFF_CUSTOM_FILE ]         ###### Environment variable for default custom file name.
    then
      v03="$CFDIR/$GFF_CUSTOM_FILE"
    else
      v03="$CFDIR/.gff2psrc"
    fi
    n03="default_customfile_name"
  v04="0"; n04="exist_default_customfile"
  v04_1="0"; n04_1="create_default_customfile"
  v05="0"; n05="print_report"
  v06="Landscape"; n06="page_orientation"
  v07="a4"; n07="page_size"
  v08="1"; n08="page_number"
  v09="1"; n09="blocks_x_page"
  v10="0"; n10="nucleotides_x_line"
  v11="1"; n11="show_blocks_top-bottom"
# Layout Properties
  c01="1cm"; m01="margin_left"
  c02="1cm"; m02="margin_right"
  c03="1cm"; m03="margin_upper"
  c04="1cm"; m04="margin_bottom"
  c05="FGcolor"; m05="foreground_color"
  c06="BGcolor"; m06="background_color"
  c07=5; m07="max_blocks_x_page"
  c08="on"; m08="strand_show_forward"
  c09="on"; m09="strand_show_reverse"
  c10="on"; m10="strand_show_independent"
  c11=$c01; m11="text_color"
  c12="none"; m12="label"
}

#
# Defining Help...
#
Help () {
#  echo ""
#  echo "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
#  echo "         1         2         3         4         5         6         7         8"
  echo ""
  echo "NAME           $PROGRAM"
  echo "VERSION        $VERSION"
  echo ""
  echo "Creation DATE: $SHCREATION"
  echo "Last REVISION: $SHREVISION"
  echo ""
  echo "SYNOPSIS"
  echo ""
  echo "      $USAGE"
  echo ""
  echo "DESCRIPTION"
  echo ""
  echo "       This program draws color-filled DotPlots"
  echo "       from files with gff-formatted data fields."
  echo "   "
  echo ""
  echo "OPTIONS"
  echo ""
  echo "     -h  Shows this help."
  echo "     -H <option> Show only help for the especified option."
  echo "     -C <custom_filename>  Load given custom file and append to default custom file (.gff2psrc)."
  echo "     -v Verbose mode, a report is sent to standard error."
  echo "     -p Switch page orientation to Portrait (default is Landscape)."
  echo ""
  echo "COMMENTS"
  echo ""
  echo "  * Colors Defined are:"
  echo ""
  echo "$COLORS"
  echo ""
  echo "BUGS"
  echo ""
  echo "  Please, report bugs to:"
  echo "       $AUTHOR"
  echo "       e-mail: $EMAIL"
  echo "       Mail  : "
  gawk 'BEGIN{tt=ARGV[1];ARGV[1]="";gsub("\%\%","",tt);printf tt;print}' "$MAIL"
  echo ""
  return
}

ShowHelpLine () {
 Help | gawk 'BEGIN{
  IGNORECASE=1; flg=0; srch=ARGV[1]; ARGV[1]=""
  gsub("-","",srch); srch="\ -"srch"\ " }
  { if ($0~srch) { print $0; flg=1 } }
  END{ if (!flg) printf "\n\tERROR: Option %s is not defined,\n\t\tmake sure which option you need help.\n",srch }' $1 
 echo ""
 return
}

##############################################################
################# POSTSCRIPT MAIN FUNCTIONS ##################
#
# Printing %%Prolog Constant Definitions...
#
MAINPSCPR () {
cat <<'@@@EndCopyRight@@@'
% 
% $Id: gff2ps,v 1.15 1999-06-16 15:58:04 jabril Exp $
% 
%          Converting GFF files to PostScript plots.
%
%          Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
%                                      Roderic GUIGO SERRA       
%
%    This program is free software; you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation; either version 2 of the License, or
%    (at your option) any later version.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program; if not, write to the Free Software
%    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
%
% ------------------------------------------------------------------------
@@@EndCopyRight@@@
}

MAINPSSETUP () {
cat <<'@@@EndProlog@@@'
%
%%BeginSetup
%
% true setpacking
true setstrokeadjust
0.125 setlinewidth
0 setlinejoin
0 setlinecap
%
%   1 cm   = 28.35 points
%   1 inch = 72.00 points
/bdf { bind def } bind def
/xdf { exch def } bdf
/cm { 28.35 mul } bdf
%
% Fixed Color Variables (CMYK)
% -----------------------------
/colordict 80 dict def colordict begin % 52 colors + 28 definitions
/black            { 0.00 0.00 0.00 1.00 } def /verydarkgrey     { 0.00 0.00 0.00 0.90 } def
/darkgrey         { 0.00 0.00 0.00 0.75 } def /grey             { 0.00 0.00 0.00 0.50 } def
/lightgrey        { 0.00 0.00 0.00 0.25 } def /verylightgrey    { 0.00 0.00 0.00 0.10 } def
/white            { 0.00 0.00 0.00 0.00 } def /verydarkgreen    { 0.65 0.00 0.95 0.40 } def
/darkgreen        { 0.90 0.00 0.90 0.10 } def /green            { 1.00 0.00 1.00 0.00 } def
/lightgreen       { 0.50 0.00 1.00 0.00 } def /verylightgreen   { 0.25 0.00 0.75 0.00 } def
/verydarkskyblue  { 0.95 0.15 0.00 0.40 } def /darkskyblue      { 1.00 0.25 0.00 0.15 } def
/skyblue          { 1.00 0.25 0.00 0.00 } def /lightskyblue     { 0.80 0.20 0.10 0.00 } def
/verylightskyblue { 0.60 0.15 0.15 0.00 } def /verydarkblue     { 1.00 1.00 0.00 0.40 } def
/darkblue         { 1.00 1.00 0.00 0.10 } def /blue             { 1.00 1.00 0.00 0.00 } def
/lightblue        { 0.80 0.80 0.00 0.00 } def /verylightblue    { 0.50 0.50 0.00 0.00 } def
/verydarkcyan     { 0.65 0.15 0.00 0.25 } def /darkcyan         { 0.65 0.15 0.00 0.00 } def
/cyan             { 1.00 0.00 0.00 0.00 } def /lightcyan        { 0.50 0.00 0.00 0.00 } def
/verylightcyan    { 0.25 0.00 0.00 0.00 } def /verydarkviolet   { 0.40 0.80 0.20 0.00 } def
/darkviolet       { 0.45 0.85 0.00 0.00 } def /violet           { 0.30 0.60 0.00 0.00 } def
/lightviolet      { 0.15 0.55 0.00 0.00 } def /verylightviolet  { 0.05 0.45 0.00 0.00 } def
/verydarkred      { 0.00 0.90 0.90 0.30 } def /darkred          { 0.00 0.80 0.90 0.10 } def
/red              { 0.00 1.00 1.00 0.00 } def /lightred         { 0.05 0.80 0.90 0.00 } def
/verylightred     { 0.15 0.40 0.60 0.00 } def /verydarkorange   { 0.00 0.60 1.00 0.00 } def
/darkorange       { 0.00 0.55 0.90 0.00 } def /orange           { 0.00 0.50 0.70 0.00 } def
/lightorange      { 0.00 0.30 0.85 0.00 } def /verylightorange  { 0.00 0.30 0.55 0.00 } def
/verydarkyellow   { 0.00 0.10 0.85 0.25 } def /darkyellow       { 0.00 0.10 0.85 0.00 } def
/yellow           { 0.00 0.00 1.00 0.00 } def /lightyellow      { 0.00 0.00 0.50 0.00 } def
/verylightyellow  { 0.00 0.00 0.25 0.00 } def /verydarkbrown    { 0.00 0.85 1.00 0.70 } def
/darkbrown        { 0.00 0.75 1.00 0.60 } def /brown            { 0.00 0.70 1.00 0.40 } def
/lightbrown       { 0.30 0.60 0.70 0.00 } def /verylightbrown   { 0.15 0.45 0.55 0.00 } def
end % colordict
%
%  Defining CONSTANTS
% --------------------
/TkMrkW 0.25 cm def                  % Defining tickmark-width.
/tflg false def                      % test flag
%
%  Defining VARIABLES
% --------------------
%
%  Paper Sizes  (in points)  <--- Probably it is better to generate each time.
% --------------------------
/pagedict 14 dict def pagedict begin % Portrait { minor-axes:X major-axes:Y }
/pgA2          { 1190 1684 } def /pgA3          {  842 1190 } def
/pgA4          {  595  842 } def /pgA5          {  420  595 } def
/pgB4          {  708 1003 } def /pgB5          {  516  729 } def
/pgExecutive   {  540  720 } def /pgLedger      { 1224  792 } def
/pgLegal       {  612 1008 } def /pgLetter      {  612  792 } def
/pgTabloid     {  792 1224 } def /pgUserDefined {  595 2448 } def
end % pagedict
%
%  Page Layout
%%%% BG & FG colors
/BGcolor { colordict begin white end } def
/FGcolor { colordict begin black end } def 
%%%% page orientation flag
/flglscape true def
%%%% page size in points used for plot % pgA4 == 595  842
/Dpage { pagedict begin pgA4 flglscape { exch } if end } bdf
%%%% offset defines non printable paper area on portrait pages
/VUpOS 0.25 cm def
/VDnOS 0.25 cm def
/HLtOS 0.25 cm def
/HRtOS 0.25 cm def
%%%% margins (1 cm) (Up Down Left Right - margins are XY independent)
/UpM 1 cm def
/DnM 1 cm def
/LtM 1 cm def
/RtM 1 cm def
%%%% checking if margins are within the defined offset
flglscape {
 UpM HLtOS lt { /UpM HLtOS def } if % Checking margins for flglscape mode
 DnM HRtOS lt { /DnM HRtOS def } if
 LtM VDnOS lt { /LtM VDnOS def } if
 RtM VUpOS lt { /RtM VUpOS def } if
 } {
  UpM VUpOS lt { /UpM VUpOS def } if % Checking margins for portrait mode
  DnM VDnOS lt { /DnM VDnOS def } if
  LtM HLtOS lt { /LtM HLtOS def } if
  RtM HRtOS lt { /RtM HRtOS def } if
  } ifelse
%%%%  defining pagelimits and X - Y scales (Xlim Ylim)
/pglim { Dpage pop LtM RtM add sub Dpage exch pop UpM DnM add sub } def
% /pgXsc { pglim pop 100 div } def
% /pgYsc { pglim exch pop 100 div } def
%%%% Defining starting point on page.
/XORI LtM def
/YORI UpM def
%%%% Defining page layout.
/XOriTitl 1 cm def
/YOriTitl 0 cm def
/XSTitl pglim pop XOriTitl 2 mul sub def
/YSTitl 1 cm def
/FlgTitl true def
/BlckSp 0.25 cm def
/NBlck  1 def
/XSBlck pglim pop def
/YSBlck pglim exch pop YSTitl BlckSp NBlck mul add YOriTitl add sub NBlck div def
/XOriBlck 0 def
/YOriBlck YOriTitl YSTitl BlckSp add add def
/Y YOriBlck def
/XLftLbl 4 cm  def
/FLftLbl true  def
/XRgtLbl 4 cm  def
/FRgtLbl true  def
/XSPlot { XSBlck FLftLbl { XLftLbl sub } if FRgtLbl { XRgtLbl sub } if } def
/XOriPlot { XOriBlck FLftLbl { XLftLbl add } if } def
%
%  Newer vars
%
/spcrsize 25 def
/tracksize 25 def
/vectoffset 10 def
/flpos true def % flag for showing Seq Xpos for all elements.
%
/Fbline true def % flag for showing baseline for each method.
/FgpLbl true def % flag for showing baseline for each group.
/down YSBlck def
/up   YSBlck def
/MaxNuclPage 1000 def
/Xscale XSPlot MaxNuclPage div def
/Yscale tracksize def
/MaxTick 100 def
/MinTick  10 def
%
@@@EndProlog@@@
}
#### End of MAINPSSETUP function

#
# Printing Main PostScript Routines...
#
MAINPSPROCS () { 
cat <<'@@@MAINProcs@@@'
%
%  Calculating some variables
% ----------------------------
/LnTot LnFwd LnBth LnRvs add add def
/is2tck LnBth 0 gt LnFwd 0 gt LnRvs 0 gt and LnFwd 0 eq LnRvs 0 eq and or and def % true if must plot two tickmark lines
/putuptck LnFwd 0 gt LnFwd LnRvs add 0 eq or def
/putdntck LnBth 0 gt LnFwd LnBth add 0 eq or def
/TmpYSB YSBlck TkMrkW is2tck { 2 mul } if sub def  % Adjusting plot area size with tickmarks.
/YSLine YSBlck LnTot div def
/YSFwd LnFwd LnTot div TmpYSB mul def
/YOriFwd YOriBlck def
/YSBth LnBth LnTot div TmpYSB mul def
/YOriBth YOriFwd YSFwd add putuptck { TkMrkW add } if def
/YSRvs LnRvs LnTot div TmpYSB mul def
/YOriRvs YOriBth YSBth add putdntck { TkMrkW add } if def
%
%%EndSetup
%
%%BeginProlog
%
%%BeginProcSet: functions 1.0 0
/min { 2 copy gt { exch } if pop } bdf 
/max { 2 copy lt { exch } if pop } bdf
/Xscm { Xscale mul } bdf /Xscme { Xscm exch } bdf
/Yscm { Yscale mul } bdf /Yscme { Yscm exch } bdf
/ChkLimits { 3 copy pop 5 2 roll dup dup 5 1 roll 3 1 roll lt 3 1 roll gt or { pop false } { true } ifelse } def 
/nucdif { 2 copy exch sub } bdf
%%EndProcSet:   functions 1.0 0
%
%%BeginProcSet: text_functions 1.0 0
/sfont { findfont exch scalefont setfont } bdf
/stringheight  { gsave newpath 0 0 moveto (0) false charpath flattenpath pathbbox exch pop exch sub exch pop 0.95 mul grestore } bdf
/ct { gsave 0 translate sfont scmyk dup stringwidth pop 2 div neg stringheight 2 div moveto show grestore } bdf
/ctr { gsave 0 translate sfont scmyk dup stringwidth pop 2 div neg stringheight 1.65 mul neg moveto show grestore } bdf
%%EndProcSet:   text_functions 1.0 0
%
%%BeginProcSet: painting_functions 1.0 0
/scmyk { setcmykcolor } bdf
/scolor { colordict exch get exec scmyk } bdf 
colordict begin % adding definitions and functions
 /lup { /ku xdf /yu xdf /mu xdf /cu xdf } bdf
 /lmd { /km xdf /ym xdf /mm xdf /cm xdf } bdf
 /ldn { /kd xdf /yd xdf /md xdf /cd xdf } bdf
 /load2col { lup ldn /dk ku kd sub def /dy yu yd sub def /dm mu md sub def /dc cu cd sub def } bdf
 /load3col { lup lmd ldn /uk ku km sub def /uy yu ym sub def /um mu mm sub def /uc cu cm sub def /dk km kd sub def /dy ym yd sub def /dm mm md sub def /dc cm cd sub def } bdf
 /col2 { 2 dict begin /p xdf /pcd { p mul add } bdf cd dc pcd md dm pcd yd dy pcd kd dk pcd scmyk end } bdf
 /col3 { 3 dict begin /p xdf /pcd { p 2 mul mul add } bdf /pcu { p 0.5 sub 2 mul mul add } bdf p 0.5 le { cd dc pcd md dm pcd yd dy pcd kd dk pcd } { cm uc pcu mm um pcu ym uy pcu km uk pcu } ifelse scmyk end } bdf
 /rainbow { 1 dict begin /p xdf p 0.1 le { p 0.2 div 0.5 add 1 0 0 scmyk } { p 0.4 le { 1 1 p 0.1 sub 0.3 div sub 0 0 scmyk } { p 0.6 le { 1 0 p 0.4 sub 0.2 div 0 scmyk } { p 0.8 le { 1 p 0.6 sub 0.2 div sub 0 1 0  scmyk } { 0 p 0.8 sub 0.2 div 1 0 scmyk } ifelse } ifelse } ifelse } ifelse end } bdf
end % colordict
%%EndProcSet:   painting_functions 1.0 0
%
%%BeginProcSet: drawing_functions 1.0 0
/dotted { [ 1 ] 0 setdash } def
/bbox { 4 copy 3 1 roll exch 6 2 roll 8 -2 roll moveto lineto lineto lineto closepath } bdf
/tbbox { tflg { gsave setlinewidth scmyk stroke grestore } { pop pop } ifelse } def
%%EndProcSet:   drawing_functions 1.0 0
%
%%BeginProcSet: tickmarks 1.4 0
% Rule.ps ---> rules and scales
/tmdct 22 dict def tmdct begin
 /ShowGrid 0 def % 0 - none : 1 - MinTicks : 2 - MaxTicks : 3 - Both
 /Gridup true def /Griddn true def /flgup true def
 /TkMrkHW TkMrkW  2 div def
 /TkMrkDW TkMrkW 10 div def
 /TkFont { TkMrkHW /Helvetica } def
 /MaxWidthT { gsave MaxNuclPage 10 string cvs TkFont sfont stringwidth pop 2 mul grestore } bdf
 /CheckCloser { 3 copy pop MaxWidthT sub 3 1 roll MaxWidthT add 3 1 roll dup dup 5 1 roll 3 1 roll lt 3 1 roll gt or 4 1 roll 3 copy dup 3 1 roll ne 3 1 roll ne and 5 -1 roll and { pop false } { true } ifelse } bdf
 /ctextick { gsave TkFont sfont dup stringheight 2 div exch stringwidth pop 2 Xscm div neg Xscm exch 2 copy neg translate 2 mul exch 2 mul neg exch gsave 0 0 bbox BGcolor scmyk gsave tflg { FGcolor scmyk } if 2 setlinewidth stroke grestore fill grestore 0 0 moveto FGcolor scmyk show grestore } bdf
 /bltextick { gsave TkFont sfont dup stringwidth pop 2 Xscm div neg Xscm TkMrkHW 2 copy flgup { TkMrkDW add translate } { 2 mul translate 1 -1 scale } ifelse exch 2 mul neg exch gsave 0 0 bbox BGcolor scmyk gsave tflg { FGcolor scmyk } if 2 setlinewidth stroke grestore fill grestore 0 0 moveto FGcolor scmyk show grestore } bdf
 /tonormtick { 0 eq { dup dup 0 ne { MinTick mod } if sub exch dup dup 0 ne { MinTick mod } if sub exch } { dup dup 0 ne { MaxTick mod } if sub exch dup dup 0 ne { MaxTick mod } if sub exch } ifelse } bdf
 /Mkg { 0 0 moveto lineto FGcolor scmyk dotted stroke } bdf
 /MkVGrid { gsave setlinewidth Gridup flgup not { not } if { 0 up Mkg } if Griddn flgup not { not } if { 0 down neg Mkg } if  grestore } bdf
 /MkAtick { setlinewidth 0 TkMrkHW neg moveto 0 TkMrkHW lineto FGcolor scmyk stroke } bdf
 /MkBtick { gsave dup Xscm 0 translate ShowGrid 2 eq ShowGrid 3 eq or { 0.25 MkVGrid } if 1 MkAtick CheckCloser { 10 string cvs ctextick } if grestore } bdf
 /MkCtick { setlinewidth 0 0 moveto 0 TkMrkHW 3 -1 roll { TkMrkDW sub } if lineto FGcolor scmyk stroke } bdf
 /MkDtick { gsave dup Xscm 0 translate CheckCloser { 10 string cvs bltextick } if ShowGrid 2 eq ShowGrid 3 eq or { 0.25 MkVGrid } if false 1 MkCtick grestore } bdf
 /baseline { gsave Xscm TkMrkDW moveto Xscm TkMrkDW lineto TkMrkDW 2 mul setlinewidth FGcolor scmyk stroke grestore } bdf
 /r { /Gridup true def /Griddn true def /flgup true def gsave TkMrkHW add translate 1 -1 scale 5 { 2 copy } repeat pop neg Xscm 0 translate 0 tonormtick MinTick exch { ChkLimits { gsave Xscm 0 translate 0.25 MkAtick ShowGrid 1 eq ShowGrid 3 eq or { 0 MkVGrid } if grestore } if } for 1 tonormtick MaxTick exch { ChkLimits { MkBtick } if } for 2 { dup dup 0 ne { MaxTick mod } if 0 ne { MkBtick } { pop } ifelse } repeat grestore } bdf
 /x { 6 { 2 copy } repeat pop neg Xscm 0 translate baseline 0 tonormtick MinTick exch { ChkLimits { gsave Xscm 0 translate true 0.25 MkCtick ShowGrid 1 eq ShowGrid 3 eq or { 0 MkVGrid } if grestore } if } for 1 tonormtick MaxTick exch { ChkLimits { MkDtick } if } for 2 { dup dup 0 ne { MaxTick mod } if 0 ne { MkDtick } { pop } ifelse } repeat } bdf 
 /s { /Gridup false def /Griddn true def /flgup true def gsave translate 1 -1 scale x grestore } bdf
 /z { /Gridup true def /Griddn false def /flgup false def gsave TkMrkW add translate 1 1 scale x grestore } bdf
end % tmdct
%%EndProcSet:   tickmarks 1.4 0
%
%%BeginProcSet: objects 1.0 0
/shpdct 40 dict def shpdct begin
 /LY { tracksize 1.5 mul } bdf
 /ShFont { TkMrkW 2 div /Helvetica } def
 /RWTS { LY 1.5 mul } bdf
 /mtrx matrix def
 /cpt { moveto { lineto } repeat closepath } bdf
 /hline { 0 0 moveto 1 0 lineto closepath } bdf
 /fline { hline tracksize sc mul setlinewidth } bdf
 /harw {  0.0  0.0  0.0  -1.0  0.745 -1.0  0.745 -1.1  0.75 -1.1  5  1.0  0.0  cpt } bdf
 /farw {  0.75   0.6  0.745  0.6  0.745  0.5  0.0   0.5  0.0  -0.5
          0.745 -0.5  0.745 -0.6  0.75 -0.6                        8  1.0  0.0  cpt } bdf
 /hend {  0.0  0.0  -1.0   0.0 -1.0   1.0                        3  0.75 0.0  cpt } bdf
 /fend {  0.5  1.0   0.5   0.0 -0.5   0.0 -0.5   1.0             4  0.75 0.0  cpt } bdf
 /hbox {  1.0  0.0   1.0  -1.0  0.0  -1.0                        3  0.0  0.0  cpt } bdf
 /fbox {  0.0  0.5   1.0   0.5  1.0  -0.5                        3  0.0 -0.5  cpt } bdf
 /hcir {  0.5 -0.5   0.5   0   360 arc closepath } bdf
 /fcir {  0.5  0.0   0.5   0   360 arc closepath } bdf
%%% /getcol { colordict begin /ct xdf /s end } bdf
% must define frame colors /frm0 /frm1 /frm2...
 /getfrcol { dup 0 eq { pop frm0 } { dup 1 eq { pop frm1 } { 2 eq { frm2 } if } ifelse } ifelse } bdf
 /cmdln { 0 moveto sqdif 2 div 0 lineto scmyk stroke } bdf
 /lnfill { gsave RWTS setlinewidth sqdif 2 div cmdln 0 cmdln grestore } bdf
 /frmfill { frm getfrcol rmd getfrcol lnfill } bdf
 /rnbfill { 1 dict begin gsave /incr sqdif 100 div def 0 incr sqdif { dup dup incr add 0 exch 0 moveto lineto dup 0 gt { sqdif div } if rainbow RWTS setlinewidth stroke } for grestore end } bdf 
% /getvar { /ftlbl xdf /sc xdf /rmd xdf /frm xdf strnd (-) eq { exch } if 2 copy exch sub /sqdif exch Xscm def /sqdsc sqdif Xscale div def /seqend exch Xscm def /seqori exch Xscm def /cmod xdf } bdf
 /getvar { /ftlbl xdf /cmod xdf /sc xdf /rmd xdf /frm xdf nucdif /sqdif exch Xscm def /sqend exch def /sqori exch def /seqend sqend Xscm def /seqori sqori Xscm def } bdf
 /setcolmod { colordict begin cmod cvx exec dup 1 eq { pop scmyk fill } { dup 2 eq { pop lnfill } { dup 3 eq { pop frmfill } { dup 4 eq { pop rnbfill } { 0 eq { BGcolor scmyk fill } if } ifelse } ifelse } ifelse } ifelse end } bdf
 /shwpos { flpos { sqend sqori strnd (-) eq { exch } if sqdif exch 0 2 { gsave tracksize 0.75 mul moveto 10 string cvs gsave strnd (-) eq { -1 -1 scale -45 } { 45 } ifelse rotate ShFont sfont FGcolor scmyk show grestore grestore } repeat } if } bdf
 /frshared { strnd (-) eq { -1 -1 scale } if 0.5 setlinewidth gsave /svmtrix mtrx currentmatrix def LY sc mul sqdif flglscape { exch } if scale cvx exec svmtrix setmatrix gsave FGcolor scmyk stroke grestore clip setcolmod grestore shwpos pop } bdf
 /f { gsave getvar strnd (-) eq { seqend } { seqori } ifelse 0 translate frshared grestore } bdf
 /gpuline { gsave 0 0 moveto grdif 0 rlineto /red scolor 1 setlinewidth stroke grestore } bdf
 /shgplbl { FgpLbl { gsave grori tracksize 0.75 mul strnd (-) ne { neg } if translate gpuline grlbl FGcolor 8 /Helvetica grdif 2 div strnd (-) eq { ct } { ctr } ifelse grestore } if } bdf 
 /g_end { exit end } bdf 
end % shpdct
%%EndProcSet:   objects 1.0 0
%
%%BeginProcSet: vectors 1.6 0
% Objects.ps ---> vectors
/vctdct 6 dict def vctdct begin
 /resizetrack tracksize 0.95 mul def
 /vtoffset vectoffset 2 div Xscm def
 /clrselc { colordict begin dup 2 eq { pop load2col /clrproc { {col2} } def } { dup 3 eq { pop load3col /clrproc { {col3} } def } { dup 0 eq { pop white black load2col /clrproc { {col2} } def } { dup 4 eq { pop /clrproc { {rainbow} } def } { 1 eq { white 8 4 roll load2col /clrproc { {col2} } def } if } ifelse } ifelse } ifelse } ifelse } bdf % no end for closing dict because grdct must be closed by calling function
 /v { gsave Xscm dup vtoffset sub exch vtoffset add 0 moveto 0 lineto resizetrack setlinewidth clrproc exec stroke grestore } bdf
 /ovend { end exit } bdf   % end is for grdct dict
end % vctdct
%%EndProcSet:   vectors 1.5 0
%
%%BeginProcSet: main_function_calls 1.0 0
%
/tm { tmdct begin /ShowGrid xdf exec end } bdf
%
% /objects
/bline { Fbline { gsave FGcolor scmyk 0 0 moveto XSPlot 0 lineto stroke grestore } if } bdf
/shsrclbl { FLftLbl { gsave srclbl FGcolor 10 /Courier XLftLbl 2 div neg ct grestore } if } bdf 
/source { gsave 3 dict begin /nxtspacer exch spcrsize mul def /Yscl exch tracksize mul def /srclbl xdf /Y Y Yscl add def XOriPlot Y translate 1 -1 scale bline shsrclbl } bdf
/endsource { end grestore /Y Y nxtspacer add def } bdf
%
% /gp { gsave shpdct begin /strnd xdf strnd (-) eq { exch } if 2 copy exch sub /grdif exch Xscm def /grend exch Xscm def /grori exch Xscm def /grlbl xdf shgplbl { currentfile token { exec } { exit } ifelse } loop grestore } bdf
 /gp { gsave shpdct begin /strnd xdf nucdif /grdif exch Xscm def /grend exch Xscm def /grori exch Xscm def /grlbl xdf shgplbl { currentfile token { exec } { exit } ifelse } loop grestore } bdf
%
/ov { gsave vctdct begin exch Xscm exch translate { currentfile token { exec } { exit } ifelse } loop end grestore } bdf
%
%%EndProcSet:   main_function_calls 1.0 0
%%EndProlog
@@@MAINProcs@@@
} 
#### End of MAINPSPROCS function

#
# PostScript end of file... 
# 
MAINPSTRAILER () {
cat <<'@@@EndTrailer@@@'
%%Trailer
%
%%EOF
@@@EndTrailer@@@
} 
#### End of MAINPSTRAILER function

##############################################################
####################### PROGRAM FUNCTIONS ####################
#
# Testing parameters passed by User: Colors.
#
CheckColor () {
  gawk 'BEGIN{
    color=ARGV[1]
    if (color!~/^BG$|^FG$|^black$|^white$|^(very)?(light|dark)?(grey|green|(sky)?blue|cyan|violet|red|orange|yellow|brown)$/) {
      printf "\n<<<<ERROR>>>> \" %s \" is not a defined color.\n", color | "cat 1>&2"
      printf "              Default \" black \" is asigned to option.\n" | "cat 1>&2"
      printf "              You can choose one of this colors:\n" | "cat 1>&2"
      print ARGV[3] | "cat 1>&2"
      print "" | "cat 1>&2"
      color=ARGV[2]
      }
    print color
    ARGV[1]=ARGV[2]=ARGV[3]=""
    }' $1 $2 "$COLORS"
  return 0
}

#
# Testing parameters passed by User: Integer Numbers.
#
CheckInt () {
  if [ `expr $1 : '[0-9]*'` -eq `expr $1 : '.*'` ]
    then echo "1"; return 0
    else 
      echo "<<<<ERROR>>>> \" $1 \" is not an integer value." 1>&2
      echo "              You must especify an integer value to -$W_OPTION" 1>&2
      echo "              Program will take value from defaults..." 1>&2
      echo "" 1>&2
      echo "0";return 1
    fi
  return 1
}

#
# Testing if exist Custom File.
#
ExistCustomfile () {
  if [ ! -f "$1" ]
    then echo "0"
      echo "Report: Default Custom File does not exist." 1>&2
      echo "        Program is going to write a Local Custom File." 1>&2 
    else echo "1" # exist_default_customfile
      echo "Warning: Default Custom File exist." 1>&2
      echo "         Program is going to overwrite your Local Custom File." 1>&2
    fi
  echo "          Custom_Filename: $1" 1>&2
  return 0
}
###################################################################
################## MAIN GFF2PS SHELL SCRIPT #######################
#
###################################################################
################## Choosing Options for GFF2PS ####################
#
# Resetting default program variables.
#
Defaults

#
# Checking if default custom file exists
#  else switch on flag to create.
#
echo "" 1>&2
echo "Report: You have typed the following command line:" 1>&2
echo "" 1>&2
echo $CMDLine 1>&2
echo "" 1>&2

#
# When no options, no parameters and 
#  no inputstream are given, print USAGE.
#
if [ $# -eq 0 ] 
  then
    echo; echo $USAGE; echo; exit 1
  fi

#
# Asking for Help, output it to screen. 
#
case $1 in
  -h) Help; exit 2;;
  -H) echo; echo $PROGRAM" : Option Definition Help."; echo;
      if [ $# -gt 1 ]; 
        then shift; fi;
      for temp in $@;
        do ShowHelpLine $temp; done;
      exit 2;;
  esac

#
# Processing all options and parameters passed to program.
#
while getopts :dD:C:vpP:B:N:bHh W_OPTION
  do
    case $W_OPTION in
      H|h) Help; exit 2;;
      d) v04_1="1";                     # create_default_customfile (.gff2psrc) & rename_it if exist
         v04=`ExistCustomfile "$v03"`;;
      D) v04_1="1";                     # create_default_customfile & rename_it if exist
         v03="$CFDIR/$OPTARG";
         v04=`ExistCustomfile "$v03"`;;
      C) if [ ! -f $CFDIR/$OPTARG ];    # load_customfile customfile_name
           then v01="0";
             echo "Error: Custom File $OPTARG does not exist...Not Loaded." 1>&2 ;
           else v01="1";
	         echo "Report: Adding $OPTARG Custom File to Default Custom File." 1>&2 ;
             v02="$CFDIR/$OPTARG";
           fi;;
      v) v05="1";;                      # print_report
      p) v06="Portrait";;               # page_orientation
      P) v08=$OPTARG;;                  # page_number
      B) v09=$OPTARG;;                  # blocks_x_page
      N) v10=$OPTARG;;                  # nucleotides_x_line
      b) v11="0";;                      # show_blocks_top-bottom
       :) ShowHelpLine $1; exit 2;;
      \?) ShowHelpLine $1; exit 2;;
    esac # case $W_OPTION
  done   # while getopts

#
# Shifting all options tested before,
# without removing files passed to shell...
#
 incr=1
 while [ $OPTIND -gt $incr ]
   do shift; incr=`expr $incr + 1`; done

#
# Defining PLOToptions STRING for GNU awk programs.
#
   P="BACKGROUND_COLOR:="$bgcolor"::FOREGROUND_COLOR:="$fgcolor"::"$n04_1":="$v04_1"::"
 P=$P$n01":="$v01"::"$n02":="$v02"::"$n03":="$v03"::"$n04":="$v04"::"$n05":="$v05"::"
 P=$P$n06":="$v06"::"$n07":="$v07"::"$n08":="$v08"::"$n09":="$v09"::"$n10":="$v10"::"
 P=$P$n11":="$v11"::"
 P=$P$m01":="$c01"::"$m02":="$c02"::"$m03":="$c03"::"$m04":="$c04"::"$m05":="$c05"::"
 P=$P$m06":="$c06"::"$m07":="$c07"::"$m08":="$c08"::"$m09":="$c09"::"$m10":="$c10"::"
 P=$P$m11":="$c11"::"$m12":="$c12
 PLOToptions=$P
 if [ $v05 -eq 1 ]
   then
     echo "" 1>&2
     echo "********************************************" 1>&2
     echo ">>>>> Option String Passed to Program <<<<<<" 1>&2
     echo "********************************************" 1>&2
     echo "" 1>&2
     echo $PLOToptions 1>&2
     echo "" 1>&2
   fi

###################################################################
############### CONVERTING GFF TO POSTSCRIPT ######################
#
# Printing PostScript Header...
#
gawk 'BEGIN{ 
 # Find actual date...
 "date" | getline d
 split(d,dt," ")
 date = dt[3] "." dt[2] "." dt[6] " " substr(dt[4],1,5)
 # Finding logged user...
 "whoami" | getline usr
 # Printing PostScript Header...
 bigchain=        "%%\!PS-Adobe-2.0\n"
 bigchain=bigchain"%%%%Title: %s\n"
 bigchain=bigchain"%%\n%%%%User: %s\n"
 bigchain=bigchain"%%%%Date: %s\n"
 bigchain=bigchain"%%\n%%%%Program: %s\n"
 bigchain=bigchain"%%%%Version: %s\n"
 bigchain=bigchain"%%%%CreationDate: %s\n"
 bigchain=bigchain"%%%%LastRevision: %s\n"
 bigchain=bigchain"%%%%Author : %s\n"
 bigchain=bigchain"%%%%e-mail : %s\n"
 bigchain=bigchain"%%%%Mail Adress:\n%s\n%%\n"
 if (ARGV[1]!~"##dflt##") title=ARGV[1]
 else title="GFF to PostScript"
 printf bigchain, title, usr, date, ARGV[2], ARGV[3], ARGV[4], ARGV[5], ARGV[6], ARGV[7], ARGV[8]
 printf "%%\n%% ------------------------------------------------------------------------\n"
 printf "%%                           %s - %s\n",ARGV[2], ARGV[3]
 printf "%% ------------------------------------------------------------------------\n"
  for (i=1;i<=8;i++) ARGV[i]=""
}' "##dflt##" "$PSPROGRAM" "$PSVERSION" "$PSCREATION" "$PSREVISION" "$AUTHOR" "$EMAIL" "$MAIL"

#
# Printing PostScript Setup Constants...
#
  MAINPSCPR
  echo "%%Orientation: "$v06 # "page_orientation"
  echo "%%BoundingBox:  0  0  842   595"
  MAINPSSETUP

#
# Main GFF2PS GNU awk Program...
#
# (cat <<'@@@EndPROGRAM@@@') |
# @@@EndPROGRAM@@@
# gawk -v CUSTOMFILE=$v03 -f - "$@"
#
(echo $PLOToptions"::DCF:=$CFDIR/.gff2psrc"; MAINPSPROCS) |
gawk 'BEGIN{
  ############ INITIALITATION ############

  # defaults
  MINSCORE=0.10;
  MAXSCORE=1.00;
  BigLINE="########################################";
  FIRST_POS=0;
  LAST_POS=0;

  # gff data structure
  seqname  = 1;
  source   = 2;
  feature  = 3;
  start    = 4;
  end      = 5;
  score    = 6;
  strand   = 7;
  frame    = 8;
  group    = 9;

  # gff strand codification
  strands["+"]=strands["-"]=strands["."]=1;

  # Find actual date...
  "date" | getline d
  split(d,dt," ")
  date = dt[3] "." dt[2] "." dt[6] " " substr(dt[4],1,5)
  # Finding logged user...
  "whoami" | getline usr
  # Finding current process...
  "echo $$" | getline IDP

  # Loading PSMainProgram. Line 0 is the Command Line Parameter String.
  psline=0
  while ((getline < ARGV[1])>0) PSMAIN[psline++]=$0;
  ARGV[1]=""

 ############## Defining pre-variables by CommandLine ############ 
 PARAM=PSMAIN[0]
 npar=split(PARAM,parm,"::") 
 for (r=1;r<=npar;r++) {
   split(parm[r],elem,":=")
   if (elem[2]!="##dflt##") {
     if (elem[1]~/COLOR\$/) {
       ecolor=elem[2]
       if (ChkColor(ecolor)) {
         if (ecolor~/^BG\$|(##DEFAULT##)/) { elem[2]=Var["BACKGROUND_COLOR"] }
         else if (ecolor~/^FG\$/) { elem[2]=Var["FOREGROUND_COLOR"] }
         }
       else { elem[2]=Var["BACKGROUND_COLOR"] }
       }
     Var[elem[1]]=elem[2]
     }
   }
  for (v in Var) printf "VAR: %-25s :: Value: %s\n", v, Var[v] | "cat 1>&2" 

# Layout Properties
  Default["load_customfile"]=0            # Var["load_customfile"]
  Default["customfile_name"]=""           # Var["customfile_name"]
  Default["default_customfile_name"]=Var["DCF"]  # DCF="$CFDIR/.gff2psrc"
#  Default["exist_default_customfile"]="0"  # only as a Var
#  Default["create_default_customfile"]="0" # only as a Var
#  Default["print_report"]="0"              # only as a Var
  Default["page_size"]="a4"               # Var["page_size"]
  Default["page_orientation"]="Landscape" # Var["page_orientation"] : Landscape (default), Portrait.
  Default["margin_left"]="1cm"
  Default["margin_right"]="1cm"
  Default["margin_upper"]="1cm"
  Default["margin_bottom"]="1cm"
  Default["foreground_color"]="FGcolor"
  Default["background_color"]="BGcolor"
  Default["nucleotides_x_line"]=0 # Var["nucleotides_x_line"] : Default=0,gets the seqlenght from data
  Default["blocks_x_page"]=1      # Var["blocks_x_page"] : Default=1
  # Default["max_blocks_x_page"]=5  # You can change on .gff2psrc file.
  Default["show_blocks_top-bottom"]=1 # Var["show_blocks_top-bottom"] : 1->TopBottom, 2->LeftRight.
  Default["page_number"]=1        # Var["page_number"] : Default=1
  Default["strand_show_forward"]="on"
  Default["strand_show_reverse"]="on"
  Default["strand_show_independent"]="on"
# General Properties
  Default["text_color"]=Default["foreground_color"]
  Default["label"]="none"
# Features Properties
  FT_PROP["fill_shape_mode"]="default" # none(BGcolor), default(FGcolor 1color), 1_color, 2_color, frame-remainder, rainbow
  FT_PROP["fill_vector_mode"]="default" # none(0 BGcolor grad), default(0 black grad), rainbow(1), 1_color(BGcolor color 2), 2_color(color1 color2 2), 3_color(col1 col2 col3 2)
  FT_PROP["label"]="default" # none , default , "user-def"
  FT_PROP["color"]=Default["foreground_color"] # 1color(color),2color(color..color),3color(color..color..color)
  FT_PROP["shape"]="box" #box, arrow, end_arrow, circle, vector, spike, block
  FT_PROP["vert_align"]="baseline" #center,baseline
  FT_PROP["layer"]=0
  FT_PROP["show"]="on"
# Group Properties
  GR_PROP["label"]="default"        # none , default , "user-def"
  GR_PROP["rank"]="0:1"             # rank of lower-upper scores
  #  GR_PROP["vert_align"]="center" # center or baseline
  GR_PROP["join_align"]="center"
  GR_PROP["join_color"]=Default["foreground_color"]
  GR_PROP["join_linetype"]="solid"
  GR_PROP["join_show"]="off"
# Lines (Method-Source) Properties
  SO_PROP["label"]="default"     # none , default , "user-def"
  SO_PROP["vert_align"]="center" # center or baseline
  SO_PROP["baseline_align"]="center"
  SO_PROP["baseline_color"]=Default["foreground_color"]
  SO_PROP["baseline_linetype"]="dotted"
  SO_PROP["baseline_show"]="off"
  SO_PROP["bbox_color"]=Default["foreground_color"]
  SO_PROP["bbox_show"]="off"
  SO_PROP["scale"]=2
  SO_PROP["spacing_scale"]=0.5
  SO_PROP["rule_scale"]="nucleotide"
  SO_PROP["rule_rel"]="none"
  SO_PROP["rule_abs"]="none"
# Default[""]=

 # Data for upper-case to lower-case function #lcase()#
 CM["A"]="a";CM["B"]="b";CM["C"]="c";CM["D"]="d";CM["E"]="e";
 CM["F"]="f";CM["G"]="g";CM["H"]="h";CM["I"]="i";CM["J"]="j";
 CM["K"]="k";CM["L"]="l";CM["M"]="m";CM["N"]="n";CM["O"]="o";
 CM["P"]="p";CM["Q"]="q";CM["R"]="r";CM["S"]="s";CM["T"]="t";
 CM["U"]="u";CM["V"]="v";CM["W"]="w";CM["X"]="x";CM["Y"]="y";
 CM["Z"]="z";CM["Ñ"]="ñ";CM["Ç"]="ç"

 if (Var["print_report"]) 
   printf "\n%s\nInput File...\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
 }
{ ############ READING .GFF FILES  ############

  # skips those comment lines (starting with "#") or empty lines
  #
  is_EOF=0
  while ($0~/^(\#)+/ || NF==0 ) { 
    if (Var["print_report"]) 
      printf "%10s :: Not Read :: %s\n", NR, $0 | "cat 1>&2"
    if (getline<=0) { is_EOF=1; break }
    }

 if (!is_EOF) {

  # Printing Input Lines
  #
  if (Var["print_report"]) 
   printf "%10s : %s\n", NR, $0 | "cat 1>&2"

  # read gff element within source and strand
  #
  sources[$source]++;                       # field 2 (source) counter
  if ($group=="") $group=".";               # empty group defined as default (none==".")
  GP_ary[$group]++;                         # field 9 (group) counter
#   The same as ng[sc,s] 
#   GP_SO[$source,$strand,$group]++;          # groups per source and strand
  FT_ary[$feature]++;                       # field 3 (gff-feature) counter
#   FT_GP[$source,$strand,$group,$feature]++; # features per group, source and strand
  n[$source,$strand]++;                     # elements per source and strand
  $feature=lcase($feature);
  element[$source,$strand,n[$source,$strand],feature] = $feature; 
  element[$source,$strand,n[$source,$strand],start]   = $start;
  element[$source,$strand,n[$source,$strand],end]     = $end;
  element[$source,$strand,n[$source,$strand],frame]   = $frame;  
  element[$source,$strand,n[$source,$strand],score]   = $score;  
  element[$source,$strand,n[$source,$strand],group]   = $group; 
  if ($NF>group) {
    for (i=(group+1);i<=$NF;i++) {
      if ($i~"Label")
        element[$source,$strand,n[$source,$strand],$i]= $(i+1);  
    }
  }

  if (FIRST_POS>$start) FIRST_POS=$start;
  if (LAST_POS<$end) LAST_POS=$end;

  # recompute scores between MINSCORE and MAXSCORE
  #
  if ($score < MINSCORE)
    element[$source,$strand,n[$source,$strand],score]  = MINSCORE;
  else if ($score > MAXSCORE)
    element[$source,$strand,n[$source,$strand],score]  = MAXSCORE;

  # place gff element in sort array by acceptor position
  #
  ns=n[$source,$strand]-1;
  while ($start < element[$source,$strand,S[$source,$strand,ns],start]) {
    S[$source,$strand,ns+1]=S[$source,$strand,ns];
    ns--;
  }
  S[$source,$strand,ns+1]=n[$source,$strand]

 } # if (!is_EOF)

}
END{

  # Printing elements sorted
  #
  if (Var["print_report"]) {
   printf "\n%s\ngff elements are sorted...\n%s\n",BigLINE,BigLINE | "cat 1>&2"
   for (sc in sources) 
    for (s in strands) {
      printf "\nSOURCE: %s\nSTRAND: %s\n",sc,s | "cat 1>&2"
      if (n[sc,s]>0)
        for (i=1;i<=n[sc,s];i++) {
          printf "%10s %s\n", S[sc,s,i],showelemS(sc,s,S[sc,s,i]) | "cat 1>&2"
        
        }
      else
        printf "%10s This block is empty ##\n", "##" | "cat 1>&2"
      }
   close("cat 1>&2")
   }

  ########## Defining Object Properties ##########
  #
  # Variable definition hierarchy:
  # Program Defaults < Default Custom File < Custom File < Command Line.
  #
  CreateProps(0)
  ECF=0
  if (Var["exist_default_customfile"]) {
    if (Var["print_report"]) printf "\n%s\nReading Default Custom File...\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    RCFile(Var["default_customfile_name"])
    if (Var["print_report"]) printf "\n%s\nReading Custom File...........\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    if (Default["load_customfile"]==Var["load_customfile"]) {
      Default["load_customfile"]=PLOT_LY["load_customfile"]
      Default["customfile_name"]=PLOT_LY["customfile_name"]
      }
    else {
      Default["load_customfile"]=Var["load_customfile"]
      Default["customfile_name"]=Var["customfile_name"]
      }
    if (Default["load_customfile"]) RCFile(Default["customfile_name"])
    ECF=1
    }
  else
    if (Default["load_customfile"]) RCFile(Default["customfile_name"])
  if (Var["print_report"]) printf "\n%s\nChecking for Command-Line Modified options...........\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
  for (lytdef in Default) {
    dft=Default[lytdef]
    if (dft==Var[lytdef] && ECF==1) Default[lytdef]=PLOT_LY[lytdef]
      else Default[lytdef]=Var[lytdef]
    if (Var["print_report"]) printf "%s : Default Value=%s Custom File=%s Command-Line=%s : Using=%s\n", lytdef,dft,PLOT_LY[lytdef],Var[lytdef],Default[lytdef] | "sort | cat 1>&2"
    }
  close("sort | cat 1>&2")

  # Calculating Page Number, Blocks and NucxLine
  #
  PORI=Nuc_round(FIRST_POS,0) # floor
  PEND=Nuc_round(LAST_POS,1)  # ceiling
  # Zoom must be defined here
  if (PORI!=0) PDIF=PEND-PORI+1
  else PDIF=PEND-PORI

  P=Default["page_number"]
  B=Default["blocks_x_page"]

  if (Default["nucleotides_x_line"]==0) {
    if (B>1 || P>1) POFFSET=Nuc_round((PDIF/(B*P)),1)
    else POFFSET=PDIF
    }
  else POFFSET=Default["nucleotides_x_line"]
  if (POFFSET>PDIF) POFFSET=PDIF # necessary if it is defined a Zoom.

  B1= PDIF%POFFSET!=0 ? ((PDIF-(PDIF%POFFSET))/POFFSET)+1 : ((PDIF-(PDIF%POFFSET))/POFFSET)
  P = B1%B!=0 ? ((B1-(B1%B))/B)+1 : ((B1-(B1%B))/B)
  
  if (Default["show_blocks_top-bottom"]) BOFFSET=POFFSET
  else BOFFSET=POFFSET*P

  printf "\n%s\nPostScript Page Definitions...\n%s\n",BigLINE,BigLINE | "cat 1>&2"  
  printf "\npage_number %s\nblocks_x_page %s\nnucleotides_x_line %s\nmax_blocks_x_page %s\nshow_blocks_top-bottom %s\n",Default["page_number"],Default["blocks_x_page"],Default["nucleotides_x_line"],Default["max_blocks_x_page"],Default["show_blocks_top-bottom"] | "cat 1>&2"  
  printf "\nPORI %s\nPEND %s\nP %s\nB %s\nPOFFSET %s\nBOFFSET %s\n\n",PORI,PEND,P,B,POFFSET,BOFFSET | "cat 1>&2"  

  # PostScript Variables Setup.
  #

  # PostScript Main Procs.
  #
  for (i=1;i<psline;i++) print PSMAIN[i]; 

  # Pages MAIN LOOP.
  #
  for (pages=1;pages<=P;pages++) {
    BORI=PORI
    startPSpage(pages,pages)  # PostSCript PageSetup.

    for (blocks=1;blocks<=B;blocks++) {
      printf "%%\n%% Block Num: %s Page: %s\n%%\n",blocks,pages

  # make groups. assumes elements sorted by increasing acceptor position
  #
  cntstr_fwd=cntstr_bth=cntstr_rvs=0
  printf "\n%s\nPostScript Code...\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
  for (sc in sources) {
    for (s in strands) {
      for (i=1;i<=n[sc,s];i++) {
        start_=element[sc,s,S[sc,s,i],start];
        end_=element[sc,s,S[sc,s,i],end];

       if (ChkLimits(start_,BORI,end_,(BORI+POFFSET))) {
        feature_=element[sc,s,S[sc,s,i],feature];
        score_=element[sc,s,S[sc,s,i],score];

	    tgr=element[sc,s,S[sc,s,i],group];
	    if (!grouping[sc,s,tgr,start]) {
	      grouping[sc,s,tgr,start]=element[sc,s,S[sc,s,i],start];
	      ng[sc,s]++;
	      group_[sc,s,ng[sc,s]]=tgr
          }

        if (grouping[sc,s,tgr,end]<element[sc,s,S[sc,s,i],end])
          grouping[sc,s,tgr,end]= element[sc,s,S[sc,s,i],end];

        # for gene mode. try to recompute relative frame and remainder
        frame_[sc,s,tgr]= element[sc,s,S[sc,s,i],frame];

        if (feature_=="First" || feature_=="Single") 
          frame_[sc,s,tgr]=0;
        else if (feature_=="Internal" || feature_=="Terminal" )
          frame_[sc,s,tgr]=remainder_[sc,s,tgr];

        remainder_[sc,s,tgr]=(3-(end_-(start_+frame_[sc,s,tgr])+1)%3)%3;

        printf "%s %s %s : %s \/%s %d %d %d %d %4.2f (%s) (%s) f\n", sc,s,i, PLOT_FT[feature_,":","layer"], Set_feat_Shape(feature_,sc), start_, end_, frame_[sc,s,tgr] ,remainder_[sc,s,tgr], score_, Set_feat_Clr(feature_), Plot_Lbl(feature_) | "cat 1>&2"
        grouping[sc,s,tgr,group,blocks,pages] = sprintf("%s%s \/%s %d %d %d %d %4.2f (%s) (%s) f\n", grouping[sc,s,tgr,group,blocks,pages], PLOT_FT[feature_,":","layer"], Set_feat_Shape(feature_,sc), start_, end_, frame_[sc,s,tgr] ,remainder_[sc,s,tgr], score_, Set_feat_Clr(feature_), Plot_Lbl(feature_))
        plot_group[tgr,blocks,pages]=1
       } # if ChkLimits
      }  # for i
        printf "\n" | "cat 1>&2"
    }    # for s
    # Percent of plot area for each strand
    if (ng[sc,"+"]>0) cntstr_fwd+=PLOT_FT[sc,":","scale"]
    if (ng[sc,"."]>0) cntstr_bth+=PLOT_FT[sc,":","scale"]
    if (ng[sc,"-"]>0) cntstr_rvs+=PLOT_FT[sc,":","scale"]
  }      # for sc
  cntstr_TOT=cntstr_fwd+cntstr_bth+cntstr_rvs
#  printf "/LnFwd %s def %% groups for each strand\n/LnBth %s def\n/LnRvs %s def\n", cntstr_fwd/cntstr_TOT, cntstr_bth/cntstr_TOT, cntstr_rvs/cntstr_TOT

  # PostScript Drawing strands, sources, groups, features
  #
  # make plotlines. Put non-overlapping groups into the same plotting line.
  #
  if (Var["print_report"]) printf "\n%s\nPrinting Lines......Page: %s Block: %s\n%s\n\n",BigLINE,pages,blocks,BigLINE | "cat 1>&2"
  for (s in strands) {
    for (sc in sources) {
      if (n[sc,s]>0) printf "(%s) %s %s source\n", sc, PLOT_FT[sc,":","scale"], PLOT_FT[sc,":","spacing_scale"]
      for (i=1;i<=ng[sc,s];i++) {
        g=group_[sc,s,i];
        for (j=1;j<=nl[sc,s] && grouping[sc,s,g,start] < endline[sc,s,j];j++);
        nl[sc,s] = j==nl[sc,s]+1 ? j : nl[sc,s];
        endline[sc,s,j]=grouping[sc,s,g,end];
	    # plot group in file
        if (Var["print_report"])
          printf "GROUP : %-10s : %s %10d %10d \n", g, s, grouping[sc,s,g,start], grouping[sc,s,g,end] | " sort +6 | cat 1>&2";
        if (PLOT_FT[g,":","label"]=="default") labl=g
        else labl=PLOT_FT[g,":","label"]
        if (plot_group[g,blocks,pages]==1) {
          printf "(%s) %s %s (%s) gp \n", checklbl(labl), grouping[sc,s,g,start], grouping[sc,s,g,end], s
          printf "%s", grouping[sc,s,g,group,blocks,pages] | "sort +0nr +6nr +2n +3nr"
          close("sort +0nr +6nr +2n +3nr")
          printf "g_end\n"
          } # if plot_group
        } # for ng[]
        if (n[sc,s]>0) printf "endsource\n"
      }   # for sources
    }     # for strands
  if (Var["print_report"]) close(" sort +6 | cat 1>&2")

  # Closing Pages MAIN LOOP.
  #
    BORI+=BOFFSET
    } # for blocks
  endPSpage(pages,pages)     # PostSCript Page Trailer.
  PORI+=POFFSET
  } # for pages

  # If not exist, create custom file (.gff2psrc)
  #
  printf "\n%s\nCustom File:\n%s\n\n%s\n\n", BigLINE,BigLINE, Default["default_customfile_name"] | "cat 1>&2"
  if (Var["create_default_customfile"]) { 
    if (Var["exist_default_customfile"]) {
      printf "Warning: I am going to rewrite your Default Custom File.\n" | "cat 1>&2"
      printf "         Moving last Default Custom File to %s.old\n",Default["default_customfile_name"] | "cat 1>&2"
      system("cp -v " Default["default_customfile_name"] " " Default["default_customfile_name"] ".old")
      }
    else {
      printf "Warning: Writing Default Custom File %s.\n",Default["default_customfile_name"] | "cat 1>&2"
      }
    CreateProps(2)
    }

  # Object Properties Report...
  #
  if (Var["print_report"]) {
    printf "\n%s\nDefining Object Properties..........\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    CreateProps(1)    }

}
function min(a,b) { if (a<=b) return a; else return b }
function max(a,b) { if (a>=b) return a; else return b }
function ChkLimits(o,O,e,E) { if (e<=O || o>=E) return 0; else return 1 }
  # start_,BORI,end_,BEND
function OnOff(value) { if (value~/^1$|^ON$|^Y(ES)?$|^T(RUE)?$/) return 1; else return 0 }
function ChkColor(ncolor) {
 if (ncolor~/^FG$|^black$|^white$|^(very)?(light|dark)?(grey|green|(sky)?blue|cyan|violet|red|orange|yellow|brown)$/)
   return 1
 else return 0 # also when ncolor == ^BG$|(##DEFAULT##)
 }
function Nuc_round(nm,flg, i) { # flg=0 then floor; flg=1 then ceiling.
 sign=nm<0?-1:1;
 if (sign==-1) { nm=-nm; flg=!(flg) }
 nmp=nm; for (i=1;nmp>10;i++) { nmp=nmp/10 };
 if (nm>=1000) mlt=2; else mlt=1;
 if (flg) {
   if (nm>0) {
	 if (nm%10^(i-mlt)==0) smm=0;
	   else smm=1;
	 t=nm>=100?sign*((int(nmp*10^(mlt-1))+smm)*10^(i-mlt)):sign*100;
	 }
   else t=0;
   }
 else {
   if (nm>0) t=nm>=100?sign*((int(nmp*10^(mlt-1)))*10^(i-mlt)):0;
     else t=0;
   }
 return t;
 }
function tick(nm) { # Still not adapted.
 end1=ESQ1-OSQ1; if (end1==0) end1=10000
 # end2=ESQ2-OSQ2; if (end2==0) end2=10000
 wy=max(end1,end2);
 y=wy/nm;
 ylog=(log(y)/log(10));
 yfloor=int(ylog);
 y1=y/(10^yfloor);
 y2=int(y1);
 t=y2*(10^yfloor);
 return t
 }
function lcase(string) {
  for (chr in CM) gsub(chr,CM[chr],string)
  return string
}
function checklbl(chain) {
 gsub(/[\(]/,"\\050",chain); gsub(/[\)]/,"\\051",chain)
 gsub(/[\<]/,"\\074",chain); gsub(/[\>]/,"\\076",chain)
 gsub(/[\/]/,"\\057",chain); gsub(/[\%]/,"\\045",chain)
 gsub(/[\[]/,"\\133",chain); gsub(/[\]]/,"\\135",chain)
 gsub(/[\{]/,"\\173",chain); gsub(/[\}]/,"\\175",chain)  
 return chain
}
function Plot_Lbl(gff_feat) {
  if (PLOT_FT[gff_feat,":","label"]=="none") lbl=" "
  else if (PLOT_FT[gff_feat,":","label"]=="default") lbl=gff_feat
  else lbl=PLOT_FT[gff_feat,":","label"]
  return checklbl(lbl)
}
function Set_feat_Clr(gff_feat) { # remaining to add vector definition colors.
  clrmode=0; color1=""; color2=""; # "none" or not defined
  k=split(PLOT_FT[gff_feat,":","color"],clm,"..")
  if (PLOT_FT[gff_feat,":","fill_shape_mode"]=="default") { clrmode=1; color1="FGcolor " }
  else if (PLOT_FT[gff_feat,":","fill_shape_mode"]=="1_color") { clrmode=1; color1=PLOT_FT[gff_feat,":","color"]" " }
  else if (PLOT_FT[gff_feat,":","fill_shape_mode"]=="2_color") { clrmode=2; color1=clm[1]" "; if (k>=2) color2=clm[2]" "; else color2="FGcolor " }
  else if (PLOT_FT[gff_feat,":","fill_shape_mode"]=="frame-remainder") { clrmode=3 }
  else if (PLOT_FT[gff_feat,":","fill_shape_mode"]=="rainbow") { clrmode=4 }
  tmp=color1""color2""clrmode
  return tmp
}
function Set_feat_Shape(gff_feat,src) {
 if (PLOT_FT[gff_feat,":","shape"]=="box") shp="box"
 else if (PLOT_FT[gff_feat,":","shape"]=="arrow") shp="arw"
 else if (PLOT_FT[gff_feat,":","shape"]=="end_arrow") shp="end"
 else if (PLOT_FT[gff_feat,":","shape"]=="circle") shp="cir"
 else shp="line"
  # else if (PLOT_FT[gff_feat,":","shape"]==" vector, spike, block ")
 if (PLOT_FT[src,":","vert_align"]=="center") pos="f"
 else if (PLOT_FT[src,":","vert_align"]=="baseline") pos="h"
 tmp=pos""shp
 return tmp
}
function CreateProps(flag) {
  ############ Create Properties Index for Objects ############ 
  STRING="#\n# L ############PAGE LAYOUT############\n#\n"
  if (flag==1) { 
    printf STRING | "cat 1>&2"
    for (dffeat in Default)
      printf "%s=%s\n", dffeat, Default[dffeat] | "sort 1>&2"
    }
  else if (flag==2) { 
    printf STRING > Default["default_customfile_name"]
    for (dffeat in Default)
      printf "%s=%s\n", dffeat, Default[dffeat] > Default["default_customfile_name"]
    }
  STRING="#\n# F ############GENOMIC FEATURES############\n#\n"
  if (flag==1) {
    close("sort 1>&2"); close("cat 1>&2")
    printf STRING | "cat 1>&2"
    }
  else if (flag==2) {
    close(Var["default_customfile_name"])
    printf STRING >> Default["default_customfile_name"]
    }
  for (feat in FT_ary) {
    for (prop in FT_PROP) {
      if (flag==0) PLOT_FT[feat,":",prop]=FT_PROP[prop]
      else if (flag==1)
	    printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] | "sort 1>&2"
      else if (flag==2)
	    printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] >> Default["default_customfile_name"]
      }
    if (flag==1)
      printf "# %s:%s=%s\n#\n", feat, "feature_number", FT_ary[feat] | "cat 1>&2"
    # else if (flag==2)
    #   printf "# %s:%s=%s\n#\n", feat, "feature_number", FT_ary[feat] >> Default["default_customfile_name"]
    }
  STRING="#\n# G ############GROUP FEATURES############\n#\n"
  if (flag==1) { 
    close("sort 1>&2"); close("cat 1>&2")
    printf STRING | "cat 1>&2"
    }
  else if (flag==2) {
    close(Var["default_customfile_name"])
    printf STRING >> Default["default_customfile_name"]
    }
  for (gpfeat in GP_ary) {
    for (prop in GR_PROP) {
      if (flag==0) PLOT_FT[gpfeat,":",prop]=GR_PROP[prop]
      else if (flag==1)
	    printf "%s:%s=%s\n", gpfeat, prop, PLOT_FT[gpfeat,":",prop] | "sort 1>&2"
      else if (flag==2)
	    printf "%s:%s=%s\n", gpfeat, prop, PLOT_FT[gpfeat,":",prop] >> Default["default_customfile_name"] 
      }
    if (flag==1)
      printf "# %s:%s=%s\n#\n", gpfeat, "feature_number", GP_ary[gpfeat] | "cat 1>&2"
    # else if (flag==2)
    #   printf "# %s:%s=%s\n#\n", gpfeat, "feature_number", GP_ary[gpfeat] >> Default["default_customfile_name"]
    }
  STRING="#\n# S ############SOURCE FEATURES############\n#\n"
  if (flag==1) { 
    close("sort 1>&2"); close("cat 1>&2")
    printf STRING | "cat 1>&2"
    }
  else if (flag==2) {
    close(Var["default_customfile_name"])
    printf STRING >> Default["default_customfile_name"]
    }
  for (sofeat in sources) {
    for (prop in SO_PROP) {
      if (flag==0) PLOT_FT[sofeat,":",prop]=SO_PROP[prop]
      else if (flag==1)
	    printf "%s:%s=%s\n", sofeat, prop, PLOT_FT[sofeat,":",prop] | "sort 1>&2"
      else if (flag==2)
	    printf "%s:%s=%s\n", sofeat, prop, PLOT_FT[sofeat,":",prop] >> Default["default_customfile_name"]
      }
    if (flag==1)
      printf "# %s:%s=%s\n#\n", sofeat, "group_number", sources[sofeat] | "cat 1>&2"
    # else if (flag==2)
    #  printf "# %s:%s=%s\n#\n", sofeat, "group_number", sources[sofeat] >> Default["default_customfile_name"]
    }
    if (flag==1) { close("sort 1>&2"); close("cat 1>&2") }
    else if (flag==2) close(Default["default_customfile_name"])
}
function RCFile(file) { ############ Read CustomFile
  STRING="Match between: %s & %s : %s=%s\n"
  while ((getline < file) > 0 ) {
   if ( $1!~/^(\#)+/ && NF>0 ) { 
    nothere=0
    split($0,defs,"=")
    split(defs[1],nwfeat,":")
    first=nwfeat[1]
    if (first=="*") first=".*" 
    gffirst=lcase(first)
    second=nwfeat[2]
    if (ft_type=="F") {
      for (feat in FT_ary) {
        if (match(feat,gffirst)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) {
            PLOT_FT[feat,":",second]=defs[2]
            nothere=1
            }
          if (Var["print_report"])
            printf "Feature "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      # print ">>>New Feature>>>" $0
      if (nothere==0) {
        FT_ary[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["print_report"])
          printf "No Match found - New Feature: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="G") {
      for (feat in GP_ary) { 
        if (match(feat,first)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) {
            PLOT_FT[feat,":",second]=defs[2]
            nothere=1
            }
          if (Var["print_report"])
            printf "Group "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      # print ">>>New Feature>>>" $0
      if (nothere==0) {
        GP_ary[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["print_report"])
          printf "No Match found - New Feature: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="S") {
      for (feat in sources) {
        if (match(feat,first)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) { 
            PLOT_FT[feat,":",second]=defs[2]
	        nothere=1
            }
          if (Var["print_report"])
            printf "Source "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      # print ">>>New Feature>>>" $0
      if (nothere==0) {
        sources[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["print_report"])
          printf "No Match found - New Feature: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="L") {
      if (defs[1] in Default) {
        PLOT_LY[defs[1]]=defs[2]
        if (Var["print_report"])
            printf "Layout "STRING,defs[1],first,defs[1],defs[2] | "cat 1>&2"
        }
      }
   }# if not empty or comment line 
   else if ( $1~/^(\#)$/ && $2~/^[LFGS]$/) { 
     ft_type=$2
     }
  } # while getline
  close(file)  
}
function showelemS(s,p,q){
  string=" : "
  string=string" "element[s,p,q,feature]" "
  string=string" "element[s,p,q,start]" "
  string=string" "element[s,p,q,end]" "
  string=string" "element[s,p,q,frame]" "
  string=string" "element[s,p,q,group]
  return string
 }
function showelem(a,b){
  string=" : "
  string=string" "element[a,b,n[a,b],feature]" "
  string=string" "element[a,b,n[a,b],start]" "
  string=string" "element[a,b,n[a,b],end]" "
  string=string" "element[a,b,n[a,b],frame]" "
  string=string" "element[a,b,n[a,b],group]
  return string
 }
function startPSpage(num,tot){
 printf "%%%%Page: %s %s\n",num,num
 printf "%%%%BeginPageSetup\n%%\n"
 printf "%% Saving current page settings\n"
 printf "/pgsave save def\n"
 printf "%% Defining pagenumber\n"
 printf "/PageNumber (Page %s/%s) def\n",num,tot
 printf "%% Setting BGcolor for sheet \n"
 printf "Dpage flglscape { exch } if 0 0 bbox FGcolor 1 tbbox BGcolor scmyk fill\n"
 printf "%% setting coordinate axes for page orientation\n"
 printf "flglscape\n"
 printf " { 90 rotate 1 -1 scale XORI YORI translate }                  %% (0,0) - Ori for landscape pages\n"
 printf " { XORI Dpage exch pop YORI sub translate 1 -1 scale } ifelse  %% (0,0) - Ori for portrait pages\n"
 printf "%% If testing output print bounding_boxes for page elements\n"
 printf "%%tflg { TB } if\n%%\n%% /FGcolor scolor\n%%\n"
 printf "%% Header\n%%\n"
 printf "%%%%EndPageSetup\n%%\n"
 printf "0 1000 XOriPlot Y {s} 3 tm\n"
 }
function endPSpage(num,tot){
 printf "%%\ngrestoreall\nshowpage\n%%\n%% PageEND: %s %s\n%%\n",num,tot
 }
' - "$@"
#### Main GFF2APLOT GNU awk Program DONE.

#
# PostScript end of page (Trailer)
# 
  MAINPSTRAILER

#
##################### EOF #####################
#
exit 0
