#!/bin/sh
######################################################################
#                               gff2ps                               #
######################################################################
#
#     Converting GFF files to PostScript.
#
#     Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
#                                 Roderic GUIGO SERRA       
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
######################################################################
#
# Creation Date: 01.03.1999
# Last Update:
#         $Id: gff2ps,v 1.30 1999-07-26 21:20:14 jabril Exp $	
#
# Autor : Josep Francesc ABRIL FERRANDO
# e-mail: jabril@imim.es
#
# ( ./gff2ps -vC mygffcustomfile -- samples/data.gff > samples/.ps ) > & samples/report.
#
#

##############################################################
#################### PROGRAM DEFINITIONS #####################
# 
CMDLine=$0" "$*
# 
# Defining Default Values...
Defaults () {
 # 
 # Constants: 
  PROGRAM="gff2ps"
  VERSION="v1.0"
  REVISION='$Revision: 1.30 $'
  DATERELEASE='$Date: 1999-07-26 21:20:14 $'
  PSPROGRAM="PostScript Output from gff2ps"
  AUTHOR="Josep Francesc ABRIL FERRANDO"
  EMAIL="jabril@imim.es"
  MAIL="%                  Dept. Informatica Medica
%          Institut Municipal d'Investigacio Medica
%                   C./ Doctor Aiguader 80
%                  08003 - BARCELONA (SPAIN)"
  USAGE=$PROGRAM" [-h][-H <option>] gff_file"
  COLORS="       black | verydarkgrey | darkgrey | grey | lightgrey | verylightgrey | white 
    verydarkseagreen | darkseagreen | seagreen | lightseagreen | verylightseagreen 
          verydarkgreen | darkgreen | green | lightgreen | verylightgreen 
 verydarklimegreen | darklimegreen | limegreen | lightlimegreen | verylightlimegreen 
      verydarkmagenta | darkmagenta | magenta | lightmagenta | verylightmagenta 
      verydarkskyblue | darkskyblue | skyblue | lightskyblue | verylightskyblue 
             verydarkblue | darkblue | blue | lightblue | verylightblue 
            verydarkcyan | darkcyan | cyan | lightcyan | verylightcyan 
        verydarkviolet | darkviolet | violet | lightviolet | verylightviolet 
               verydarkred | darkred | red | lightred | verylightred 
        verydarkorange | darkorange | orange | lightorange | verylightorange 
        verydarkyellow | darkyellow | yellow | lightyellow | verylightyellow 
           verydarkbrown | darkbrown | brown | lightbrown | verylightbrown"

 # 
 # Default User-Defined Options: 
  CFDIR=`pwd`;
  if [ $GFFDIR ]
    then
      if [ -d "$GFFDIR" ]                  ###### Environment variable for working directory.
        then
          CFDIR="$GFFDIR";
        fi
    fi
  bgcolor="white";
  fgcolor="black";
  v01=0; n01="load_customfile";
  v02=""; n02="customfile_name";
  if [ $GFF_CUSTOM_FILE ]         ###### Environment variable for default custom file name.
    then
      v03="$CFDIR/$GFF_CUSTOM_FILE";
    else
      v03="$CFDIR/.gff2psrc";
    fi
    n03="customfile_name_default";
  v04=0; n04="exist_default_customfile";
  v04_1=0; n04_1="create_default_customfile";
  v05=0; n05="print_report";
  v06="Landscape"; n06="page_orientation";
  v07="a4"; n07="page_size";
  v08=1; n08="page_number";
  v09=1; n09="blocks_x_page";
  v10=0; n10="nucleotides_x_line";
  v11=1; n11="show_blocks_top-bottom";
  v12="a4,595,842"; n12="page_bbox";
  v13=10; n13="major_tickmarks_num";
  v14=-1; n14="major_tickmarks_nucleotides";
  v15=10; n15="minor_tickmarks_num";
  v16=-1; n16="minor_tickmarks_nucleotides";
  v17="true"; n17="show_positions";
  v18_s='*'; v18_e='*'; n18="zoom";
  v19="FGcolor"; n19="foreground_color";
  v20="BGcolor"; n20="background_color";
  v21="default"; n21="header_style";
  v22="on"; n22="show_page_numbers";
  v23="on"; n23="show_date";
  v24="on"; n24="show_time";
  v25="default"; n25="title";
  v26="default"; n26="subtitle";
  v27="on"; n27="strand_show_forward";
  v28="on"; n28="strand_show_reverse";
  v29="on"; n29="strand_show_independent";
  v30="blue";   n30="frame0_color";
  v31="red";    n31="frame1_color";
  v32="green";  n32="frame2_color";
  v33="orange"; n33="frame_unknown_color";
# Layout Properties
  c01="1cm"; m01="margin_left"
  c02="1cm"; m02="margin_right"
  c03="1cm"; m03="margin_upper"
  c04="1cm"; m04="margin_bottom"
  c05="0.25cm"; m05="default_scale_width"
  c06="1cm";    m06="default_track_width"
  c07="0.25cm";    m07="default_track_spacing_width"
  c08="0.25cm"; m08="default_block_spacing_width"
  c09=1; m09="show_inner_scale"
  c10=1; m10="show_outer_scale"
  c11="default"; m11="header_style"
  # c11="boxed"; m11="header_style"
  c12="default"; m12="block_style"
  # c12="boxed"; m12="block_style"
  #
  # c20=$c05;   m20="text_color"
  # c21="none"; m21="label"
} # End of Defaults

#  
# Default ColorDefinition:
#
colorDef () { # still not defined seagreen and limegreen (now same as green)
cat <<'@@@COLORS@@@'
% black+grey+white
black               0.00 0.00 0.00 1.00
verydarkgrey        0.00 0.00 0.00 0.90
darkgrey            0.00 0.00 0.00 0.75
grey                0.00 0.00 0.00 0.50
lightgrey           0.00 0.00 0.00 0.25
verylightgrey       0.00 0.00 0.00 0.10
white               0.00 0.00 0.00 0.00
% magenta
verydarkmagenta     0.00 1.00 0.00 0.50
darkmagenta         0.00 1.00 0.00 0.25
magenta             0.00 1.00 0.00 0.00
lightmagenta        0.00 0.50 0.00 0.00
verylightmagenta    0.00 0.25 0.00 0.00
% violet
verydarkviolet      0.40 0.80 0.20 0.00
darkviolet          0.45 0.85 0.00 0.00
violet              0.30 0.60 0.00 0.00
lightviolet         0.15 0.55 0.00 0.00
verylightviolet     0.05 0.45 0.00 0.00
% blue
verydarkblue        1.00 1.00 0.00 0.25
darkblue            1.00 1.00 0.00 0.00
blue                0.85 0.85 0.00 0.00
lightblue           0.70 0.70 0.00 0.00
verylightblue       0.50 0.50 0.00 0.00
% skyblue
verydarkskyblue     0.95 0.15 0.00 0.40
darkskyblue         1.00 0.25 0.00 0.15
skyblue             1.00 0.25 0.00 0.00
lightskyblue        0.80 0.20 0.10 0.00
verylightskyblue    0.60 0.15 0.15 0.00
% cyan
verydarkcyan        1.00 0.00 0.00 0.50
darkcyan            1.00 0.00 0.00 0.25
cyan                1.00 0.00 0.00 0.00
lightcyan           0.50 0.00 0.00 0.00
verylightcyan       0.25 0.00 0.00 0.00
% seagreen
verydarkseagreen    0.65 0.00 0.95 0.40
darkseagreen        0.90 0.00 0.90 0.10
seagreen            1.00 0.00 1.00 0.00
lightseagreen       0.50 0.00 1.00 0.00
verylightseagreen   0.25 0.00 0.75 0.00
% green
verydarkgreen       0.65 0.00 0.95 0.40
darkgreen           0.90 0.00 0.90 0.10
green               1.00 0.00 1.00 0.00
lightgreen          0.50 0.00 1.00 0.00
verylightgreen      0.25 0.00 0.75 0.00
% limegreen
verydarklimegreen   0.65 0.00 0.95 0.40
darklimegreen       0.90 0.00 0.90 0.10
limegreen           1.00 0.00 1.00 0.00
lightlimegreen      0.50 0.00 1.00 0.00
verylightlimegreen  0.25 0.00 0.75 0.00
% yellow
verydarkyellow      0.00 0.00 1.00 0.30
darkyellow          0.00 0.00 1.00 0.10
yellow              0.00 0.00 1.00 0.00
lightyellow         0.00 0.00 0.50 0.00
verylightyellow     0.00 0.00 0.25 0.00
% orange
verydarkorange      0.00 0.60 1.00 0.00
darkorange          0.00 0.55 0.90 0.00
orange              0.00 0.50 0.70 0.00
lightorange         0.00 0.30 0.85 0.00
verylightorange     0.00 0.30 0.55 0.00
% red
verydarkred         0.00 0.90 0.90 0.30
darkred             0.00 0.80 0.90 0.10
red                 0.00 1.00 1.00 0.00
lightred            0.05 0.80 0.90 0.00
verylightred        0.15 0.40 0.60 0.00
% brown
verydarkbrown       0.00 0.85 1.00 0.70
darkbrown           0.00 0.75 1.00 0.60
brown               0.00 0.70 1.00 0.40
lightbrown          0.30 0.60 0.70 0.00
verylightbrown      0.15 0.45 0.55 0.00
@@@COLORS@@@
} # End of colorDef

#  
# Default PageSizes:
#
pagesizes () {  # Size_name Portrait_minor-axes:X Portrait_major-axes:Y
cat <<'@@@PAGESIZES@@@'
a0         2384 3370
a1         1684 2384
a2         1190 1684
a3          842 1190
a4          595  842
a5          420  595
a6          297  420
a7          210  297
a8          148  210
a9          105  148
a10          73  105
b0         2920 4127
b1         2064 2920
b2         1460 2064
b3         1032 1460
b4          729 1032
b5          516  729
b6          363  516
b7          258  363
b8          181  258
b9          127  181
b10          91  127
10x14       720 1008
executive   540  720
folio       612  936
ledger     1224  792
legal       612 1008
letter      612  792
quarto      610  780
statement   396  612
tabloid     792 1224
userdefined 595 2384
@@@PAGESIZES@@@
} # End of pagesizes

##############################################################
################### SHELL MAIN FUNCTIONS #####################
#
# Defining Help...
Help () {
#  echo ""
#  echo "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
#  echo "         1         2         3         4         5         6         7         8"
  echo ""
  echo "NAME           $PROGRAM"
  echo "VERSION        $VERSION"
  echo ""
  echo "Creation DATE: $SHCREATION"
  echo "Last REVISION: $SHREVISION"
  echo ""
  echo "SYNOPSIS"
  echo ""
  echo "      $USAGE"
  echo ""
  echo "DESCRIPTION"
  echo ""
  echo "       This program draws color-filled DotPlots"
  echo "       from files with gff-formatted data fields."
  echo "   "
  echo ""
  echo "OPTIONS"
  echo ""
  echo "     -h  Shows this help."
  echo "     -H <option> Shows only help for the especified option."
  echo "     -v Verbose mode, a report is sent to standard error."
  echo "     -s <page_size> Useful for modifying the page size (default is a4)."
  echo "     -P <\#> Sets how many pages are needed to split your output (default is one)."
  echo "     -p Switches page orientation to Portrait (default is Landscape)."
  echo "     -B <\#> Sets blocks per page (default is one)."
  echo "     -b Blocks from left to right and from top to bottom (default is top to bottom first)."
  echo "     -N <\#> Sets nucleotides per line (default is the largest sequence position from input gff-files)."
  echo "     -S <\#> Zoom first nucleotide (default is sequence origin)."
  echo "     -E <\#> Zoom last nucleotide (default is sequence length)."
  echo "     -n Switch off labels for element positions." 
  echo "     -L Switch off Header (Title area)."
  echo "     -l Does not show page numbering."
  echo "     -O Does not show date."
  echo "     -o Does not show time."
  echo "     -T <title_string> Defining title (default is input gff filename)."
  echo "     -t <subtitle_string> Defining subtitle (default is none)."
  echo "     -w or -f Switch off displaying forward-strand(Watson) elements."
  echo "     -c or -r Switch off displaying reverse-strand(Crick) elements."
  echo "     -i Switch off displaying strand-independent elements."
  echo "     -G <color_name> Sets color for FOREGROUND (default is black)."
  echo "     -g <color_name> Sets color for BACKGROUND (default is white)."
  echo "     -0 <color_name> Sets color for frame \"0\" (default is blue)."
  echo "     -1 <color_name> Sets color for frame \"1\" (default is red)."
  echo "     -2 <color_name> Sets color for frame \"2\" (default is green)."
  echo "     -3 <color_name> Sets color for frame \".\" (default is orange)."
  echo "     -M <\#> Number of major tickmarks per line (default 10)."
  echo "     -m <\#> Number of minor tickmarks between major tickmarks (default 10)."
  echo "     -K <\#> Major tickmarks scale in nucleotides, default is nucleotide length for lines divided by major tickmarks number (see option -T)."
  echo "     -k <\#> Minor tickmarks scale in nucleotides default is major tickmarks size divided by minor tickmarks number (see option -t)."
  echo "     -d Write (or rewrite if exist) default customfile \"$v03\"."
  echo "     -D <default_custom_filename> Create a new default customfile with the given filename."
  echo "     -C <custom_filename>  Load given custom file and append to default custom file (.gff2psrc)."
  echo ""
  echo "ENVIRONMENT VARIABLES"
  echo ""
  echo "     You can specify the $PROGRAM path where it can find the default files with the shell variable GFFDIR."
  echo "     You can also define the default custom filename you will like with the variable GFF_CUSTOM_FILE, program default filename for custom file is \".gff2psrc\"."
  echo ""
  echo "COMMENTS"
  echo ""
  echo "  * Colors Defined are:"
  echo ""
  echo "$COLORS"
  echo ""
  echo "BUGS"
  echo ""
  echo "  Please, report bugs to:"
  echo "       $AUTHOR"
  echo "       e-mail: $EMAIL"
  echo "       Mail  : "
  gawk 'BEGIN{tt=ARGV[1];ARGV[1]="";gsub("\%\%","",tt);printf tt;print}' "$MAIL"
  echo ""
 return 0
} # End of Help

ShowHelpLine () {
 Help | gawk 'BEGIN{
  IGNORECASE=1; flg=0; srch=ARGV[1]; ARGV[1]=""
  gsub("-","",srch); srch="\ -"srch"\ " }
  { if ($0~srch) { print $0; flg=1 } }
  END{ if (!flg) printf "\n\tERROR: Option %s is not defined,\n\t\tmake sure which option you need help.\n",srch }' $1 
 echo ""
 return 0
} # End of ShowHelpLine

##############################################################
################# POSTSCRIPT MAIN FUNCTIONS ##################
#
# Printing PostScript Prolog (Constants,Variables and Functions)...
MAINPSHEADER () {
gawk 'BEGIN{ 
 # Find actual date...
 "date" | getline d;
 split(d,dt," ");
 date = dt[3] "." dt[2] "." dt[6] " " substr(dt[4],1,5);
 # Finding logged user...
 "whoami" | getline usr;
 # Printing PostScript Header...
 bg=  "%%\!PS-Adobe-3.0\n";
 bg=bg"%%%%Title: %s\n";
 bg=bg"%%%%Creator: %s\n";
 bg=bg"%%%%Version: %s\n";
 bg=bg"%%%%CreationDate: %s\n";
 bg=bg"%%%%For: %s\n";
 bg=bg"%%%%Pages: (atend)\n";
 bg=bg"%%%%Orientation: %s\n";
 bg=bg"%%%%BoundingBox: 0 0 %s %s\n";
 bg=bg"%%%%EndComments\n%%\n";
 bg=bg"%% Author : %s\n";
 bg=bg"%% e-mail : %s\n";
 bg=bg"%% Mail Adress:\n%s\n%%\n";
 if (ARGV[1]!~"##dflt##") title=ARGV[1];
 else title="gff-format to PostScript";
 split(ARGV[9],bbary,",");
 printf bg, title, ARGV[2], ARGV[3], date, usr, ARGV[8], bbary[2], bbary[3], ARGV[4], ARGV[5], ARGV[6];
 printf "%% ------------------------------------------------------------------------\n";
 printf "%%                     %s\n",ARGV[7];
 printf "%% ------------------------------------------------------------------------\n";
 for (i=1;i<=9;i++) ARGV[i]="";
}' "##dflt##" "$PROGRAM" "$VERSION" "$AUTHOR" "$EMAIL" "$MAIL" "$PSPROGRAM" "$v06" "$v12"

cat <<'@@@EndProlog@@@'
% 
%    $Id: gff2ps,v 1.30 1999-07-26 21:20:14 jabril Exp $
% 
% 
%        Converting GFF files to PostScript plots.
%
%        Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
%                                    Roderic GUIGO SERRA       
%
%    This program is free software; you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation; either version 2 of the License, or
%    (at your option) any later version.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program; if not, write to the Free Software
%    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
%
% ------------------------------------------------------------------------
%
%%BeginProlog
%
%%BeginProcSet: ShortNames 1.0 0
/tflg false def % test flag
/bdf { bind def } bind def
/xdf { exch def } bdf
/cm { 28.35 mul } bdf
/in { 72    mul } bdf
%%EndProcSet:   ShortNames 1.0 0
%
%%BeginProcSet: Constants 1.0 0
% Printing Offset
/VUpOS 0.25 cm def  % offset defines non printable
/VDnOS 0.25 cm def  % paper area for pages (printer outlimits).
/HLtOS 0.25 cm def
/HRtOS 0.25 cm def
@@@EndProlog@@@

colorDef | gawk 'BEGIN{ i=0 }
 { if ($1!="%") { count[i++]=$1; C[$1]=$2; M[$1]=$3; Y[$1]=$4; K[$1]=$5 } }
 END {
  printf "%% Fixed Color Variables (CMYK)\n";
  printf "/colordict %s dict def colordict begin %% %s colors + 28 definitions\n", (i+28), i;
  for (j=0;j<i;j++) { n=count[j]; printf "/%-20s { %-4s %-4s %-4s %-4s } def\n", n,C[n],M[n],Y[n],K[n] }
  printf "end %% colordict\n" }' -
 
pagesizes | gawk 'BEGIN{ i=0 }
 { if ($1!="%") { count[i++]=$1; X[$1]=$2; Y[$1]=$3 } }
 END{ 
  printf "%%  Paper Sizes  (in points)\n";
  printf "/pagedict %s dict def pagedict begin %% %s sizes defined\n", (i+1), i;
  for (j=0;j<i;j++) printf "/pg%-12s { %4s %4s } def\n", count[j], X[count[j]], Y[count[j]];
  printf "end %% pagedict\n%%%%EndProcSet:   Constants 1.0 0\n" }' -

} #### End of MAINPSHEADER function #### 

#
# Printing Main PostScript Routines...
MAINPSPROCS () { 
cat <<'@@@MAINProcs@@@'
%%EndProcSet:   Setting_Vars 1.0 0
%
%%BeginProcSet: Page_Layout 1.0 0
% checking if margins are within the defined offset
flglscape {
 UpM HLtOS lt { /UpM HLtOS def } if % Checking margins for flglscape mode
 DnM HRtOS lt { /DnM HRtOS def } if
 LtM VDnOS lt { /LtM VDnOS def } if
 RtM VUpOS lt { /RtM VUpOS def } if
 } {
  UpM VUpOS lt { /UpM VUpOS def } if % Checking margins for portrait mode
  DnM VDnOS lt { /DnM VDnOS def } if
  LtM HLtOS lt { /LtM HLtOS def } if
  RtM HRtOS lt { /RtM HRtOS def } if
  } ifelse
% defining pagelimits and X - Y scales (Xlim Ylim)
/pglim { Dpage pop LtM RtM add sub Dpage exch pop UpM DnM add sub } def
% Defining starting point on page.
/XORI LtM def
/YORI UpM def
% Defining page-elements layout.
/XSTitl pglim pop XOriTitl 2 mul sub def
/XSBlck pglim pop def
/YSBlck { pglim exch pop FlgTitl { YSTitl YOriTitl add NBlck } { 0 NBlck 1 sub } ifelse BlckSp mul add sub NBlck div } def
/XOriBlck 0 def
/YOriBlck { FlgTitl { YOriTitl YSTitl add BlckSp add } { 0 } ifelse } def
/XSPlot { XSBlck FLftLbl { XLftLbl sub } if FRgtLbl { XRgtLbl sub } if } def
/XOriPlot { XOriBlck FLftLbl { XLftLbl add } if } def
/Xscale XSPlot MaxNuclPage div def
/YSLine YSBlck LnTot div def
/tracksize tracksize YSLine mul def
/spcrsize spcrsize YSLine mul def
/YSFwd LnFwd YSLine mul def
/YSBth LnBth YSLine mul def
/YSRvs LnRvs YSLine mul def
/YSTck LnTck YSLine mul def
 /is1tck LnFwd 0 gt LnBth 0 gt and LnFwd 0 gt LnRvs 0 gt and or LnBth 0 gt LnRvs 0 gt and or def
 /is2tck LnBth 0 gt LnFwd 0 gt LnRvs 0 gt and and def % true if must plot two tickmark lines
%%EndProcSet:   Page_Layout 1.0 0
%
%%BeginProcSet: functions 1.0 0
/F { scale } bdf
/T { translate } bdf
/S { gsave } bdf
/R { grestore } bdf
/m { moveto } bdf
/rm { rmoveto } bdf
/l { lineto } bdf
/rl { rlineto } bdf
/K { stroke } bdf
/scmyk { setcmykcolor } bdf
/slw { setlinewidth } bdf
/min { 2 copy gt { exch } if pop } bdf 
/max { 2 copy lt { exch } if pop } bdf
/Xscm { Xscale mul } bdf /Xscme { Xscm exch } bdf
/ChkLimits { 3 copy pop 5 2 roll dup dup 5 1 roll 3 1 roll lt 3 1 roll gt or { pop false } { true } ifelse } def 
/nucdif { 2 copy exch sub } bdf
%%EndProcSet:   functions 1.0 0
%
%%BeginProcSet: text_functions 1.0 0
/sfont { findfont exch scalefont setfont } bdf
%/strh { S newpath 0 0 m false charpath flattenpath pathbbox exch pop exch sub exch pop R } bdf
/chrh { S newpath 0 0 m false charpath flattenpath pathbbox exch pop 3 -1 roll pop R } bdf
/strh { 2 dict begin /lly 0.0 def /ury 0.0 def { ( ) dup 0 4 -1 roll put chrh dup ury gt { /ury xdf } { pop } ifelse dup lly lt { /lly xdf } { pop } ifelse } forall ury end } bdf % lly add end } bdf
% /desc { 2 dict begin /lly 0.0 def /ury 0.0 def { ( ) dup 0 4 -1 roll put chrh pop dup lly lt { /lly xdf } { pop } ifelse } forall lly end } bdf
/stringheight  { S newpath 0 0 m (0) false charpath flattenpath pathbbox exch pop exch sub exch pop 0.95 mul R } bdf
/ct { S 0 T sfont scmyk dup stringwidth pop 2 div neg stringheight 2 div neg m show R } bdf
% X Y angle string valign halign fnt color ttxt
 % valign : tv (top)  cv (middle) bv (bottom)
 % halign : lh (left) ch (center) rh (right)
/ttxt { S scmyk sfont 8 dict begin /h xdf /v xdf /lbl xdf /angle xdf /y xdf /x xdf /hs lbl stringwidth pop neg def /vs lbl strh neg def x y T angle rotate h (rh) eq { hs } { h (ch) eq { hs 2 div } { 0 } ifelse } ifelse v (tv) eq { vs } { v (cv) eq { vs 2 div } { 0 } ifelse } ifelse m lbl show end R } bdf
%%EndProcSet:   text_functions 1.0 0
%
%%BeginProcSet: painting_functions 1.0 0
/dotted { [ 1 ] 0 setdash } def
/bbox { 4 copy 3 1 roll exch 6 2 roll 8 -2 roll m l l l closepath } bdf
/scolor { colordict exch get exec scmyk } bdf
%
colordict begin % adding definitions and functions
 /lup { /ku xdf /yu xdf /mu xdf /cu xdf } bdf
 /lmd { /km xdf /ym xdf /mm xdf /cm xdf } bdf
 /ldn { /kd xdf /yd xdf /md xdf /cd xdf } bdf
 /load2col { lup ldn /dk ku kd sub def /dy yu yd sub def /dm mu md sub def /dc cu cd sub def } bdf
 /load3col { lup lmd ldn /uk ku km sub def /uy yu ym sub def /um mu mm sub def /uc cu cm sub def /dk km kd sub def /dy ym yd sub def /dm mm md sub def /dc cm cd sub def } bdf
 /col2 { 2 dict begin /p xdf /pcd { p mul add } bdf cd dc pcd md dm pcd yd dy pcd kd dk pcd scmyk end } bdf
 /col3 { 3 dict begin /p xdf /pcd { p 2 mul mul add } bdf /pcu { p 0.5 sub 2 mul mul add } bdf p 0.5 le { cd dc pcd md dm pcd yd dy pcd kd dk pcd } { cm uc pcu mm um pcu ym uy pcu km uk pcu } ifelse scmyk end } bdf
 /rainbow { 1 dict begin /p xdf p 0.1 le { p 0.2 div 0.5 add 1 0 0 scmyk } { p 0.4 le { 1 1 p 0.1 sub 0.3 div sub 0 0 scmyk } { p 0.6 le { 1 0 p 0.4 sub 0.2 div 0 scmyk } { p 0.8 le { 1 p 0.6 sub 0.2 div sub 0 1 0  scmyk } { 0 p 0.8 sub 0.2 div 1 0 scmyk } ifelse } ifelse } ifelse } ifelse end } bdf
end % colordict
%%EndProcSet:   painting_functions 1.0 0
%
%%BeginProcSet: header_functions 1.0 0
%
headerdict begin
 /ttfnt { 20 /Helvetica-Bold FGcolor } def
 /stfnt { 12 /Helvetica      FGcolor } def
 /dtfnt {  9 /Times-Roman    FGcolor } def
 /tmfnt {  9 /Times-Roman    FGcolor } def
 /pgfnt {  9 /Times-Roman    FGcolor } def
 /Header { S XOriTitl YOriTitl YSTitl add T 1 -1 F ShwTBx { S 0 0 XSTitl YSTitl bbox FGcolor scmyk K R } if ShwTt Title () ne and { 0.25 cm YSTitl 2 div 0 Title (cv) (lh) ttfnt ttxt } if ShwST SubTitle () ne and { XSTitl 2 div YSTitl 2 div 0 SubTitle (cv) (ch) stfnt ttxt } if ShwTime { XSTitl 4.5 sub 9 0 Sdate (tv) (rh) tmfnt ttxt } if ShwDate { XSTitl 4.5 sub YSTitl 2 div 0 Stime (cv) (rh) dtfnt ttxt } if Shwp_num { XSTitl 4.5 sub YSTitl 9 sub 0 PageNumber (bv) (rh) pgfnt ttxt } if R } bdf
end
%
%%EndProcSet:   header_functions 1.0 0
%
%%BeginProcSet: tickmarks 1.4 0
% Rule.ps ---> rules and scales
/tmdct 22 dict def tmdct begin
 /ShowGrid 0 def % 0 - none : 1 - MinTicks : 2 - MaxTicks : 3 - Both
 /Gridup true def /Griddn true def /flgup true def
 /TkMrkHW TkMrkW  2 div def
 /TkMrkDW TkMrkW 10 div def
 /TkFont { TkMrkHW /Helvetica } def
 /MaxWidthT { S MaxNuclPage 10 string cvs TkFont sfont stringwidth pop 2 mul R } bdf
 /CheckCloser { 3 copy pop MaxWidthT sub 3 1 roll MaxWidthT add 3 1 roll dup dup 5 1 roll 3 1 roll lt 3 1 roll gt or 4 1 roll 3 copy dup 3 1 roll ne 3 1 roll ne and 5 -1 roll and { pop false } { true } ifelse } bdf
 /ctextick { S TkFont sfont dup stringheight 2 div exch stringwidth pop 2 Xscm div neg Xscm exch 2 copy neg T 2 mul exch 2 mul neg exch S 0 0 bbox BGcolor scmyk S tflg { FGcolor scmyk } if 2 slw K R fill R 0 0 m FGcolor scmyk show R } bdf
 /bltextick { S TkFont sfont dup stringwidth pop 2 Xscm div neg Xscm TkMrkHW 2 copy flgup { TkMrkDW add T } { 2 mul T 1 -1 F } ifelse exch 2 mul neg exch S 0 0 bbox BGcolor scmyk S tflg { FGcolor scmyk } if 2 slw K R fill R 0 0 m FGcolor scmyk show R } bdf
 /tonormtick { 0 eq { dup dup 0 ne { MinTick mod } if sub exch dup dup 0 ne { MinTick mod } if sub exch } { dup dup 0 ne { MaxTick mod } if sub exch dup dup 0 ne { MaxTick mod } if sub exch } ifelse } bdf
 /Mkg { 0 0 m l FGcolor scmyk dotted K } bdf
 /MkVGrid { S slw Gridup flgup not { not } if { 0 up Mkg } if Griddn flgup not { not } if { 0 down neg Mkg } if  R } bdf
 /MkAtick { slw 0 TkMrkHW neg m 0 TkMrkHW l FGcolor scmyk K } bdf
 /MkBtick { S dup Xscm 0 T ShowGrid 2 eq ShowGrid 3 eq or { 0.25 MkVGrid } if 1 MkAtick CheckCloser { 10 string cvs ctextick } if R } bdf
 /MkCtick { slw 0 0 m 0 TkMrkHW 3 -1 roll { TkMrkDW sub } if l FGcolor scmyk K } bdf
 /MkDtick { S dup Xscm 0 T CheckCloser { 10 string cvs bltextick } if ShowGrid 2 eq ShowGrid 3 eq or { 0.25 MkVGrid } if false 1 MkCtick R } bdf
 /baseline { S Xscm TkMrkDW m Xscm TkMrkDW l TkMrkDW 2 mul slw FGcolor scmyk K R } bdf
 /r { /Gridup true def /Griddn true def /flgup true def 0 exch TkMrkHW sub T S 0 T 1 -1 F 5 { 2 copy } repeat pop neg Xscm 0 T 0 tonormtick MinTick exch { ChkLimits { S Xscm 0 T 0.25 MkAtick ShowGrid 1 eq ShowGrid 3 eq or { 0 MkVGrid } if R } if } for 1 tonormtick MaxTick exch { ChkLimits { MkBtick } if } for 2 { dup dup 0 ne { MaxTick mod } if 0 ne { MkBtick } { pop } ifelse } repeat R } bdf
 /x { 6 { 2 copy } repeat pop neg Xscm 0 T baseline 0 tonormtick MinTick exch { ChkLimits { S Xscm 0 T true 0.25 MkCtick ShowGrid 1 eq ShowGrid 3 eq or { 0 MkVGrid } if R } if } for 1 tonormtick MaxTick exch { ChkLimits { MkDtick } if } for 2 { dup dup 0 ne { MaxTick mod } if 0 ne { MkDtick } { pop } ifelse } repeat } bdf 
 /s { /Gridup false def /Griddn true def /flgup true def 0 exch TkMrkW add T S 0 T 1 -1 F x R } bdf
 /z { /Gridup true def /Griddn false def /flgup false def 0 exch T S 0 T 1 1 F x R } bdf
end % tmdct
%%EndProcSet:   tickmarks 1.4 0
%
%%BeginProcSet: objects 1.1 0
/shpdct 100 dict def shpdct begin
 /mtrx matrix def
 /LY { Yscl 0.5 mul } bdf
%
% X Y angle string valign halign fnt color ttxt
% functions for vectors-like data-sets
 /rt { tracksize strnd (.) eq { 0.975 mul } { 0.50 mul } ifelse } bdf
 /clrselc { dup 2 eq { pop load2col /clrproc { {col2} } def } { dup 3 eq { pop load3col /clrproc { {col3} } def } { dup 0 eq { pop white black load2col /clrproc { {col2} } def } { dup 4 eq { 5 { pop } repeat /clrproc { {rainbow} } def } { 1 eq { white 8 4 roll load2col /clrproc { {col2} } def } if } ifelse } ifelse } ifelse } ifelse } bdf % no end for closing dict because grdct must be closed by calling function
% /ov { S shpdct begin exch Xscm exch T { currentfile token { exec } { exit } ifelse } loop end R } bdf
% /v { S GetVtVar Xscm dup vtoffset sub exch vtoffset add 0 m 0 l rt slw clrproc exec K R } bdf
 /GetVtVar { /v_cmod xdf /v_end exch Xscm def /v_ori exch Xscm def colordict begin v_cmod nclrselc } bdf
 /vt { S /v_os exch Xscm def GetVtVar R } bdf
 /vp { S GetVtVar R } bdf
 /v_end { end exit } bdf   % end is for grdct dict
%
% Functions for Shapes......
 /getfrcol { dup (.) eq { pop frmN } { dup 0 eq { pop frm0 } { dup 1 eq { pop frm1 } { 2 eq { frm2 } if } ifelse } ifelse } ifelse } bdf
 /cmdln { S 0 m sqdif 2 div neg 0 rl scmyk K R } bdf
 /lnfill { S Yscl slw sqdif cmdln sqdif 2 div cmdln R } bdf
 /frmfill { frm getfrcol rmd getfrcol lnfill } bdf
 /rnbfill { 1 dict begin S /incr sqdif 100 div def 0 incr sqdif { dup dup incr add 0 exch 0 m l dup 0 gt { sqdif div } if rainbow Yscl slw K } for R end } bdf 
 /setcolmod { S colordict begin cmod cvx exec dup 1 eq { pop scmyk fill } { dup 2 eq { pop lnfill } { dup 5 eq { 5 { pop } repeat frmfill } { dup 4 eq { 5 { pop } repeat rnbfill } { 0 eq { BGcolor scmyk fill } if } ifelse } ifelse } ifelse } ifelse end R } bdf
 /ShFont { TkMrkW 2 div /Helvetica } bdf 
 /postk { S 0 0 m 0 LY 0.55 mul rl 0.75 setgray 0 slw K R } bdf
 /shwpos { S Flgspos { seqori LY ScV 0 eq { 0.55 mul neg } if T sqend sqdif sqori 0 2 { S 0 T postk 10 string cvs 0 0 S strnd (-) ne { 1 -1 F 45 } { -45 } ifelse 4 -1 roll strnd (-) eq { (tv) } { (bv) } ifelse (lh) ShFont FGcolor ttxt R R } repeat } if R } bdf
% *V align:  0 center : 1 baseline : -1 reverse
 /frs { S 0.25 slw strnd (-) eq { -1 1 F } if FtV 0 eq { 0 LY sc mul 2 div neg T } { FtV -1 eq { 1 -1 F } if } ifelse colordict begin p_s cvx exec end p_strk { fshp } if R } bdf
 /GetVar { /ftlbl xdf /FtV xdf /p_s xdf /cmod xdf /sc xdf /rmd xdf /frm xdf CKL nucdif /sqdif exch Xscm def /sqend xdf /seqend sqend Xscm def /sqori xdf /seqori sqori Xscm def pop /fflbl ftlbl () eq { false } { true } ifelse def /p_strk true def } bdf
 /p { S GetVar shwpos strnd (-) eq { seqend } { seqori } ifelse 0 T frs R } bdf
% Shapes......
 /fshp { S scmyk K R clip newpath setcolmod } bdf
 /cpt { /svmtrix mtrx currentmatrix def sqdif LY sc mul F m { l } repeat closepath svmtrix setmatrix } bdf
 /cptc { /svmtrix mtrx currentmatrix def sqdif LY sc mul F arc closepath svmtrix setmatrix } bdf
 /lft { sqdifn 0 T -1 1 F } bdf
 /cpb { fshp } bdf 
 /no_shp { /p_strk false def } bdf
 /line   { 0 0 m sqdif 0 l LY sc mul slw } bdf
 /box    { 1.0 0.0 1.0 1.0 0.0 1.0 3 0.0 0.0 cpt } bdf
 /fcir   { 0.5 0.5 0.5 0 360 cptc } bdf
 /hcir   { 0.5 0.5 0.5 0 180 cptc } bdf
 /frhead { 0.75 0.0 0.75 -0.1 0.755 -0.1 1.0 0.5 0.755 1.1 0.75 1.1 0.75 1.0 0.0 1.0 8 0.0 0.0 cpt } bdf
 /flhead { lft frhead } bdf
 /hrhead { 1.0 0.0 0.755 1.1 0.75 1.1 0.75 1.0 0.0 1.0 5 0.0 0.0 cpt } bdf
 /hlhead { lft hrhead } bdf
 /frend  { 1.0 0.0 1.0 1.0 0.0 1.0 0.0 0.995 0.25 0.5 0.0 0.005 6 0.0 0.0 cpt } bdf
 /flend  { lft frend } bdf
 /hrend  { 1.0 0.0 1.0 1.0 0.0 1.0 0.0 0.995 4 0.25 0.0 cpt } bdf
 /hlend  { lft hrend } bdf
 /frsgl  { 0.75 0.0 0.75 -0.1 0.755 -0.1 1.0 0.5 0.755 1.1 0.75 1.1 0.75 1.0 0.0 1.0 0.0 0.995 0.25 0.5 0.0 0.005 11 0.0 0.0 cpt } bdf
 /flsgl  { lft frsgl } bdf
 /hrsgl  { 1.0 0.0 0.755 1.1 0.75 1.1 0.75 1.0 0.0 1.0 0.0 0.995 6 0.25 0.0 cpt } bdf
 /hlsgl  { lft hrsgl } bdf
 /frtgl  { 0.0 0.0 0.0 1.0 1.0 0.505 3 1.0 0.495 cpt } bdf
 /fltgl  { lft frtgl } bdf
 /hrtgl  { 0.0 0.0 0.0 1.0 2 1.0 0.0 cpt } bdf
 /hltgl  { lft hrtgl } bdf
 /fdmd   { 0.0 0.5 0.5 1.0 1.0 0.5 3 0.5 0.0 cpt } bdf
 /hdmd   { 1.0 0.0 0.5 1.0 2 0.0 0.0 cpt } bdf
 /fdtgl  { 0.0 1.0 1.0 1.0 2 0.5 0.0 cpt } bdf
%
 /prmx {  S newpath
          1.0   -0.8  0.5   -0.8  0.5   -0.25 m l l
          FGcolor scmyk 0.1 slw K 
          1.0   -0.8  0.75  -0.60 0.75  -1.0  3  1.0   -0.8 cpt
          0.01 slw S K R fill R } bdf
 /hprm {  1.0    0.0  1.0   -0.25 0.0 0.25 3 0.0 0.0 cpt prmx } bdf
 /fprm {  0.0    0.25 1.0    0.25 1.0   -0.25 3  0.0 -0.25 cpt prmx } bdf
% ......Shapes
%
% Group functions...
% /ctr { S 0 T sfont scmyk dup stringwidth pop 2 div neg stringheight strnd (-) eq { 2 div } { 1.25 mul neg } ifelse m show R } bdf
 /g_score 0.5 def
 /GpFsz 8 def
 /GpFont { GpFsz /Helvetica } bdf
 /gshp { 0 gp_st gp_nd 0 0 g_score gcmod g_shape GpV grlbl p } bdf
 /gp_no { 4 { pop } repeat } bdf
 /gp_ln { scmyk 1 slw 0 0 m grdif 0 l K } bdf
 /gp_dt { dotted gp_ln } bdf
 /gp_bk { scmyk 0.25 slw 1 dict begin /tl grdif 2 div def 0 0 m S 0 -1 rl K R tl 0 rl S 0 1 rl K R tl 0 rl S 0 -1 rl K R K end } bdf
 /gp_raw { scmyk 0.25 slw strnd (-) eq { grdif 0 T -1 1 F } if 1 dict begin /tl grdif 0.05 mul def tl 0 m tl neg dup S 1 rl K R S -1 rl K R grdif tl sub 0 l S tl neg 1 rl 0 -2 rl tl 1 rl S fill R K R K end } bdf
 /gp_law { grdif 0 T -1 1 F gp_raw } bdf
 /CkGPL { dup GpFsz 2 div lt { pop GpFsz 0.55 mul } if } bdf
 /gln { S colordict begin g_line cvx exec end R } bdf
 /shgl { S grori Yscl ScV 0 eq { 0.25 mul } { 0.75 mul } ifelse T gln S grdif 2 div Yscl 0.25 mul 2 div CkGPL T strnd (-) ne { 1 -1 F } if ScV 1 eq { 1 -1 F } if Flgglbl { 0 0 0 grlbl (cv) (ch) GpFont FGcolor ttxt } if R R } bdf 
 /GetGVar { /grlbl xdf /g_line xdf /GpV xdf /g_shape xdf /gcmod xdf CKL nucdif /grdif exch Xscm def /gp_nd xdf /grend gp_nd Xscm def /gp_st xdf /grori gp_st Xscm def /Flgglbl grlbl () eq { false } { true } ifelse def } bdf
 /g_end { end exit } bdf 
end % shpdct
%%EndProcSet:   objects 1.1 0
%
%%BeginProcSet: blocks 1.0 0
/blckdct 35 dict def blckdct begin
 /XLL { blckori MaxTick sub } bdf
 /XLR { blckend MaxTick add } bdf
 /CKL { 2 { dup XLL lt { pop XLL } { dup XLR gt { pop XLR } if } ifelse exch } repeat } bdf
% 
% Group Functions
 /gp { S shpdct begin GetGVar shgl gshp { currentfile token { exec } { exit } ifelse } bind loop R } bdf
%
% Source Functions.
 /sc_no { 4 { pop } repeat } bdf
 /sc_ln { scmyk 0 slw 0 0 m XSPlot 0 l K } bdf
 /sc_dt { dotted sc_ln } bdf
 /sln { S colordict begin s_line cvx exec end R } bdf
 /sbc { -10 Yscl 2 mul neg XSPlot 10 add Yscl 1.5 mul bbox clip newpath } bdf % S K R
 /sbb { S 0 0 XSPlot Yscl bbox FlgScBx { 1 slw FGcolor scmyk K } { newpath } ifelse R sbc } bdf
 /shsl { S XLftLbl 2 div neg Yscl 2 div T strnd (-) ne { 1 -1 F } if  FLftLbl { Flgslbl { 0 0 0 srclbl (cv) (ch) 10 /Courier FGcolor ttxt } if } if R } bdf
 /GetSVar { /srclbl xdf /s_line xdf /strnd xdf /FlgScBx xdf /spacer exch spcrsize mul def /Yscl exch tracksize mul def /ScV xdf /Flgslbl srclbl () eq { false } { true } ifelse def strnd (.) eq { /Y Y spacer 2 div add def } { strnd (-) eq { /Y Y Yscl spacer add add def } if } ifelse } bdf
 /source { S GetSVar XOriPlot Y T strnd (-) eq { 1 -1 F } if shsl sbb S ScV 0 eq { 0 Yscl 2 div T } { ScV 1 eq { 0 Yscl T 1 -1 F } if } ifelse sln S blckori Xscm neg 0 T } bdf
 /s_end { R R R strnd (.) eq { /Y Y Yscl add spacer 2 div add def } { strnd (+) eq { /Y Y Yscl spacer add add def } if } ifelse } bdf
%
% Block Functions.
 /YBori { YSTck 2 mul } bdf
 /GetBVar { /blcknum exch 1 sub def /blckend xdf /blckori xdf /YB YOriBlck YSBlck blcknum mul add BlckSp blcknum mul add def } bdf
 /kbb { XOriBlck 5 sub -2 XSBlck 10 add YSBlck 2 add bbox FlgBkBx { 1 slw FGcolor scmyk K } { newpath } ifelse } bdf
 /tm { S tmdct begin /ShowGrid xdf exec end R } bdf
 /shwtck { YSFwd 0 gt YSFwd 0 eq YSBth 0 gt and or { /down YSFwd YSTck add def } { /down 0 def } ifelse YSRvs 0 gt { /up YSRvs YSTck add def } { /up 0 def } ifelse FlgOS { blckori blckend XOriPlot 0 {s} 2 tm } if is1tck FlgIS and { blckori blckend XOriPlot YSTck 3 mul YSFwd 0 gt { YSFwd add } { YSBth add } ifelse {r} 0 tm } if is2tck FlgIS and { blckori blckend XOriPlot YSTck 4 mul YSFwd add YSBth add {r} 0 tm } if FlgOS { blckori blckend XOriPlot YSBlck TkMrkW sub {z} 2 tm } if } bdf
 /ChangeStrand { /Y Y YSTck add def } bdf
 /b_end { R end } bdf
end
%%EndProcSet:   blocks 1.0 0
%
%%BeginProcSet: main_function_calls 1.0 0
%
/block { blckdct begin GetBVar S 0 YB T kbb shwtck /Y YBori def } bdf
%
%%EndProcSet:   main_function_calls 1.0 0
%
%%EndProlog
%
%%BeginSetup
%
% initgraphics
% true setpacking
true setstrokeadjust
0.125 slw
0 setlinejoin
0 setlinecap
%
%%EndSetup
%
@@@MAINProcs@@@
} #### End of MAINPSPROCS function

##############################################################
##################### SHELL FUNCTIONS ########################
#
# Testing parameters passed by User: Colors.
CheckColor () {
  gawk 'BEGIN{
    color=ARGV[1]
    if (color!~/^BG(color)?$|^FG(color)?$|^black$|^white$|^(very)?(light|dark)?(grey|(sea|lime)?green|(sky)?blue|cyan|violet|magenta|red|orange|yellow|brown)$/) {
      printf "\n<<<<ERROR>>>> \" %s \" is not a defined color.\n", color | "cat 1>&2"
      printf "              Default \" ARGV[2] \" is asigned to this option.\n" | "cat 1>&2"
      printf "              You can choose one of this colors:\n" | "cat 1>&2"
      print ARGV[3] | "cat 1>&2"
      print "" | "cat 1>&2"
      color=ARGV[2]
      }
    print color
    ARGV[1]=ARGV[2]=ARGV[3]=""
    }' $1 $2 "$COLORS"
  return 0
} # End of CheckColor

#
# Testing parameters passed by User: Integer Numbers.
CheckInt () {
  if [ `expr $1 : '[0-9]*'` -eq `expr $1 : '.*'` ]
    then echo "1"; return 0
    else 
      echo "<<<<ERROR>>>> \" $1 \" is not an integer value." 1>&2
      echo "              You must especify an integer value to -$W_OPTION" 1>&2
      echo "              Program will take value from defaults..." 1>&2
      echo "" 1>&2
      echo "0";return 1
    fi
  return 1
} # End of CheckInt

#
# Testing parameters passed by User: Page Sizes.
chkpagesize () {
  pagesizes | gawk 'BEGIN{
    pg=ARGV[1]; ARGV[1]=""; ec=0 }
    { if (pg==$1) { ec=1; ps=sprintf("%s,%s,%s",$1,$2,$3) } }
    END{ if (ec) { print ps }
         else { print "a4,595,842" } }' $1 -
  return 0
} # End of chkpagesize

#
# Testing if exist a File.
ExistCustomfile () {
  if [ ! -f "$1" ]
    then echo "0"
      echo "Report: Default Custom File does not exist." 1>&2
      return 0
    else echo "1" # exist_default_customfile
      echo "Warning: Default Custom File exist." 1>&2
      echo "          Custom_Filename: $1" 1>&2
      return 1
    fi
} # End of ExistCustomfile

ExistFile () {
  if [ ! -f "$1" ]
    then echo "0"
      echo "Warning: File "$1" is empty or does not exist." 1>&2
      return 1
    else echo "1" # exist_file
      echo "Report: File "$1" exist, included as a gff file." 1>&2
      return 0
    fi
} # End of ExistFile

###################################################################
################## MAIN GFF2PS SHELL SCRIPT #######################
###################################################################
############### CONVERTING GFF TO POSTSCRIPT ######################
###################################################################

Defaults

#
# Checking if default custom file exists
#  else switch on flag to create.
echo "" 1>&2
echo "Report: You have typed the following command line:" 1>&2
echo "" 1>&2
echo $CMDLine 1>&2
echo "" 1>&2

#
# When no options, no parameters and 
#  no inputstream are given, print USAGE.
npar=$#;
if [ $npar -eq 0 ] 
  then
    echo; echo $USAGE; echo; exit 1
  fi

#
# Asking for Help, output it to screen. 
case $1 in
  -h) Help; exit 2;;
  -H) echo; echo $PROGRAM" : Option Definition Help."; echo;
      if [ $npar -gt 1 ]; 
        then shift; fi;
      for temp in $@;
        do ShowHelpLine $temp; done;
      exit 2;;
  esac

#
# Processing all options and parameters passed to program.
while getopts :dD:C:vs:pP:B:bS:E:N:nT:t:G:g:LlOowfcri0:1:2:3:M:m:K:k:Hh W_OPTION
  do
    case $W_OPTION in
      H|h) Help; exit 2;;
      d) v04_1=1;;                    # create_default_customfile (.gff2psrc) or rewrite
      D) v04_1=1;                     # create_default_customfile or rename_it if exist
         v03="$CFDIR/$OPTARG";;
      C) if [ ! -f $CFDIR/$OPTARG ];    # load_customfile customfile_name
           then v01=0;
             echo "Error: Custom File $OPTARG does not exist...Not Loaded." 1>&2 ;
           else v01=1;
	         echo "Report: Adding $OPTARG Custom File to Default Custom File." 1>&2 ;
             v02="$CFDIR/$OPTARG";
           fi;;
      v) v05=1;;                        # print_report
      s) v07=$OPTARG;                   # page_bbox
         v12=`chkpagesize $v07`;;  
      p) v06="Portrait";;               # page_orientation
      P) if [ `CheckInt $OPTARG` ]
           then
             v08=$OPTARG;
           fi;;                  # page_number
      B) if [ `CheckInt $OPTARG` ]
           then
             v09=$OPTARG;
           fi;;                  # blocks_x_page
      b) v11=0;;                      # show_blocks_top-bottom
      S) if [ `CheckInt $OPTARG` ]
           then
             v18_s=$OPTARG;
           fi;;                  # zoom_begin
      E) if [ `CheckInt $OPTARG` ]
           then
             v18_e=$OPTARG;
           fi;;                  # zoom_end
      N) if [ `CheckInt $OPTARG` ]
           then
             v10=$OPTARG;
           fi;;                  # nucleotides_x_line
      n) v17="false";;           # show_positions
      G) v19=`CheckColor $OPTARG $fgcolor`;;    # foreground_color
      g) v20=`CheckColor $OPTARG $bgcolor`;;    # background_color
      L) v21="none";;          # header_style
      l) v22="off";;           # show_page_numbers
      O) v23="off";;           # show_date
      o) v24="off";;           # show_time
      T) v25=$OPTARG;;        # title
      t) v26=$OPTARG;;        # subtitle
      w|f) v27="off";;        # strand_show_forward
      c|r) v28="off";;        # strand_show_reverse
      i) v29="off";;          # strand_show_independent
      0) v30=`CheckColor $OPTARG $fgcolor`;;  # frame0_color
      1) v31=`CheckColor $OPTARG $fgcolor`;;  # frame1_color
      2) v32=`CheckColor $OPTARG $fgcolor`;;  # frame2_color
      3) v33=`CheckColor $OPTARG $fgcolor`;;  # frame_unknown_color
      M) if [ `CheckInt $OPTARG` ]
           then
             v13=$OPTARG;
           fi;;                  # major_tickmarks_num
      m) if [ `CheckInt $OPTARG` ]
           then
             v15=$OPTARG;
           fi;;                  # minor_tickmarks_num
      K) if [ `CheckInt $OPTARG` ]
           then
             v14=$OPTARG;
           fi;;                  # major_tickmarks_nucleotides
      k) if [ `CheckInt $OPTARG` ]
           then
             v16=$OPTARG;
           fi;;                  # minor_tickmarks_nucleotides
       :) ShowHelpLine $1; exit 2;;
      \?) ShowHelpLine $1; exit 2;;
    esac # case $W_OPTION
  done   # while getopts
# Done GetOpts

#
# Shifting all options tested before,
# without removing files passed to shell...
 incr=1
 while [ $OPTIND -gt $incr ]
   do shift; incr=`expr $incr + 1`; done

 GFF_INPUT_FILES=""; ck=0; hmf=0;
if [ $npar -ge $OPTIND ]
 then
 for files in $@
   do
     if [ `ExistFile ./$files` ]  # $CFDIR/
       then 
         if [ $ck -eq 1 ] 
           then
              GFF_INPUT_FILES=$GFF_INPUT_FILES" "
           fi
         GFF_INPUT_FILES=$GFF_INPUT_FILES./$files;  # $CFDIR/
         shift; ck=1;
         hmf=`expr $hmf + 1`;
       fi;
   done;
 fi
 if [ $hmf -eq 0 ]
   then
     echo "WARNING: You have not passed any gff_file to program, it will create an empty page..." 1>&2;
     if [ "$v18_e" = '*' ] 
       then
         v18_e=1000;
       fi;
   fi;

#
# Defining PLOToptions STRING for GNU awk programs.
 v04=`ExistCustomfile "$v03"`
 v18="$v18_s..$v18_e"
   P="BACKGROUND_COLOR:="$bgcolor"::FOREGROUND_COLOR:="$fgcolor"::"$n04_1":="$v04_1"::"
 P=$P$n01":="$v01"::"$n02":="$v02"::"$n03":="$v03"::"$n04":="$v04"::"$n05":="$v05"::"
 P=$P$n06":="$v06"::"$n07":="$v07"::"$n08":="$v08"::"$n09":="$v09"::"$n10":="$v10"::"
 P=$P$n11":="$v11"::"$n12":="$v12"::"$n13":="$v13"::"$n14":="$v14"::"$n15":="$v15"::"
 P=$P$n16":="$v16"::"$n17":="$v17"::"$n18":="$v18"::"$n19":="$v19"::"$n20":="$v20"::"
 P=$P$n21":="$v21"::"$n22":="$v22"::"$n23":="$v23"::"$n24":="$v24"::"$n25":="$v25"::"
 P=$P$n26":="$v26"::"$n27":="$v27"::"$n28":="$v28"::"$n29":="$v29"::"$n30":="$v30"::"
 P=$P$n31":="$v31"::"$n32":="$v32"::"$n33":="$v33"::"
 P=$P$m01":="$c01"::"$m02":="$c02"::"$m03":="$c03"::"$m04":="$c04"::"$m05":="$c05"::"
 P=$P$m06":="$c06"::"$m07":="$c07"::"$m08":="$c08"::"$m09":="$c09"::"$m10":="$c10"::"
 P=$P$m11":="$c11"::"$m12":="$c12"::"
 P=$P"DCF:=$CFDIR/.gff2psrc::InputFNs:="$GFF_INPUT_FILES
 PLOToptions=$P
 if [ $v05 -eq 1 ]
   then
     echo "" 1>&2
     echo "********************************************" 1>&2
     echo ">>>>> Option String Passed to Program <<<<<<" 1>&2
     echo "********************************************" 1>&2
     echo "" 1>&2
     echo $PLOToptions 1>&2
     echo "" 1>&2
   fi

MAINPSHEADER

# (cat <<'@@@EndPROGRAM@@@') |
# @@@EndPROGRAM@@@
# gawk -v CUSTOMFILE=$v03 -f - "$@"
#
(echo "$PLOToptions"; MAINPSPROCS) |
gawk 'BEGIN{
############ INITIALITATION ############
# Find actual date...
 "date" | getline d;
 split(d,dt," ");
 date = dt[3] " " dt[2] " " dt[6]; 
 time = substr(dt[4],1,5);
# gff data structure
  seqname  = 1;   gpname     = 1;
  source   = 2;   gpstart    = 2;
  feature  = 3;   gpend      = 3;
  start    = 4;   is_grouped = 4;
  end      = 5;   gplabel    = 5;
  score    = 6;
  strand   = 7;   v_step  = 11;
  frame    = 8;   v_scmin = 12;
  group    = 9;   v_scmax = 13;
  vector   = 10;  v_DATA  = 14;
# gff strand-frame codification
  strands["+"]=strands["."]=strands["-"]=1;
  wstr[1]="+";wstr[2]=".";wstr[3]="-";
  Frames["."]=Frames["0"]=Frames["1"]=Frames["2"]=1;
# coding shape-names
  shpnm["none"]="no_shp";
  shpnm["default"]=shpnm["line"]="line";
  shpnm["box"]="box";
  shpnm["circle"]="fcir";
  shpnm["half_circle"]="hcir";
  shpnm["arrow_head"]=shpnm["right_arrow_head"]="frhead";
  shpnm["half_arrow_head"]=shpnm["half_right_arrow_head"]="hrhead";
  shpnm["left_arrow_head"]="flhead";
  shpnm["half_left_arrow_head"]="hlhead";
  shpnm["arrow_end"]=shpnm["right_arrow_end"]="frend";
  shpnm["half_arrow_end"]=shpnm["half_right_arrow_end"]="hrend";
  shpnm["left_arrow_end"]="flend";
  shpnm["half_left_arrow_end"]="hlend";
  shpnm["single"]=shpnm["right_single"]=shpnm["arrow"]=shpnm["right_arrow"]="frsgl";
  shpnm["half_arrow"]=shpnm["half_right_arrow"]="hrsgl";
  shpnm["left_single"]=shpnm["left_arrow"]="flsgl";
  shpnm["half_left_arrow"]="hlsgl";
  shpnm["right_triangle"]="frtgl";
  shpnm["half_right_triangle"]="hrtgl";
  shpnm["left_triangle"]="fltgl";
  shpnm["half_left_triangle"]="hltgl";
  shpnm["diamond"]="fdmd";
  shpnm["half_diamond"]=shpnm["up_triangle"]="hdmd";
  shpnm["down_triangle"]="fdtgl";
# coding baseline alignment
  shpal["default"]=shpal["center"]="c";
  shpal["baseline"]=shpal["bottom"]="b";
  shpal["reverse"]=shpal["top"]="t";
# coding line-types
  lnnm["none"]="no";
  lnnm["default"]=lnnm["line"]="ln";
  lnnm["dotted"]=lnnm["dotted_line"]="dt";
  lnnm["bracket"]="bk";
  lnnm["arrow"]=lnnm["right_arrow"]="raw";
  lnnm["left_arrow"]="law";
# Loading PSMainProgram. Line 0 is the Command Line Parameter String.
  psline=0;
  while ((getline < ARGV[1])>0) { PSMAIN[psline++]=$0 };
  ARGV[1]="";
############## Defining pre-variables by CommandLine ############ 
 npar=split(PSMAIN[0],parm,"::");
 for (r=1;r<=npar;r++) {
   split(parm[r],elem,":=");
   if (elem[1]~/COLOR$/) {
     ecolor=elem[2];
     if (!ChkColor(ecolor)) elem[2]=Var["BACKGROUND_COLOR"];
     else if (ecolor~/^FGcolor$/) elem[2]=Var["FOREGROUND_COLOR"];
     } # if elem[1]
   Var[elem[1]]=elem[2] } # for
  delete PSMAIN[0]
  for (v in Var) printf "VAR: %-28s :: Value: %s\n", v, Var[v] | "sort | cat 1>&2"
  close("sort | cat 1>&2")
# Layout Properties
  Default["load_customfile"]=Var["load_customfile"];  # in this case we need to force variables.
  Default["customfile_name"]=Var["customfile_name"];  # in this case we need to force variables.
  Default["customfile_name_default"]=Var["DCF"];      # DCF="$CFDIR/.gff2psrc"
  Default["page_size"]="a4";               # Var["page_size"]
  Default["page_bbox"]="a4,595,842";       # Var["page_bbox"]
  Default["page_orientation"]="Landscape"; # Var["page_orientation"] : Landscape (default), Portrait.
  Default["margin_left"]="1cm";            # cm, in, pt
  Default["margin_right"]="1cm";           #
  Default["margin_upper"]="1cm";           #
  Default["margin_bottom"]="1cm";          #
  Default["foreground_color"]="FGcolor";  #
  Default["background_color"]="BGcolor";  #
  Default["nucleotides_x_line"]=0;     # Var["nucleotides_x_line"] : Default=0,gets the seqlenght from data
  Default["blocks_x_page"]=1;          # Var["blocks_x_page"] : Default=1
  Default["show_blocks_top-bottom"]=1; # Var["show_blocks_top-bottom"] : 1->TopBottom, 2->LeftRight.
  Default["page_number"]=1;            # Var["page_number"] : Default=1
  Default["strand_show_forward"]="on";     #
  Default["strand_show_reverse"]="on";     #
  Default["strand_show_independent"]="on"; #
  Default["zoom"]="*..*"      # "*..*", "*..end", "start..*", "start..end"
# General Properties
  Default["header_style"]="default";       # none, default, boxed
  Default["block_style"]="default";       # default, boxed
  Default["show_page_numbers"]="on"; #
  Default["show_date"]="on";         #
  Default["show_time"]="on";         #
  Default["title"]="default";        # none, default, "user def"
  Default["subtitle"]="default";     # none, default, "user def"
  Default["default_scale_width"]="0.25cm";         #
  Default["default_track_width"]="1cm";            #
  Default["default_track_spacing_width"]="0.25cm";    #
  Default["default_block_spacing_width"]="0.25cm"; #
  Default["major_tickmarks_num"]=10;           #
  Default["major_tickmarks_nucleotides"]=-1;   #
  Default["minor_tickmarks_num"]=10;           #
  Default["minor_tickmarks_nucleotides"]=-1;   #
  Default["frame_unknown_color"]="orange" #
  Default["frame0_color"]="blue";    #
  Default["frame1_color"]="red";     #
  Default["frame2_color"]="green";   #
  Default["show_inner_scale"]=1;    #
  Default["show_outer_scale"]=1;    #
  Default["show_positions"]="true"; #
# Features Properties
  FT_PROP["show_feature"]="on"; # 
  FT_PROP["label"]="default";       # none , default , "user-def"
  FT_PROP["feature_color"]="default"; # default,1color(color),2color(color..color),3color(color..color..color)
  FT_PROP["shape"]="box";           # box, arrow, end_arrow, circle # still not implemented: vector, spike, block
  FT_PROP["fill_shape_mode"]="default"; # none(BGcolor), default(FGcolor 1color), 1_color, 2_color, frame-remainder, rainbow
  FT_PROP["fill_vector_mode"]="default"; # none(0 BGcolor grad), default(0 black grad), rainbow(1), 1_color(BGcolor color 2), 2_color(color1 color2 2), 3_color(col1 col2 col3 2)
  FT_PROP["vert_align"]="default";  # center,baseline # still not implemented: reverse
  FT_PROP["layer"]=0;               # now is implemented, first sorting for feature lines is made on FT_PROP["layer"]
# Group Properties
  GR_PROP["feature_color"]="default";      # 
  GR_PROP["group_color"]="default";        # 
  GR_PROP["label"]="default";        # none , default , "user-def"
  GR_PROP["group_line"]="default";   # none , default (black line)
  GR_PROP["group_line_color"]="default"; #
  GR_PROP["group_shape"]="none";   # default (none) , ...
  GR_PROP["fill_shape_mode"]="default"; # none(BGcolor), default(FGcolor 1color), 1_color, 2_color, frame-remainder, rainbow
  GR_PROP["fill_vector_mode"]="default"; # none(0 BGcolor grad), default(0 black grad), rainbow(1), 1_color(BGcolor color 2), 2_color(color1 color2 2), 3_color(col1 col2 col3 2)
  GR_PROP["vert_align"]="default";    # center or baseline
  GR_PROP["show_group"]="on"; # 
# Lines (Method-Source) Properties
  SO_PROP["feature_color"]="default";       # 
  SO_PROP["group_color"]="default";         # 
  SO_PROP["label"]="default";         # none , default , "user-def"
  SO_PROP["source_style"]="default";       # default, boxed
  SO_PROP["source_line"]="default";   # none , default (black line), line, dotted
  SO_PROP["source_line_color"]="red"; #
  SO_PROP["vert_align"]="default";     # default,center,baseline(down), 
  SO_PROP["range"]="default";            # range of lower-upper scores (none, default, "#user_def number#")
  SO_PROP["track_scale"]=1;           #
  SO_PROP["track_spacing_scale"]=1; #
  SO_PROP["unfold_grouped_ungrouped"]="off"; # on/off
  SO_PROP["unfold_grouped_line"]="off";      # on/off
  SO_PROP["unfold_ungrouped_line"]="off";    # on/off
#
# Not defined yet:
#
#  Default["text_color"]=Default["foreground_color"]; 
#  Default["label"]="none";
#
#  FT_PROP["join"]="on";
#
#  GR_PROP["join_align"]="center";
#  GR_PROP["join_color"]=Default["foreground_color"];
#  GR_PROP["join_linetype"]="solid";
#  GR_PROP["join_show"]="off";
#
#  SO_PROP["show"]="on"; # 
#  SO_PROP["baseline_align"]="center";
#  SO_PROP["baseline_color"]=Default["foreground_color"];
#  SO_PROP["baseline_linetype"]="dotted";
#  SO_PROP["bbox_color"]=Default["foreground_color"];
#  SO_PROP["bbox_show"]="off";
#
#  ?_PROP["rule_scale"]="nucleotide";
#  ?_PROP["rule_rel"]="none";
#  ?_PROP["rule_abs"]="none";
#
# Data for upper-case to lower-case function #lcase()#
 CM["A"]="a";CM["B"]="b";CM["C"]="c";CM["D"]="d";CM["E"]="e";
 CM["F"]="f";CM["G"]="g";CM["H"]="h";CM["I"]="i";CM["J"]="j";
 CM["K"]="k";CM["L"]="l";CM["M"]="m";CM["N"]="n";CM["O"]="o";
 CM["P"]="p";CM["Q"]="q";CM["R"]="r";CM["S"]="s";CM["T"]="t";
 CM["U"]="u";CM["V"]="v";CM["W"]="w";CM["X"]="x";CM["Y"]="y";
 CM["Z"]="z";CM[""]="";CM[""]="";
# Initialization for some vars.
 BigLINE="########################################";
 MINSCORE=0.10;
 MAXSCORE=1.00;
 FIRST_POS=0;
 LAST_POS=0;
 nordcnt=ordcnt=0;
 grouped_=1;ungrouped_=0;
#
 if (Var["print_report"])
  printf "\n%s\nInput File...\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"

}
{ ############ READING .GFF FILES  ############
  is_EOF=0;
# skips those comment lines (starting with "#") or empty lines
# also checking if input line is gff_formated.
  while (!ChkInput()) { 
    if (Var["print_report"]) { printf ">>> %10s :: Not Read :: %s\n", NR, $0 | "cat 1>&2" };
    if (getline<=0) { is_EOF=1; break };
    }; # while
 if (!is_EOF) {
  # Printing Input Lines
  if (Var["print_report"]) { printf "%10s : %s\n", NR, $0 | "cat 1>&2" };
  # Reading gff-line elements.
  ReadElements()
  } # if (!is_EOF)
 }  # Main Loop END
END{
  #
  # Defining Object Properties.
  SET_VARS()
  # Sorting groups
  SortGroups()
  #
  # Making Lines...
  MakeGroupLines()
  #
  # Printing groups and elements sorted
  PrtSorted()
  #
  # Defining Page variables.
  SET_PAGE_VARS()
  #
  # PostScript Variables Setup.
  defPSvars()
  #
  # PostScript Main Procs.
  for (i=1;i<psline;i++) print PSMAIN[i]; 
  #
  ###############################################################
  # Pages MAIN LOOP: Start
  for (pages=1;pages<=P;pages++) {
    BORI=PORI
    startPSpage(pages,P)  # PostSCript PageSetup.
    for (blocks=1;blocks<=B;blocks++) {
      BEND=BORI+NOFFSET
      printf "%%\n%% Block Num: %s Page: %s\n%%\n",blocks,pages
      printf "%s %s %s block\n", BORI, BEND, blocks
      # make groups. assumes elements sorted by increasing acceptor position
      # PostScript Drawing strands, sources, groups, features
      # make plotlines. Put non-overlapping groups into the same plotting line.
      if (Var["print_report"]) printf "\n%s\nPrinting Lines......\nPage: %s Block: %s\nNuc_Ori: %s - Nuc_End: %s\n%s\n\n",BigLINE,pages,blocks,BORI,BEND,BigLINE | "cat 1>&2"
      PRINTGROUPS()
      if (Var["print_report"]) close(" sort +6 | cat 1>&2")
      # Closing Pages MAIN LOOP.
      printf "b_end\n"
      BORI+=BOFFSET
      } # for blocks
    # PostSCript Page Trailer.
    endPSpage(pages)
    PORI+=POFFSET
  } # for pages
  # Pages MAIN LOOP: End
  ###############################################################
  #
  # Closing PostScript document.
  PSTrailer(P)
  #
  # If not exist, create custom file (.gff2psrc)
  CREATECUSTOM()
 }
function lcase(string,    chr) { for (chr in CM) gsub(chr,CM[chr],string); return string }
function min(a,b) { if (a<=b) return a; else return b }
function max(a,b) { if (a>=b) return a; else return b }
function ChkLimits(o,O,e,E) { if (e<=O || o>=E) return 0; else return 1 } # start_,BORI,end_,BEND
function OnOff(v) { if (lcase(v)~/^1$|^on$|^y(es)?$|^t(rue)?$/) return 1; else return 0 }
function TxtBool(n) { if (n) return "true"; else return "false" }
function DoUnFoldMixed(SC) {
 if (!OnOff(PLOT_FT[SC,":","unfold_grouped_ungrouped"])&&((OnOff(PLOT_FT[SC,":","unfold_grouped_line"]) || OnOff(PLOT_FT[SC,":","unfold_ungrouped_line"]))))
   return 1; 
 else return 0 } # end of DoUnFoldMixed
function ChkColor(ncolor) {
 if (ncolor~/^FGcolor$|^black$|^white$|^(very)?(light|dark)?(grey|(sea|lime)?green|(sky)?blue|cyan|violet|magenta|red|orange|yellow|brown)$/)
   return 1
 else return 0 } # also when ncolor == ^BG$|(##DEFAULT##)
function checklbl(chain) {
 if (chain=="") return ""; 
 else { gsub(/[\(]/,"\\050",chain); gsub(/[\)]/,"\\051",chain); gsub(/[\<]/,"\\074",chain);
        gsub(/[\>]/,"\\076",chain); gsub(/[\/]/,"\\057",chain); gsub(/[\%]/,"\\045",chain);
        gsub(/[\[]/,"\\133",chain); gsub(/[\]]/,"\\135",chain); gsub(/[\{]/,"\\173",chain);
        gsub(/[\}]/,"\\175",chain); return chain } } # checklbl
function chkpo(v) { if (v=="Portrait") return "false"; else return "true" }
function chkps(v,    vv) {
 vv=lcase(v)
 if (vv~/^(a|b)([0-9]|10)$|^10x14$|^(executive|folio|(le)(tter|gal|dger)|quarto|statement|tabloid|userdefined)$/)
   return vv
 else return "a4" }
function chkun(st,    t,p) {
 t=lcase(st);
 if (gsub(/cm(s)?/,"",t)>0) { p=t" cm"; return p }
 else {
   if (gsub(/in(ch)?(s)?/,"",t)>0) { p=t" in"; return p }
   else {
     if (gsub(/pt(s)?/,"",t)>0) return t
     else return "1 cm" }}}
function calcpt(st,    t,p) { # return points
 t=lcase(st);
 if (gsub(/cm(s)?/,"",t)>0) { p=t*28.35; return p }
 else {
   if (gsub(/in(ch)?(s)?/,"",t)>0) { p=t*72; return p }
   else {
     if (gsub(/pt(s)?/,"",t)>0) return t
     else return 0 }}} # End of calcpt
function Nuc_round(nm,flg,    sign,nmp,i,mlt,smm,t) { # flg=0 then floor; flg=1 then ceiling.
 sign=nm<0?-1:1;
 if (sign==-1) { nm=-nm; flg=!(flg) }
 nmp=nm; for (i=1;nmp>10;i++) { nmp=nmp/10 };
 if (nm>=1000) mlt=2; else mlt=1;
 if (flg) {
   if (nm>0) {
     if (nm%10^(i-mlt)==0) smm=0; else smm=1;
	 t=nm>=100?sign*((int(nmp*10^(mlt-1))+smm)*10^(i-mlt)):sign*100 }
   else t=0 }
 else { if (nm>0) t=nm>=100?sign*((int(nmp*10^(mlt-1)))*10^(i-mlt)):0; else t=0 }
 return t } # End of Nuc_round
function Plot_Lbl(gff_feat,    sc,s,fl_gp,lbl,vn) {
 vn=PLOT_FT[gff_feat,":","label"]
 if (vn=="none") lbl="";
 else {
   if (vn=="default") { 
     lbl=gff_feat;
     if (gff_feat in GP_ary)  lbl=gp[sc,s,gp_cnt[gff_feat],gplabel];
     if (gff_feat in sources) lbl=lbl"("fl_gp""s")" }
   else lbl=vn }
 return checklbl(lbl) } # End of Plot_Lbl
function Set_feat_Clr(gff_feat,gp,sc,is_vector,    clrmode,color1,color2,color3,vn,clm,k,tmp) { # remaining to add vector definition colors.
 k=1; clrmode=0; color2=""; color3=""; # "none" or not defined
 if ((PLOT_FT[gp,":","feature_color"]=="default" || PLOT_FT[gp,":","feature_color"]=="") && (PLOT_FT[sc,":","feature_color"]=="default" || PLOT_FT[sc,":","feature_color"]=="")) {
   if (PLOT_FT[gff_feat,":","feature_color"]=="default") clm[1]="FGcolor";
   else {
     k=split(PLOT_FT[gff_feat,":","feature_color"],clm,/\.\./);
     if (!ChkColor(clm[1])) clm[1]="BGcolor" }}
 else {
   clm[1]="FGcolor";
   if (PLOT_FT[gp,":","feature_color"]!="default" || PLOT_FT[gp,":","feature_color"]!="") {
     k=split(PLOT_FT[gp,":","feature_color"],clm,/\.\./);
     if (!ChkColor(clm[1])) clm[1]="BGcolor" }
   if (PLOT_FT[sc,":","feature_color"]!="default" || PLOT_FT[sc,":","feature_color"]!="") {
     k=split(PLOT_FT[sc,":","feature_color"],clm,/\.\./);
     if (!ChkColor(clm[1])) clm[1]="BGcolor" }
   }
 color1=clm[1];
 if (is_vector) vn=PLOT_FT[gff_feat,":","fill_vector_mode"];
 else vn=PLOT_FT[gff_feat,":","fill_shape_mode"];
 if (vn=="none") { clrmode=0; color1="BGcolor" }
 else if (vn=="BGcolor") { clrmode=1; color1="BGcolor" }
 else if (vn=="FGcolor") { clrmode=1; color1="FGcolor" }
 else if (vn=="default") { clrmode=1 }
 else if (vn=="1_color") { clrmode=1 }
 else if (vn=="2_color") {
   clrmode=2;
   if (k>1 && ChkColor(clm[2])) color2=clm[2]; else color2="FGcolor" }
 else if (vn=="3_color" && is_vector ) {
   clrmode=3;
   if (color1=="BGcolor") color3="FGcolor";
   else if (color1=="FGcolor") color3="BGcolor";
   if (k>1 && ChkColor(clm[2])) color2=clm[2];
   else if (color1=="BGcolor" || color1=="FGcolor") color2="grey";
        else color2="BGcolor";
   if (k>2 && ChkColor(clm[3])) color3=clm[3];
   }
 else if (vn=="rainbow") { clrmode=4 }
 else if (vn=="frame-remainder") { clrmode=5 }
 if (color2!="") color2=" "color2;
 if (color3!="") color3=" "color3;
 tmp=color1""color2""color3" "clrmode; return tmp } # End of Set_feat_Clr
function Set_feat_Shape(gff_feat,grp,src    ,shp,pos,tmp,vn,cl) {
 split(Set_feat_Clr(gff_feat,grp,src,0),cl," ");
 vn=PLOT_FT[gff_feat,":","shape"]
 if (vn in shpnm) shp=shpnm[vn];
 else shp=shpnm["none"];  # (vn==" vector, spike, block ")
 tmp=cl[1]" "shp; return tmp } # End of Set_feat_Shape
function Set_group_Clr(grp,sc,    clrmode,color1,color2,color3,vn,clm,k,tmp) {
 k=1; clrmode=0; color2=""; color3=""; # "none" or not defined
 if (PLOT_FT[sc,":","group_color"]=="default" || PLOT_FT[sc,":","group_color"]=="") {
   if (PLOT_FT[grp,":","group_color"]=="default") clm[1]="FGcolor";
   else {
     k=split(PLOT_FT[grp,":","group_color"],clm,/\.\./);
     if (!ChkColor(clm[1])) clm[1]="BGcolor" }}
 else {
   clm[1]="FGcolor";
   if (PLOT_FT[sc,":","group_color"]!="default" || PLOT_FT[sc,":","group_color"]!="") {
     k=split(PLOT_FT[sc,":","group_color"],clm,/\.\./);
     if (!ChkColor(clm[1])) clm[1]="BGcolor" }
   }
 color1=clm[1];
 vn=PLOT_FT[grp,":","fill_shape_mode"]
 if (vn=="none") { clrmode=0; color1="BGcolor" }
 else if (vn=="BGcolor") { clrmode=1; color1="BGcolor" }
 else if (vn=="FGcolor") { clrmode=1; color1="FGcolor" }
 else if (vn=="default") { clrmode=1 }
 else if (vn=="1_color") { clrmode=1 }
 else if (vn=="2_color") {
   clrmode=2;
   if (k>1 && ChkColor(clm[2])) color2=clm[2]; else color2="FGcolor" }
 else if (vn=="3_color" && PLOT_FT[grp,":","group_shape"]=="vector" ) {
   clrmode=3;
   if (color1=="BGcolor") color3="FGcolor";
   else if (color1=="FGcolor") color3="BGcolor";
   if (k>1 && ChkColor(clm[2])) color2=clm[2];
   else if (color1=="BGcolor" || color1=="FGcolor") color2="grey";
        else color2="BGcolor";
   if (k>2 && ChkColor(clm[3])) color3=clm[3];
   }
 else if (vn=="rainbow") { clrmode=4 }
 else if (vn=="frame-remainder") { clrmode=5 }
 if (color2!="") color2=" "color2;
 if (color3!="") color3=" "color3;
 tmp=color1""color2""color3" "clrmode; return tmp } # End of Set_group_Clr
function Set_group_Shape(grp,src,    shp,ln,pos,tmp,vn,cl) {
 split(Set_group_Clr(grp,src),cl," ");
 vn=PLOT_FT[grp,":","group_shape"]
 if (vn in shpnm) shp=shpnm[vn];
 else shp=shpnm["none"];
 tmp=cl[1]" "shp; return tmp } # End of Set_group_Shape
function Set_Line(nm,ext,    vn,cl,ln,c,tmp) {
 if (ext=="gp_") {
   cl=PLOT_FT[nm,":","group_line_color"];
   vn=PLOT_FT[nm,":","group_line"];
   if (vn in lnnm) ln=lnnm[vn];
   else ln=lnnm["none"];
   }
 else {
   cl=PLOT_FT[nm,":","source_line_color"];
   vn=PLOT_FT[nm,":","source_line"];
   if (vn~/none|default|dotted|(dotted_)?line/) ln=lnnm[vn];
   else ln=lnnm["none"];
   }
 if (ChkColor(cl)) c=cl;
 else {
   if (cl=="default" || cl=="FGcolor") c="FGcolor";
   else c="BGcolor" }
 tmp=c" "ext""ln; return tmp } # End of Set_Line
function VertPos(pos,    tt) {
 tt=lcase(pos);
 if (tt=="center" || tt=="default") return 0;
 else if (tt=="baseline" || tt=="bottom") return 1;
 else if (tt=="reverse" || tt=="top") return -1;
 return 0 } # End of VertPos
#
########################################
function ChkInput() { # some changes will be made on input line if some defaults were present.
 flg_grp=1
 f=split($0,ln,/ \#/);$0="";
 $0=ln[1];for (s=1;s<=f;s++) { delete ln[s] };
 if (!($frame in Frames)) { 
   printf ">>>WARNING<<< Unknown frame %s (replaced by \".\") in : %s\n",$frame,$0 | "cat 1>&2";
   $frame="." }
 if (!($strand in strands)) {
   printf ">>>WARNING<<< Unknown strand %s (replaced by \".\") in : %s\n",$strand,$0 | "cat 1>&2";
   $strand="." }
 if (($0~/^[^\# ]+[ \t]+[^ ]+[ \t]+[^ ]+[ \t]+[+-]?[0-9]+[ \t]+[+-]?[0-9]+[ \t]+[+-]?[0-9]*[.]?[0-9]*[ \t]+[+-.][ \t]+[.012][ \t]*.*/) && $start<=$end && NF>=8) { 
   if ($vector=="Vector") sp_feat=1; # $group=$source; $source=$seqname$feature; $strand="." }
   else sp_feat=0;
   if (NF==8 || $group==".") {
     $group="#" NR "#" $seqname $source $strand "#";    # empty group defined as default (none==".")
     # CP_PLOT_FT[$group]=$source   # source from which lines are defined.
     label_group[$group]="";
     flg_grp=0;
     }
   else {
     lbgp_tmp=$group;
     $group=$seqname $source $strand $group;
     label_group[$group]=lbgp_tmp }
   $feature=lcase($feature);
   # getting source order from file...
   if (($strand=="+" || $strand=="-") && !($source in sources)) {
     order["strand",ordcnt]=$source; ordcnt++ } # order for sources input.
   else if ($strand=="." && !($source in sources)) {
     order["none",nordcnt]=$source; nordcnt++ };
   return 1;
   } # if gff-line OK
 else {
   if ($0~/^(\#)+.*/ || NF==0) printf ">>>Comment Line: %s\n", $0 | "cat 1>&2";
   else {
     if (NF<8) printf ">>>WARNING<<< Non-standard gff-formatted input line: %s\n\t\tThere are %s fields left: Standard gff lines need a minimum of 8 fields.\n", 8-NF,$0 | "cat 1>&2";
     else { 
       if ($start>$end) printf ">>>WARNING<<< Non-standard gff-formatted input line: %s\n\t\t START(%s) must be lower than END(%s)\n", $0,$start,$end | "cat 1>&2";
       else printf ">>>WARNING<<< GARBAGE\!: Non-standard gff-formatted input line: %s\n", $0 | "cat 1>&2";
       } # else if NF>8
     } # if comment
   return 0 } # else gff-line WRONG
 } # End function ChkInput
#
function ReadElements() { # read gff element within source, strand, and group 
  if (!($source in sources)) {
    sc_score["MIN",$source]=0; # $score;
    sc_score["MAX",$source]=$score;
    }
  sources[$source]++;                       # field 2 (source) counter
  tmp=$source SUBSEP $strand SUBSEP $group;
  if (!(tmp in N)) {
    G[$source,$strand]++;
    gp[$source,$strand,G[$source,$strand],gpname]=$group;
    gp[$source,$strand,G[$source,$strand],gplabel]=label_group[$group];
    gp[$source,$strand,G[$source,$strand],gpstart]=$start;
    gp[$source,$strand,G[$source,$strand],gpend]=$end;
    gp[$source,$strand,G[$source,$strand],is_grouped]=flg_grp;
    gp_cnt[$group]=G[$source,$strand]
    if (Var["print_report"]) printf "********* Creating Group DataSet : {%s} %s %s %s ( %s %s ) : is_grouped? %s\n",G[$source,$strand],$source,$strand,$group,gp[$source,$strand,G[$source,$strand],gpstart],gp[$source,$strand,G[$source,$strand],gpend],TxtBool(gp[$source,$strand,G[$source,$strand],is_grouped]) | "cat 1>&2"
    } # if N
  N[$source,$strand,$group]++;
  GP_ary[$group]++;                         # field 9 (group) counter
  FT_ary[$feature]++ ;                       # field 3 (gff-feature) counter
   element[$source,$strand,$group,N[$source,$strand,$group],feature] = $feature; 
   element[$source,$strand,$group,N[$source,$strand,$group],start]   = $start;
   element[$source,$strand,$group,N[$source,$strand,$group],end]     = $end;
   element[$source,$strand,$group,N[$source,$strand,$group],frame]   = $frame;  
   element[$source,$strand,$group,N[$source,$strand,$group],score]   = $score;  
   # element[$source,$strand,$group,N[$source,$strand,$group],group] = $group; 
   element[$source,$strand,$group,N[$source,$strand,$group],vector]  = sp_feat;
   if (sp_feat) {
     element[$source,$strand,$group,N[$source,$strand,$group],v_step] = "NONE"; # if none then paired data.
     split($0,vs,"Vector");
     k=split(vs[2],vv,/( )?;( )*/);
     for (ll=1;ll<k;ll++) {
       if (vv[ll]~/^Step /) {
         stp=lcase(substr(vv[ll],6));
         if (stp~/none|paired|function/) stp="NONE";
         element[$source,$strand,$group,N[$source,$strand,$group],v_step]  = stp;
         }
       else if (vv[ll]~/^MinVal /)
         element[$source,$strand,$group,N[$source,$strand,$group],v_scmin] = substr(vv[ll],8);
       else if (vv[ll]~/^MaxVal /)
         element[$source,$strand,$group,N[$source,$strand,$group],v_scmax] = substr(vv[ll],8);
       else if (vv[ll]~/^Scores /)
         element[$source,$strand,$group,N[$source,$strand,$group],v_DATA]  = substr(vv[ll],8);
       } # for
     } # if sp_feat
  if (FIRST_POS>$start) FIRST_POS=$start;
  if (LAST_POS<$end) LAST_POS=$end;
  # start-end for each group-sc-strand  
  gp[$source,$strand,gp_cnt[$group],gpstart] = min(gp[$source,$strand,gp_cnt[$group],gpstart],$start);
  gp[$source,$strand,gp_cnt[$group],gpend]   = max(gp[$source,$strand,gp_cnt[$group],gpend],$end);
  if (Var["print_report"]) printf "*** Checking group boundaries : {%s} %s %s %s %s %s\n",gp_cnt[$group],$source,$strand,$group,gp[$source,$strand,gp_cnt[$group],gpstart],gp[$source,$strand,gp_cnt[$group],gpend] | "cat 1>&2"
  # getting score - boundaries 
  sc_score["MIN",$source]=min($score,sc_score["MIN",$source]);
  sc_score["MAX",$source]=max($score,sc_score["MAX",$source]);
  # place gff element in sort array by acceptor position
  NS=N[$source,$strand,$group]-1;
  while ($start < element[$source,$strand,$group,S[$source,$strand,$group,NS],start]) {
    S[$source,$strand,$group,NS+1]=S[$source,$strand,$group,NS]; NS-- } # while
  S[$source,$strand,$group,NS+1]=N[$source,$strand,$group]
 } # End of ReadElements
function SortGroups() {
  if (Var["print_report"]) printf "\n%s\nReordering groups...\n%s\n",BigLINE,BigLINE | "cat 1>&2"
  for (sc in sources) {
    for (s in strands) {
      if (G[sc,s]>0) {
        for (t=1;t<=G[sc,s];t++) {
          gs=t-1
          gpstrt_=gp[sc,s,t,gpstart]
          if (Var["print_report"]) printf "------- %s : (%s) %s\n",t,gp[sc,s,t,gpname],gpstrt_  | "cat 1>&2"
          while (gpstrt_ < gp[sc,s,SG[sc,s,gs],gpstart]) {
           if (Var["print_report"]) printf "------- %s < %s\n",gp[sc,s,t,gpstart],gp[sc,s,SG[sc,s,gs],gpstart]  | "cat 1>&2"
           SG[sc,s,gs+1]=SG[sc,s,gs]; gs--
           } # while
          SG[sc,s,gs+1]=t;
         } # for t 
        for (t=1;t<=G[sc,s];t++) {
          if (Var["print_report"]) printf "*** Reordering groups : {%s} %s %s %s ( %s %s )\n",t,sc,s,gp[sc,s,SG[sc,s,t],gpname],gp[sc,s,SG[sc,s,t],gpstart],gp[sc,s,SG[sc,s,t],gpend] | "cat 1>&2"
         } # for t 
        } # if 
      } # for strands
    } # for sources
 } # End of SortGroups
#
function MakeGroupLines() {
  if (Var["print_report"]) printf "\n%s\nPlacing groups on lines...\n%s\n",BigLINE,BigLINE | "cat 1>&2"
  for (stp=1;stp<=3;stp++) { # for s in strand
    s=wstr[stp]
    for (sc in sources) { 
      if (G[sc,s]>0) {
         lastpos[sc,s,grouped_,1]=lastpos[sc,s,ungrouped_,1]=t_ori; # PORI;
         lines[sc,s,grouped_]=lines[sc,s,ungrouped_]=1;
          for (g=1;g<=SG[sc,s,G[sc,s]];g++) {
            gp_nm =gp[sc,s,g,gpname];
            gp_ori=gp[sc,s,g,gpstart];
            gp_end=gp[sc,s,g,gpend];
            gp_gpd= OnOff(PLOT_FT[sc,":","unfold_grouped_ungrouped"]) ? gp[sc,s,g,is_grouped] : 1; # 1 (grouped_) or 0 (ungrouped_)
            if (Var["print_report"]) printf ">>>>>>>%s %s %s (%s %s) G %s SG %s\n",sc,s,gp_nm,gp_ori,gp_end,G[sc,s],g | "cat 1>&2"
            LN=1;
            if ((gp_gpd==1 && OnOff(PLOT_FT[sc,":","unfold_grouped_line"])) || (gp_gpd==0 && OnOff(PLOT_FT[sc,":","unfold_ungrouped_line"]))) { # || OnOff(PLOT_FT[sc,":","unfold_mixed_grouped_ungrouped"])) {
             if (Var["print_report"]) printf "A........%s : %s (%s) G %s SG %s %s %s %s \n",LN,lastpos[sc,s,gp_gpd,LN],gp_ori,G[sc,s],g,sc,s,gp_nm | "cat 1>&2"
             while (lastpos[sc,s,gp_gpd,LN] >= gp_ori) {
              LN++;
              ttt=sc SUBSEP s SUBSEP gp_gpd SUBSEP LN;
              if (!(ttt in lastpos)) lastpos[sc,s,gp_gpd,LN]=t_ori; # PORI;
              if (Var["print_report"]) printf ".........%s : %s : %s (%s)\n",LN,ttt,lastpos[sc,s,gp_gpd,LN],gp_ori | "cat 1>&2"
              } # while lastpos
             lastpos[sc,s,gp_gpd,LN]=gp_end;
             if (Var["print_report"]) printf "B........%s : %s (%s %s) G %s SG %s\n",LN,lastpos[sc,s,gp_gpd,LN],gp_ori,gp_end,G[sc,s],g | "cat 1>&2"
             } # if checking
            lines[sc,s,gp_gpd]=max(lines[sc,s,gp_gpd],LN);
            LE[sc,s,gp_gpd,LN]++;
            LNelem[sc,s,gp_gpd,LN,LE[sc,s,gp_gpd,LN]]=g;
            } # for g(SG)
        } # if G>0
      } # for sources
    } # for strands
 } # End of MakeGroupLines
#
function showelemGS(s,p,g,q,  string){
  string=" : ";
  string=string" "element[s,p,g,q,feature]" ";
  string=string" "element[s,p,g,q,start]" ";
  string=string" "element[s,p,g,q,end]" ";
  string=string" "element[s,p,g,q,frame]" ";
  string=string" "element[s,p,g,q,group];
  return string } # End of showelemS
function PrtSorted() {
  if (Var["print_report"]) {
    printf "\n%s\nGroups were sorted...\n%s\n",BigLINE,BigLINE | "cat 1>&2"
    for (sc in sources) {
      for (s in strands) {
        for (ppd=grouped_;ppd>=ungrouped_;ppd--) {
          if (s=="-") pd=1-ppd; else pd=ppd
          for (h=1;h<=lines[sc,s,pd];h++) {
            if (LE[sc,s,pd,h]>0) {
             printf "%s %s : is_grouped %s : Line %s \>\n",sc,s,TxtBool(pd),h | "cat 1>&2"
             for (t=1;t<=LE[sc,s,pd,h];t++) {
               elm_=LNelem[sc,s,pd,h,t];
               printf "\tgpd_%s:line_%s:le_%s:LNel_%s (%s:%s-%s) Label(%s)\n",TxtBool(pd),h,t,elm_,gp[sc,s,elm_,gpname],gp[sc,s,elm_,gpstart],gp[sc,s,elm_,gpend],gp[sc,s,elm_,gplabel] | "cat 1>&2"
               } # for t
             } # if LE
            } # for h
          } # for pd
        } # for strands
      } # for sources
    close("cat 1>&2")
    printf "\n%s\ngff elements were sorted...\n%s\n",BigLINE,BigLINE | "cat 1>&2"
      for (sc in sources) {
        for (s in strands) {
          printf "\nSOURCE: %s\nSTRAND: %s\n",sc,s | "cat 1>&2"
          if (G[sc,s]>0) {
            for (g=1;g<=G[sc,s];g++) {
              gs=SG[sc,s,g]
              gnm=gp[sc,s,gs,gpname];
              printf "     GROUP : %s (%s:%s)\n",gnm,gp[sc,s,gs,gpstart],gp[sc,s,gs,gpend] | "cat 1>&2"
              if (N[sc,s,gnm]>0) {
                for (i=1;i<=N[sc,s,gnm];i++)
                  printf "%10s %s\n", S[sc,s,gnm,i],showelemGS(sc,s,gnm,S[sc,s,gnm,i]) | "cat 1>&2"
                } # if N
              } # for G
            } # if G
          } # for s
        } # for sc
   } # if print_report
 } # End of PrtSorted
#
function SET_VARS() {
  # Variable definition hierarchy:
  # Program Defaults < Default Custom File < Custom File < Command Line.
  CreateProps(0)
  ECF=0
  if (Var["exist_default_customfile"]) { # Modifying Defaults with default custom file
    if (Var["print_report"]) printf "\n%s\nReading Default Custom File...\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    RCFile(Var["customfile_name_default"])
    ECF=1
    }
  if (Default["load_customfile"]) { # Modifying Defaults with custom file
    if (Var["print_report"]) printf "\n%s\nReading Custom File...........\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    RCFile(Default["customfile_name"])
    ECF=1
    }
  if (ECF==0) { # Modifying Defaults with Vars if no exist custom file
    if (Var["print_report"]) printf "\n%s\nModified options...........\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    for (lytdef in Default) {
      dft=Default[lytdef]
      if (dft!=Var[lytdef] && Var[lytdef]!="") Default[lytdef]=Var[lytdef]
      if (Var["print_report"]) printf "%s : Default Value=%s Custom File=%s Command-Line=%s : Using=%s\n", lytdef,dft,PLOT_LY[lytdef],Var[lytdef],Default[lytdef] | "sort | cat 1>&2"
      } # for lytdef
    close("sort | cat 1>&2")
    }   # if ECF==0
  # First and last position, zoom option checking...
  t_ori=Nuc_round(FIRST_POS,0) # floor
  t_end=Nuc_round(LAST_POS,1)  # ceiling
  if (Default["zoom"]=="*..*") { PORI=t_ori; PEND=t_end }
  else { split(Default["zoom"],poszm,/\.\./);
    if (poszm[1]=="*") PORI=t_ori; else PORI=poszm[1];
    if (poszm[2]=="*") PEND=t_end; else PEND=poszm[2];
    }
  if (PORI!=0) PDIF=PEND-PORI+1
  else PDIF=PEND
 } # End of function SET_VARS
#
function SET_PAGE_VARS() {  # Calculating Page Number, Blocks and NucxLine
  P=Default["page_number"]
  B=Default["blocks_x_page"]
  if (Default["nucleotides_x_line"]==0) {
    if (B>1 || P>1) NOFFSET=Nuc_round((PDIF/(B*P)),1)
    else NOFFSET=PDIF
    }
  else NOFFSET=Default["nucleotides_x_line"]
  if (NOFFSET>PDIF) NOFFSET=PDIF # necessary if it is defined a Zoom.
  B1= PDIF%NOFFSET!=0 ? ((PDIF-(PDIF%NOFFSET))/NOFFSET)+1 : ((PDIF-(PDIF%NOFFSET))/NOFFSET)
  P = B1%B!=0 ? ((B1-(B1%B))/B)+1 : ((B1-(B1%B))/B)
  if (Default["show_blocks_top-bottom"]) { BOFFSET=NOFFSET; POFFSET=B*NOFFSET }
  else { BOFFSET=P*NOFFSET; POFFSET=NOFFSET }
  if (Var["print_report"]) printf "\n%s\nPostScript Page Definitions...\n%s\n",BigLINE,BigLINE | "cat 1>&2"  
  if (Var["print_report"]) printf "\npage_number %s\nblocks_x_page %s\nnucleotides_x_line %s\nshow_blocks_top-bottom %s\n",Default["page_number"],Default["blocks_x_page"],Default["nucleotides_x_line"],Default["show_blocks_top-bottom"] | "cat 1>&2"  
  if (Var["print_report"]) printf "\nPORI %s\nPEND %s\nP %s\nB %s\nNOFFSET %s\nBOFFSET %s\n\n",PORI,PEND,P,B,NOFFSET,BOFFSET | "cat 1>&2"  
  # Calculating Block scale factor.
  StrSize=0; NStSize=0; # for strands...
  aS=calcpt(Default["default_track_width"]);
  bS=calcpt(Default["default_track_spacing_width"]);
  for (ws in order) {
    split(ws,wsb,SUBSEP)
    if (wsb[1]=="strand") {
      if (!OnOff(PLOT_FT[order[ws],":","unfold_grouped_ungrouped"]) && !OnOff(PLOT_FT[order[ws],":","unfold_grouped_line"]) && !OnOff(PLOT_FT[order[ws],":","unfold_ungrouped_line"]))
        cl=1
      else {
        if (DoUnFoldMixed(order[ws]) && !OnOff(PLOT_FT[order[ws],":","unfold_grouped_ungrouped"]))
          cl=max(lines[order[ws],"+",grouped_],lines[order[ws],"-",grouped_])
        else
          cl=max(lines[order[ws],"+",grouped_],lines[order[ws],"-",grouped_])+max(lines[order[ws],"+",ungrouped_],lines[order[ws],"-",ungrouped_])
        }
      StrSize=StrSize+(cl*((aS*PLOT_FT[order[ws],":","track_scale"])+(bS*PLOT_FT[order[ws],":","track_spacing_scale"])))
      }
    else {
     if (wsb[1]=="none") {
      if (!OnOff(PLOT_FT[order[ws],":","unfold_grouped_ungrouped"]) && !OnOff(PLOT_FT[order[ws],":","unfold_grouped_line"]) && !OnOff(PLOT_FT[order[ws],":","unfold_ungrouped_line"]))
        cl=1
      else { 
        if (DoUnFoldMixed(order[ws]) && !OnOff(PLOT_FT[order[ws],":","unfold_grouped_ungrouped"]))
          cl=lines[order[ws],".",grouped_]
        else
          cl=lines[order[ws],".",grouped_]+lines[order[ws],".",ungrouped_]
        }
      NStSize=NStSize+cl*((aS*PLOT_FT[order[ws],":","track_scale"])+(bS*PLOT_FT[order[ws],":","track_spacing_scale"]))
      } # if wsb==none
     } # else if wsb 
    } # for order
  if (OnOff(Default["strand_show_forward"])) StrSizeFwd=StrSize; else StrSizeFwd=0
  if (OnOff(Default["strand_show_reverse"])) StrSizeRvs=StrSize; else StrSizeRvs=0
  if (!OnOff(Default["strand_show_independent"])) NStSize=0;
  cpsc=calcpt(Default["default_scale_width"])
  SclSize=0 # for scales...
  if (OnOff(Default["show_outer_scale"])) SclSize=SclSize+4*cpsc;
  if (OnOff(Default["show_inner_scale"])) {
   if (StrSizeFwd>0 && (NStSize>0 || StrSizeRvs>0)) SclSize=SclSize+cpsc
   if (NStSize>0 && StrSizeRvs>0) SclSize=SclSize+cpsc
  }
  BSize=StrSizeFwd+StrSizeRvs+NStSize+SclSize # (points)
  # Major Minor Tickmarks ratio
  if (Default["major_tickmarks_nucleotides"]==-1) {
    Default["major_tickmarks_nucleotides"]=Nuc_round((PDIF/Default["major_tickmarks_num"]),0) }
  if (Default["minor_tickmarks_nucleotides"]==-1) {
    Default["minor_tickmarks_nucleotides"]=Default["major_tickmarks_nucleotides"]/Default["minor_tickmarks_num"] }
 } # End of function SET_PAGE_VARS
#
function ScoreLimits(    no_score) {
  if (PLOT_FT[sc,":","range"]=="none") no_score=1;
  else {
    no_score=0;
    if (PLOT_FT[sc,":","range"]=="default") {
      lower_sc=sc_score["MIN",sc];
      upper_sc=sc_score["MAX",sc] }
    else {
      split(PLOT_FT[sc,":","range"],scmt,/\.\./);
      if (scmt[1]>scmt[2]) { tt=scmt[1]; scmt[1]=scmt[2]; scmt[2]=tt }
      lower_sc=scmt[1];
      upper_sc=scmt[2] }
    }
 return no_score } # End of function ScoreLimits
function GetScore(sco,lwr,upr,   tmp) {
 tmp=(((MAXSCORE-MINSCORE)/(upr-lwr))*sco)+MINSCORE;
 return tmp } # End of function GetScore
function PlotElement() {
  start_=element[sc,s,ng_,sel,start];
  end_=element[sc,s,ng_,sel,end];
  if (Var["print_report"]) printf "Element %s : %s : %s - %s\n",el,sel,start_,end_ | "cat 1>&2";
  if (Var["print_report"]) printf "Start %s - BORI %s : end %s - BEND %s\n",start_,BORI,end_,BEND | "cat 1>&2";
  if (ChkLimits(start_,BORI,end_,BEND)) {
    elem_sc=element[sc,s,ng_,sel,score];
    if (sco_lm) score_=1; else score_=GetScore(elem_sc,lower_sc,upper_sc);
    # for gene mode. try to recompute relative frame and remainder
    if (Var["print_report"]) printf "Element %s : %s : %s - %s : %s %s %s/%s \n",el,sel,start_,end_,feature_, score_,frame_,remainder_ | "cat 1>&2";
    if (element[sc,s,ng_,sel,frame]!=".") {
      frame_=element[sc,s,ng_,sel,frame];
      remainder_=(3-(end_-(start_+frame_)+1)%3)%3 }
    else { frame_="(.)"; remainder_="(.)" }
    if (Var["print_report"]) printf "Element* %s : %s : %s - %s : %s %s %s/%s \n",el,sel,start_,end_,feature_, score_,frame_,remainder_ | "cat 1>&2";
    if (Var["print_report"])
      printf "%s %s %s : %s %d %d %s %s %4.2f (%s) (%s) %s (%s) p\n", sc,s,i,PLOT_FT[feature_,":","layer"], start_, end_, frame_ , remainder_, score_, Set_feat_Clr(feature_,ng_,sc,0), Set_feat_Shape(feature_,ng_,sc), VertPos(PLOT_FT[feature_,":","vert_align"]), Plot_Lbl(feature_) | "cat 1>&2";
    printf "%s %d %d %s %s %4.2f (%s) (%s) %s (%s) p\n", PLOT_FT[feature_,":","layer"], start_, end_, frame_ , remainder_, score_, Set_feat_Clr(feature_,ng_,sc,0), Set_feat_Shape(feature_,ng_,sc), VertPos(PLOT_FT[feature_,":","vert_align"]), Plot_Lbl(feature_) | "sort +0nr -1 +1n -2 +2nr -3 +5nr -6";
    } # if element checklimits
 } # End of function PlotElement
function PlotVector() {
  start_=element[sc,s,ng_,sel,start];
  end_=element[sc,s,ng_,sel,end];
  if (Var["print_report"]) printf "Vector %s : %s : %s - %s\n",el,sel,start_,end_ | "cat 1>&2";
  if (ChkLimits(start_,BORI,end_,BEND)) {
    step_=element[sc,s,ng_,sel,v_step];
    if (PLOT_FT[sc,":","range"]=="default" || sco_lm) {
      scmin_=element[sc,s,ng_,sel,v_scmin];
      scmax_=element[sc,s,ng_,sel,v_scmax] }
    else { scmin_=lower_sc; scmax_=upper_sc }
    WK=split(element[sc,s,ng_,sel,v_DATA],V_ary," ");
    lnct=0;
    if (step_!="NONE") {
     printf "%s %s %s vt\n", start_, end_, Set_feat_Clr(feature_,ng_,sc,1), step_;    
     pos_=start_;
      for (w=1;w<=WK;w++) {
        if (pos_>BORI && pos_<BEND) { # pos_ is always taken as mid_position.
          lnct++
          if (sco_lm) score_=1; else score_=GetScore(V_ary[w],scmin_,scmax_);
          printf "%5.3f ", score_;
          } # if frame is on page
        if (lnct=10 || w==WK) { printf "\n"; lnct=0 }
        pos_=pos_+step_
        } # for fixed steps...
      } # if step_ for fixed values.
    else {
      printf "%s %s vp\n", start_, end_, Set_feat_Clr(feature_,ng_,sc,1);    
      for (w=1;w<=(WK-1);w+=2) {
        pos_=V_ary[w];
        if (pos_>BORI && pos_<BEND) { # pos_ is always taken as mid_position.
          lnct++;
          if (sco_lm) score_=1; else score_=GetScore(V_ary[w+1],scmin_,scmax_);
          printf "(%5.3f %s) ", score_, pos_;
          } # if frame is on page
        if (lnct=10 || w==WK-1) { printf "\n"; lnct=0 }
        }  # for position score pairs...
      } # if step_ for position score pairs.
    printf "v_end\n";    
    } # if element checklimits
 } # End of function PlotElement
function PRINTGROUPS() { # print groups PlotSeqComp-like.
  laststrand="+"; notyet=1;
  for (stp=1;stp<=3;stp++) { # for s in strand
    s=wstr[stp];
   if ((s=="+" && OnOff(Default["strand_show_forward"])) || (s=="." && OnOff(Default["strand_show_independent"])) || (s=="-" && OnOff(Default["strand_show_reverse"]))) {
    if (s=="+" || s=="-") lastcnt=ordcnt;
    else lastcnt=nordcnt; 
    printf "GP------ Source: --- Strand: %s Counter: %s\n", s, lastcnt | "cat 1>&2"; 
    printf "%% ------------------ Strand(%s) Begin\n",s;
    for (srcord=0;srcord<lastcnt;srcord++) { # for sc in sources
      if (s=="-") { ngcnt=lastcnt-(srcord+1); sc=order["strand",ngcnt] }
      else {
        if (s=="+") sc=order["strand",srcord];
        else sc=order["none",srcord];      # (s==".")
        }
      if (!OnOff(PLOT_FT[sc,":","unfold_grouped_ungrouped"])) ungp=grouped_;
      else ungp=ungrouped_; 
      for (pd=grouped_;pd>=ungp;pd--) {
       if (s=="-" && OnOff(PLOT_FT[sc,":","unfold_grouped_ungrouped"])) i=!pd; else i=pd;
        if (s!=".") m_lines=max(lines[sc,"+",i],lines[sc,"-",i]);
        else m_lines=lines[sc,".",i];
        for (pl=1;pl<=m_lines;pl++) {
          if (s=="-") l=lines[sc,"-",i]-pl+1; else l=pl;
          printf "GP------ Source: %10s Strand: %s Counter: %s\n", sc, s, srcord | "cat 1>&2"; 
          if (DoUnFoldMixed(sc) || (!OnOff(PLOT_FT[sc,":","unfold_grouped_ungrouped"]) && !OnOff(PLOT_FT[sc,":","unfold_grouped_line"]) && !OnOff(PLOT_FT[sc,":","unfold_ungrouped_line"]))) fl_gp="M";
          else { if (i) fl_gp="G"; else fl_gp="U" }
          sco_lm=ScoreLimits();
          if (PLOT_FT[sc,":","source_style"]=="boxed") shscbx="true"; 
          else shscbx="false";
          printf "%s %s %s %s (%s) (%s) (%s) source\n", VertPos(PLOT_FT[sc,":","vert_align"]), PLOT_FT[sc,":","track_scale"], PLOT_FT[sc,":","track_spacing_scale"],shscbx,s,Set_Line(sc,"sc_"), Plot_Lbl(sc,sc,s,fl_gp);  # (lines[sc,s,grouped_]+lines[sc,s,ungrouped_])
          for (gl=1;gl<=LE[sc,s,i,l];gl++) {
            g=LNelem[sc,s,i,l,gl];
            ng_=gp[sc,s,g,gpname];
           if (OnOff(PLOT_FT[ng_,":","show_group"])) {
            sg_=gp[sc,s,g,gpstart];
            eg_=gp[sc,s,g,gpend];
            if (ChkLimits(sg_,BORI,eg_,BEND)) {
              # plot group in file
              if (Var["print_report"])
                printf "GROUP : %-15s : line_%s order_%s %10d %10d (%s)\n", ng_, l, gl, sg_, eg_, N[sc,s,ng_] | "cat 1>&2";
              printf "%s %s (%s) (%s) %s (%s) (%s) gp\n", sg_, eg_, Set_group_Clr(ng_,sc), Set_group_Shape(ng_,sc), VertPos(PLOT_FT[ng_,":","vert_align"]), Set_Line(ng_,"gp_"), Plot_Lbl(ng_,sc,s);
              for (el=1;el<=N[sc,s,ng_];el++) {
                sel=S[sc,s,ng_,el];
                feature_=element[sc,s,ng_,sel,feature];
                if (OnOff(PLOT_FT[feature_,":","show_feature"])) {
                  if (!element[sc,s,ng_,sel,vector]) {
                    PlotElement() } # if not vector
                  else { # if vector
                    PlotVector() } # if vector
                  } # if show feature
                } # for elements in group             
              close("sort +0nr -1 +1n -2 +2nr -3 +5nr -6");
              printf "g_end\n";
              } # if group checklimits
             } # if show group
            } # for LE
          printf "s_end\n";
          }   # for lines
        } # for grpd
      }   # for scord(source_ordering)
     }    # if strand_show
     printf "%% ------------------ Strand(%s) End\n",s;
     if (laststrand=="+" && StrSizeFwd>0 && notyet ) { printf "ChangeStrand\n"; notyet=0 }
     if (laststrand=="." && NStSize>0) printf "ChangeStrand\n";
     laststrand=s;
    }     # for strands(stp)
 } # End of function PRINTGROUPS
#
function CreateProps(flag,    STRING,prop,dffeat,feat,gpfeat,sofeat) {
  ############ Create Properties Index for Objects ############ 
  STRING="#\n# L ######PAGE LAYOUT \& PROGRAM OPTIONS######\n#\n";
  if (flag==1) { 
    printf STRING | "cat 1>&2";
    for (dffeat in Default)
      printf "%s=%s\n", dffeat, Default[dffeat] | "sort 1>&2";
    close("sort 1>&2");
    }
  else if (flag==2) { 
    printf STRING > Default["customfile_name_default"];
    for (dffeat in Default)
      printf "%s=%s\n", dffeat, Default[dffeat] > Default["customfile_name_default"];
    }
  STRING="#\n# F ############GENOMIC FEATURES############\n#\n";
  if (flag==1) {
    printf STRING | "cat 1>&2";
    }
  else if (flag==2) {
    # close(Var["customfile_name_default"])
    printf STRING > Default["customfile_name_default"];
    }
  for (feat in FT_ary) {
    for (prop in FT_PROP) {
      if (flag==0) PLOT_FT[feat,":",prop]=FT_PROP[prop];
      else {
        if (PLOT_FT[feat,":",prop]=="") PLOT_FT[feat,":",prop]=FT_PROP[prop];
        if (flag==1)
	      printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] | "sort 1>&2";
        else if (flag==2)
	      printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] > Default["customfile_name_default"];
        }
      }
    if (flag==1) {
      close("sort 1>&2");
      printf "# %s:%s=%s\n#\n", feat, "feature_counter", FT_ary[feat] | "cat 1>&2";
      }
    }
  STRING="#\n# G ############GROUP FEATURES############\n#\n";
  if (flag==1) { 
    printf STRING | "cat 1>&2";
    }
  else if (flag==2) {
    # close(Var["customfile_name_default"])
    printf STRING > Default["customfile_name_default"];
    }
  for (gpfeat in GP_ary) {
    for (prop in GR_PROP) {
      if (flag==0) PLOT_FT[gpfeat,":",prop]=GR_PROP[prop];
      else {
        if (PLOT_FT[gpfeat,":",prop]=="") PLOT_FT[gpfeat,":",prop]=GR_PROP[prop];
        if (flag==1)
	      printf "%s:%s=%s\n", gpfeat, prop, PLOT_FT[gpfeat,":",prop] | "sort 1>&2";
        else if (flag==2)
	      printf "%s:%s=%s\n", gpfeat, prop, PLOT_FT[gpfeat,":",prop] > Default["customfile_name_default"];
        }
      }
    if (flag==1) {
      close("sort 1>&2");
      printf "# %s:%s=%s\n#\n", gpfeat, "group_elements_counter", GP_ary[gpfeat] | "cat 1>&2";
      }
    }
  STRING="#\n# S ############SOURCE FEATURES############\n#\n";
  if (flag==1) { 
    printf STRING | "cat 1>&2";
    }
  else if (flag==2) {
    # close(Var["customfile_name_default"])
    printf STRING > Default["customfile_name_default"];
    }
  for (sofeat in sources) {
    for (prop in SO_PROP) {
      if (flag==0) PLOT_FT[sofeat,":",prop]=SO_PROP[prop];
      else {
        if (PLOT_FT[sofeat,":",prop]=="") PLOT_FT[sofeat,":",prop]=SO_PROP[prop];
        if (flag==1)
	      printf "%s:%s=%s\n", sofeat, prop, PLOT_FT[sofeat,":",prop] | "sort 1>&2";
        else if (flag==2)
	      printf "%s:%s=%s\n", sofeat, prop, PLOT_FT[sofeat,":",prop] > Default["customfile_name_default"];
        }
      }
    if (flag==1) {
      close("sort 1>&2");
      printf "# %s:%s=%s\n#\n", sofeat, "source_groups_counter", sources[sofeat] | "cat 1>&2";
      }
    }
  if (flag==1) { close("cat 1>&2") }
  else if (flag==2) close(Default["customfile_name_default"])
 } # End of CreateProps
#
function RCFile(file,    STRING,nothere,first,gffirst,second,ft_type,feat,lytdef,dft) { ############ Read CustomFile
  STRING="Match between: %s & %s : %s=%s\n"
  while ((getline < file) > 0 ) {
   if ( $1!~/^(\#)+/ && NF>0 ) { 
    nothere=0;global=0
    split($0,defs,"=")
    split(defs[1],nwfeat,":")
    first=nwfeat[1]
    if (first=="*") { first=".*"; global=1 }
    gffirst=lcase(first)
    second=nwfeat[2]
    if (ft_type=="F") {
      for (feat in FT_ary) {
        if (match(feat,gffirst)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) {
            PLOT_FT[feat,":",second]=defs[2]
            nothere=1
            }
          if (Var["print_report"])
            printf "Feature "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      if (nothere==0 && !global) {
        FT_ary[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["print_report"])
          printf "No Match found - New Feature: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="G") {
      for (feat in GP_ary) { 
        if (match(feat,first)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) {
            PLOT_FT[feat,":",second]=defs[2]
            nothere=1
            }
          if (Var["print_report"])
            printf "Group "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      if (nothere==0 && !global) {
        GP_ary[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["print_report"])
          printf "No Match found - New Feature: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="S") {
      for (feat in sources) {
        if (match(feat,first)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) { 
            PLOT_FT[feat,":",second]=defs[2]
	        nothere=1
            }
          if (Var["print_report"])
            printf "Source "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      if (nothere==0 && !global) {
        sources[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["print_report"])
          printf "No Match found - New Feature: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="L") {
      if (defs[1] in Default) {
        PLOT_LY[defs[1]]=defs[2]
        if (Var["print_report"])
            printf "Layout "STRING,defs[1],first,defs[1],defs[2] | "cat 1>&2"
        }
      }
   }# if not empty or comment line 
   else 
     if ( $1~/^(\#)$/ && $2~/^[LFGS]$/) ft_type=$2
  } # while getline
  close(file) 
  # Modifying Vars
  if (Var["print_report"]) printf "\n%s\nCommand-Line Modified options...........\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
  for (lytdef in Default) {
    dft=Default[lytdef]
    if (dft==Var[lytdef] && PLOT_LY[lytdef]!="") Default[lytdef]=PLOT_LY[lytdef]
      else Default[lytdef]=Var[lytdef]
    if (Var["print_report"]) printf "%s : Default Value=%s Custom File=%s Command-Line=%s : Using=%s\n", lytdef,dft,PLOT_LY[lytdef],Var[lytdef],Default[lytdef] | "sort | cat 1>&2"
    }
    if (OnOff(PLOT_LY["load_customfile"])) Default["load_customfile"]=PLOT_LY["load_customfile"]
  close("sort | cat 1>&2")
 } # End of RCFile
#
function CREATECUSTOM() {
  if (Var["create_default_customfile"]) { 
    printf "\n%s\nCustom File:\n%s\n\n%s\n\n", BigLINE,BigLINE, Default["customfile_name_default"] | "cat 1>&2"
    if (Var["exist_default_customfile"]) {
      printf "Warning: I am going to rewrite your Default Custom File.\n" | "cat 1>&2"
      printf "         Moving last Default Custom File to %s.old\n",Default["customfile_name_default"] | "cat 1>&2"
      system("cp -v " Default["customfile_name_default"] " " Default["customfile_name_default"] ".old")
      }
    else {
      printf "Warning: Writing Default Custom File %s.\n",Default["customfile_name_default"] | "cat 1>&2"
      }
    CreateProps(2)
    }
  else {
    printf "\n%s%s\nWarning: Defaults were taken from program defaults,\n",BigLINE,BigLINE | "cat 1>&2"
    printf "         if you want to force program to write default file,\n" | "cat 1>&2"
    printf "         you must pass the command-line option -d to the program.\n" | "cat 1>&2"
    printf "         Default custom-file name: %s\n\n",Default["customfile_name_default"] | "cat 1>&2"
    printf "         ...See help for -d and -D <filename> options...\n" | "cat 1>&2"
    printf "%s%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    }
  # Object Properties Report...
  if (Var["print_report"]) {
    printf "\n%s\nObject Properties Defined....\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    CreateProps(1) }
 } # End of function CREATECUSTOM
#
function defPSvars(    tc,z,flgt,title,flgst,subtitle,shtt,shbt,shbx) {
 printf "%% BG \& FG colors\n";
 printf "/BGcolor { colordict begin %s end } def\n", Var["BACKGROUND_COLOR"];
 printf "/FGcolor { colordict begin %s end } def\n", Var["FOREGROUND_COLOR"];
 printf "/frmN { colordict begin %s end } def\n", Default["frame_unknown_color"];
 printf "/frm0 { colordict begin %s end } def\n", Default["frame0_color"];
 printf "/frm1 { colordict begin %s end } def\n", Default["frame1_color"];
 printf "/frm2 { colordict begin %s end } def\n", Default["frame2_color"];
 printf "%% page orientation flag\n";
 printf "/flglscape %s def\n", chkpo(Default["page_orientation"]);
 printf "%%%% page size in points used for plot % pgA4 == 595  842\n";
 printf "/Dpage { pagedict begin pg%s flglscape { exch } if end } bdf\n", chkps(Default["page_size"]);
 printf "%% margins (1 cm) (Up Down Left Right - margins are XY independent)\n";
 printf "/UpM %s def\n", chkun(Default["margin_upper"]);
 printf "/DnM %s def\n", chkun(Default["margin_bottom"]);
 printf "/LtM %s def\n", chkun(Default["margin_left"]);
 printf "/RtM %s def\n%%\n", chkun(Default["margin_right"]);
 printf "/TkMrkW %s def %% Defining tickmark-width.\n", chkun(Default["default_scale_width"]);
 printf "/BlckSp %s def %% Defining blocks-spacing\n%%\n", chkun(Default["default_block_spacing_width"]);
 printf "/SeqLen %s def\n", PDIF; 
 printf "/XNucOffSet %s def\n", PORI; 
 printf "/NPages %s def\n", P; 
 printf "/NBlck %s def\n", B; 
 printf "/MaxNuclPage %s def\n", NOFFSET;
 if (Default["block_style"]=="boxed") shbx="true"; 
 else shbx="false";
 printf "/FlgBkBx %s def\n", shbx;
 printf "/FlgOS %s def\n",TxtBool(OnOff(Default["show_outer_scale"]));
 printf "/FlgIS %s def\n",TxtBool(OnOff(Default["show_inner_scale"]));
 printf "/MaxTick %s def\n", Default["major_tickmarks_nucleotides"];
 printf "/MinTick %s def\n%%\n", Default["minor_tickmarks_nucleotides"];
 printf "/tracksize %s def\n", chkun(Default["default_track_width"]);
 printf "/spcrsize  %s def\n", chkun(Default["default_track_spacing_width"]);
 printf "/LnTot  %s def\n", BSize;     # size in points (size is relative here)
 printf "/LnFwd %s def\n", StrSizeFwd; # if they are 0 then not showed
 printf "/LnRvs %s def\n", StrSizeRvs;
 printf "/LnBth %s def\n", NStSize;
 printf "/LnTck %s def\n", calcpt(Default["default_scale_width"]);
 printf "/vectoffset 10 def\n%%\n";
 printf "/Flgspos %s def\n%%\n", TxtBool(OnOff(Default["show_positions"]));
 printf "/XLftLbl 4 cm  def\n";
 printf "/FLftLbl true  def\n";
 printf "/XRgtLbl 4 cm  def\n";
 printf "/FRgtLbl false  def\n%%\n";
 printf "/XOriTitl 1 cm def\n";
 printf "/YOriTitl 0 cm def\n";
 printf "/YSTitl 1 cm def\n";
 if (Default["header_style"]=="boxed") { shtt="true"; shbt="true" }
 else {
   if (Default["header_style"]=="default") { shtt="true"; shbt="false" }
   else { shtt="false"; shbt="false" }}
 printf "/FlgTitl %s def\n", shtt;
 printf "/headerdict 20 dict def headerdict begin\n";
 printf " /ShwTBx %s def\n", shbt;
 if (Default["title"]=="none") { flgt="false"; title="" }
 else { flgt="true";
   if (Default["title"]=="default") { z=split(Var["InputFNs"],tc,"/"); title=tc[z] }
   else title=Default["title"] }
 printf " /ShwTt %s def\n", flgt;
 printf " /Title (%s) def\n", checklbl(title);
 if (Default["subtitle"]=="none" || Default["subtitle"]=="default") { flgst="false"; subtitle="" }
 else { flgst="true"; subtitle=Default["subtitle"] }
 printf " /ShwST %s def\n", flgst;
 printf " /SubTitle (%s) def\n", checklbl(subtitle);
 printf " /ShwDate %s def\n", TxtBool(OnOff(Default["show_date"]));
 printf " /Sdate (%s) def\n", checklbl(date);
 printf " /ShwTime %s def\n", TxtBool(OnOff(Default["show_time"]));
 printf " /Stime (%s) def\n", checklbl(time);
 printf " /Shwp_num %s def\n", TxtBool(OnOff(Default["show_page_numbers"]));
 printf "end%%\n";
 printf "%%\n" } # End of defPSvars
#
function startPSpage(num,tot) {
 printf "%%%%Page: %s %s\n",num,num;
 printf "%%%%BeginPageSetup\n%%\n";
 printf "%% Saving current page settings\n";
 printf "/pgsave save def\n";
 printf "%% Setting BGcolor for sheet \n";
 printf "Dpage flglscape { exch } if 0 0 bbox S BGcolor scmyk fill R clip newpath\n";
 printf "%% setting coordinate axes for page orientation\n";
 printf "flglscape\n";
 printf " { 90 rotate 1 -1 F XORI YORI T }                  %% (0,0) - Ori for landscape pages\n";
 printf " { XORI Dpage exch pop YORI sub T 1 -1 F } ifelse  %% (0,0) - Ori for portrait pages\n";
 printf "%%\n%% /FGcolor scolor\n%%\n";
 printf "%% Printing Header\n";
 printf "headerdict begin\n";
 printf " /PageNumber (Page %s of %s) def\n",num,tot;
 printf " FlgTitl { Header } if\n";
 printf "end%%\n";
 printf "%%%%EndPageSetup\n";
 printf "%%\n" } # End of startPSpage
#
function endPSpage(p) {
 printf "%%\ngrestoreall\npgsave restore\nshowpage\n"
 printf "%%\n%% PageEND: %s %s\n%%\n",p,p } # End of endPSpage
function PSTrailer(pages,    bbm,bbx,bby) {
 split(Default["page_bbox"],bbm,",");
 bbx=bbm[2]; bby=bbm[3];
 #if (Default["page_orientation"]=="Landscape") {  }
 #else { bbx=bbm[3]; bby=bbm[2] }
 # PostScript end of page (Trailer)
 printf "%%%%Trailer\n%%\n";
 printf "%%%%Pages: %s\n", pages;
 printf "%%%%Orientation: %s\n", Default["page_orientation"];
 printf "%%%%BoundingBox: 0 0 %s %s\n%%%%EOF\n", bbx, bby;
 } # End of PSTrailer
' - $GFF_INPUT_FILES
#### Main GFF2APLOT GNU awk Program DONE.

#
##################### EOF #####################
exit 0
