#!/bin/sh
######################################################################
#                               gff2ps                               #
######################################################################
#
#     Converting GFF files to PostScript.
#
#     Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
#                                 Roderic GUIGO SERRA       
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
######################################################################
#
# Creation Date: 01.03.1999
# Last Update:
#         $Id: gff2ps,v 1.3 1999-04-26 19:31:52 jabril Exp $	
#
# Autor : Josep Francesc ABRIL FERRANDO
# e-mail: jabril@imim.es
#
#

##############################################################
#################### PROGRAM DEFINITIONS #####################

# 
# Defining Default Values...
#
Defaults () {
 # 
 # Constants: 
  PROGRAM="gff2ps"
  VERSION="v1.0"
  SHCREATION="01.03.1999"
  SHREVISION="24.04.1999"
  PSPROGRAM="PlotSeqComp.ps"
  PSVERSION="v2.4"
  PSCREATION="02.09.1998"
  PSREVISION="24.04.1999"
  AUTHOR="Josep Francesc ABRIL FERRANDO"
  EMAIL="jabril@imim.es"
  MAIL="%%                  Dept. Informatica Medica
%%          Institut Municipal d'Investigacio Medica
%%                   C./ Doctor Aiguader 80
%%                  08003 - BARCELONA (SPAIN)"
  USAGE=$PROGRAM" [-h][-H <option>] gff_file"
  COLORS="    black | verydarkgrey | darkgrey | grey | lightgrey | verylightgrey | white 
       verydarkgreen | darkgreen | green | lightgreen | verylightgreen 
   verydarkskyblue | darkskyblue | skyblue | lightskyblue | verylightskyblue 
          verydarkblue | darkblue | blue | lightblue | verylightblue 
         verydarkcyan | darkcyan | cyan | lightcyan | verylightcyan 
     verydarkviolet | darkviolet | violet | lightviolet | verylightviolet 
            verydarkred | darkred | red | lightred | verylightred 
     verydarkorange | darkorange | orange | lightorange | verylightorange 
     verydarkyellow | darkyellow | yellow | lightyellow | verylightyellow 
        verydarkbrown | darkbrown | brown | lightbrown | verylightbrown"
 # 
 # Default User-Defined Options: 
  bgcolor="white"
  fgcolor="black"
}

#
# Defining Help...
#
Help () {
#  echo ""
#  echo "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
#  echo "         1         2         3         4         5         6         7         8"
  echo ""
  echo "NAME           $PROGRAM"
  echo "VERSION        $VERSION"
  echo ""
  echo "Creation DATE: $SHCREATION"
  echo "Last REVISION: $SHREVISION"
  echo ""
  echo "SYNOPSIS"
  echo ""
  echo "      $USAGE"
  echo ""
  echo "DESCRIPTION"
  echo ""
  echo "       This program draws color-filled DotPlots"
  echo "       from files with gff-formatted data fields."
  echo "   "
  echo ""
  echo "OPTIONS"
  echo ""
  echo "     -h  Show this help."
  echo "     -H <option> Show only help for the especified option."
  echo ""
  echo "COMMENTS"
  echo ""
  echo "  * Colors Defined are:"
  echo ""
  echo "$COLORS"
  echo ""
  echo "BUGS"
  echo ""
  echo "  Please, report bugs to:"
  echo "       $AUTHOR"
  echo "       e-mail: $EMAIL"
  echo "       Mail  : "
  gawk 'BEGIN{tt=ARGV[1];ARGV[1]="";gsub("\%\%","",tt);printf tt;print}' "$MAIL"
  echo ""
  return
}

ShowHelpLine () {
 Help | gawk 'BEGIN{
  IGNORECASE=1; flg=0; srch=ARGV[1]; ARGV[1]=""
  gsub("-","",srch); srch="\ -"srch"\ " }
  { if ($0~srch) { print $0; flg=1 } }
  END{ if (!flg) printf "\n\tERROR: Option %s is not defined,\n\t\tmake sure which option you need help.\n",srch }' $1 
 echo ""
 return
}

#
# Testing parameters passed by User.
#
CheckColor () {
  gawk 'BEGIN{
    color=ARGV[1]
    if (color!~/^BG$|^FG$|^black$|^white$|^(very)?(light|dark)?(grey|green|(sky)?blue|cyan|violet|red|orange|yellow|brown)$/) {
      printf "\n<<<<ERROR>>>> \" %s \" is not a defined color.\n", color | "cat 1>&2"
      printf "              Default \" black \" is asigned to option.\n" | "cat 1>&2"
      printf "              You can choose one of this colors:\n" | "cat 1>&2"
      print ARGV[3] | "cat 1>&2"
      print "" | "cat 1>&2"
      color=ARGV[2]
      }
    print color
    ARGV[1]=ARGV[2]=ARGV[3]=""
    }' $1 $2 "$COLORS"
  return 0
}

CheckInt () {
  if [ `expr $1 : '[0-9]*'` -eq `expr $1 : '.*'` ]
    then echo "1"; return 0
    else 
      echo "<<<<ERROR>>>> \" $1 \" is not an integer value." 1>&2
      echo "              You must especify an integer value to -$W_OPTION" 1>&2
      echo "              Program will take value from defaults..." 1>&2
      echo "" 1>&2
      echo "0";return 1
    fi
  return 1
}
###################################################################
################## Choosing Options for GFF2PS ####################

#
# Resetting default program variables.
#
Defaults

#
# When no options, no parameters and 
#  no inputstream are given, print USAGE.
#
if [ $# -eq 0 ] 
  then
    echo; echo $USAGE; echo; exit 1
  fi

#
# Asking for Help, output it to screen. 
#
case $1 in
  -h) Help; exit 2;;
  -H) echo; echo $PROGRAM" : Option Definition Help."; echo;
      if [ $# -gt 1 ]; 
        then shift; fi;
      for temp in $@;
        do ShowHelpLine $temp; done;
      exit 2;;
  esac

#
# Processing all options and parameters passed to program.
#
## while getopts

###################################################################
################### Converting to PostScript ######################

#
# Printing PostScript Header...
#
gawk 'BEGIN{ 
 # Find actual date...
 "date" | getline d
 split(d,dt," ")
 date = dt[3] "." dt[2] "." dt[6] " " substr(dt[4],1,5)
 # Finding logged user...
 "whoami" | getline usr
 # Printing PostScript Header...
 bigchain=        "%%\!PS-Adobe-2.0\n"
 bigchain=bigchain"%%%%Title: %s\n"
 bigchain=bigchain"%%\n%%%%User: %s\n"
 bigchain=bigchain"%%%%Date: %s\n"
 bigchain=bigchain"%%\n%%%%Program: %s\n"
 bigchain=bigchain"%%%%Version: %s\n"
 bigchain=bigchain"%%%%CreationDate: %s\n"
 bigchain=bigchain"%%%%LastRevision: %s\n"
 bigchain=bigchain"%%%%Author : %s\n"
 bigchain=bigchain"%%%%e-mail : %s\n"
 bigchain=bigchain"%%%%Mail Adress:\n%s\n%%\n"
 if (ARGV[1]!~"##dflt##") title=ARGV[1]
 else title="GFF to PostScript"
 printf bigchain, title, usr, date, ARGV[2], ARGV[3], ARGV[4], ARGV[5], ARGV[6], ARGV[7], ARGV[8]
 printf "%%\n%% ------------------------------------------------------------------------\n"
 printf "%%                           %s - %s\n",ARGV[2], ARGV[3]
 printf "%% ------------------------------------------------------------------------\n"
  for (i=1;i<=8;i++) ARGV[i]=""
}' "##dflt##" "$PSPROGRAM" "$PSVERSION" "$PSCREATION" "$PSREVISION" "$AUTHOR" "$EMAIL" "$MAIL"

#
# Printing %%Prolog Constant Definitions...
#
cat <<'@@@EndProlog@@@'
%
%          Converting GFF files to PostScript plots.
%
%          Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
%                                      Roderic GUIGO SERRA       
%
%    This program is free software; you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation; either version 2 of the License, or
%    (at your option) any later version.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program; if not, write to the Free Software
%    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
%
% ------------------------------------------------------------------------
%
%%Orientation: Portrait
%%BoundingBox:  0  0  595  842 
%%BeginProlog
%
%   1 cm   = 28.35 points
%   1 inch = 72.00 points
%
%  Paper Sizes  (in points)
% --------------------------
%
/pgA2           { 1190 1684 } def
/pgA3           {  842 1190 } def
/pgA4           {  595  842 } def
/pgA5           {  420  595 } def
/pgB4           {  708 1003 } def
/pgB5           {  516  729 } def
/pgExecutive    {  540  720 } def
/pgLedger       { 1224  792 } def
/pgLegal        {  612 1008 } def
/pgLetter       {  612  792 } def
/pgTabloid      {  792 1224 } def
/pgUserDefined  {  595  2448 } def
%
%  Fonts Used
% ---------------------------------
%
/coboti   { 3.0 /Courier-Bold } def
/cobost   { 2.0 /Courier-Bold } def
/tickfont { 1.5 /Courier      } def
/trackfont { 2.00 /Courier-Bold } def
/gnlblsize { 2.00 /Courier      } def
%
%  Fixed Color Variables (CMYK)
% ---------------------------------
%
/colordict 54 dict def colordict begin
/black             { 0.00 0.00 0.00 1.00 } def
/verydarkgrey      { 0.00 0.00 0.00 0.90 } def
/darkgrey          { 0.00 0.00 0.00 0.75 } def
/grey              { 0.00 0.00 0.00 0.50 } def
/lightgrey         { 0.00 0.00 0.00 0.25 } def
/verylightgrey     { 0.00 0.00 0.00 0.10 } def
/white             { 0.00 0.00 0.00 0.00 } def
/verydarkgreen     { 0.65 0.00 0.95 0.40 } def
/darkgreen         { 0.90 0.00 0.90 0.10 } def
/green             { 1.00 0.00 1.00 0.00 } def
/lightgreen        { 0.50 0.00 1.00 0.00 } def
/verylightgreen    { 0.25 0.00 0.75 0.00 } def
/verydarkskyblue   { 0.95 0.15 0.00 0.40 } def
/darkskyblue       { 1.00 0.25 0.00 0.15 } def
/skyblue           { 1.00 0.25 0.00 0.00 } def
/lightskyblue      { 0.80 0.20 0.10 0.00 } def
/verylightskyblue  { 0.60 0.15 0.15 0.00 } def
/verydarkblue      { 1.00 1.00 0.00 0.40 } def
/darkblue          { 1.00 1.00 0.00 0.10 } def
/blue              { 1.00 1.00 0.00 0.00 } def
/lightblue         { 0.80 0.80 0.00 0.00 } def
/verylightblue     { 0.50 0.50 0.00 0.00 } def
/verydarkcyan      { 0.65 0.15 0.00 0.25 } def
/darkcyan          { 0.65 0.15 0.00 0.00 } def
/cyan              { 1.00 0.00 0.00 0.00 } def
/lightcyan         { 0.50 0.00 0.00 0.00 } def
/verylightcyan     { 0.25 0.00 0.00 0.00 } def
/verydarkviolet    { 0.40 0.80 0.20 0.00 } def
/darkviolet        { 0.45 0.85 0.00 0.00 } def
/violet            { 0.30 0.60 0.00 0.00 } def
/lightviolet       { 0.15 0.55 0.00 0.00 } def
/verylightviolet   { 0.05 0.45 0.00 0.00 } def
/verydarkred       { 0.00 0.90 0.90 0.30 } def
/darkred           { 0.00 0.80 0.90 0.10 } def
/red               { 0.00 1.00 1.00 0.00 } def
/lightred          { 0.05 0.80 0.90 0.00 } def
/verylightred      { 0.15 0.40 0.60 0.00 } def
/verydarkorange    { 0.00 0.60 1.00 0.00 } def
/darkorange        { 0.00 0.55 0.90 0.00 } def
/orange            { 0.00 0.50 0.70 0.00 } def
/lightorange       { 0.00 0.30 0.85 0.00 } def
/verylightorange   { 0.00 0.30 0.55 0.00 } def
/verydarkyellow    { 0.00 0.10 0.85 0.25 } def
/darkyellow        { 0.00 0.10 0.85 0.00 } def
/yellow            { 0.00 0.00 1.00 0.00 } def
/lightyellow       { 0.00 0.00 0.50 0.00 } def
/verylightyellow   { 0.00 0.00 0.25 0.00 } def
/verydarkbrown     { 0.00 0.85 1.00 0.70 } def
/darkbrown         { 0.00 0.75 1.00 0.60 } def
/brown             { 0.00 0.70 1.00 0.40 } def
/lightbrown        { 0.30 0.60 0.70 0.00 } def
/verylightbrown    { 0.15 0.45 0.55 0.00 } def
end
% true setpacking
true setstrokeadjust
0.125 setlinewidth
0 setlinejoin
0 setlinecap
%%EndProlog
%%BeginSetup
@@@EndProlog@@@

#
# Printing %%Prolog User-Defined Variables...
#
# gawk -v CUSTOMFILE=$CFDIR/.gff2aplot.rc -v PARAMETERS="$APLOToptions" 'BEGIN{
#
# printf "colordict begin /BGcolor colordict /%s get def /FGcolor colordict /%s get def end\n",BGcolorname,FGcolorname

#
# Printing Main PostScript Routines...

cat <<'@@@EndProcs@@@'
%
% ---------------------------------
%     EndVariableDefinitions
% ---------------------------------
%
% ---------------------------------
%     BeginProcedureDefinitions
% ---------------------------------
%
%  Global Painting Procedures
% ---------------------------------
%
/scolor { colordict exch get exec setcmykcolor } bind def 
%
%  Global Drawing Procedures
% ---------------------------------
%
%
%  Text Procedures
% ---------------------------------
%
%
%  Page Structuring Procedures
% ---------------------------------
%
%
%  Gene Drawing Procedures
% ---------------------------------
%
%%EndSetup
%
%%Page: 1 1
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
%
/PageNumber (Page 1/1) def
flglandscape 0 eq 
{ 0 pgdefault exch pop translate
  -90 rotate
  YUpMargin XDnMargin translate
  pgXscale pgYscale div pgYscale pgXscale div scale
  } { XUpMargin YUpMargin translate
      } ifelse
%
% If last instructions does not setted then horitzontal pages.
%
  putboxes 0 0 pglimits exch box
  BGcolor setcmykcolor
  fill
black setcmykcolor
0.125 setlinewidth 
pgYscale pgXscale scale
header
%
@@@EndProcs@@@

##############################################################
############### Main GFF2PS GNU awk Program... ###############
#
# (cat <<'@@@EndPROGRAM@@@') |
# @@@EndPROGRAM@@@
# gawk -v CUSTOMFILE=$CFDIR/.gff2aplot.rc -f - "$@"

gawk 'BEGIN{
  ############ INITIALITATION ############

  # defaults
  MINSCORE=0.25;
  MAXSCORE=1.00;
  BigLINE="########################################"

  # gff data structure
  seqname  = 1;
  source   = 2;
  feature  = 3;
  start    = 4;
  end      = 5;
  score    = 6;
  strand   = 7;
  frame    = 8;
  group    = 9;

  # gff strand codification
  strands["+"]=strands["-"]=strands["."]=1;

  # Find actual date...
  "date" | getline d
  split(d,dt," ")
  date = dt[3] "." dt[2] "." dt[6] " " substr(dt[4],1,5)

  # Finding logged user...
  "whoami" | getline usr

  # Finding current process...
  "echo $$" | getline IDP

# Layout Properties
  Default["page_size"]="a4"
  Default["page_orientation"]="landscape"
  Default["margin_left"]="1cm"
  Default["margin_right"]="1cm"
  Default["margin_upper"]="1cm"
  Default["margin_bottom"]="1cm"
  Default["foreground_color"]="FGcolor"
  Default["background_color"]="BGcolor"
  Default["block_number"]=1
  Default["strand_show_forward"]="on"
  Default["strand_show_reverse"]="on"
  Default["strand_show_independent"]="on"
# General Properties
  Default["text_color"]=Default["foreground_color"]
  Default["label"]="none"
# Features Properties
  # Default["fillcolor"]=Default["background_color"]
  FT_PROP["label"]="default" # none , default , "user-def"
  FT_PROP["color"]=Default["foreground_color"]
  FT_PROP["shape"]="box"
  FT_PROP["layer"]=0
  FT_PROP["show"]="on"
# Group Properties
  GR_PROP["label"]="default" # none , default , "user-def"
  GR_PROP["rank"]="0:1"
  GR_PROP["join_align"]="center"
  GR_PROP["join_color"]=Default["foreground_color"]
  GR_PROP["join_linetype"]="solid"
  GR_PROP["join_show"]="off"
# Lines (Method-Source) Properties
  SO_PROP["label"]="default" # none , default , "user-def"
  SO_PROP["baseline_align"]="center"
  SO_PROP["baseline_color"]=Default["foreground_color"]
  SO_PROP["baseline_linetype"]="dotted"
  SO_PROP["baseline_show"]="off"
  SO_PROP["bbox_color"]=Default["foreground_color"]
  SO_PROP["bbox_show"]="off"
  SO_PROP["scale"]=1
  SO_PROP["rule_scale"]="nucleotide"
  SO_PROP["rule_rel"]="none"
  SO_PROP["rule_abs"]="none"
# Default[""]=

 # Data for upper-case to lower-case function #lcase()#
 CM["A"]="a";CM["B"]="b";CM["C"]="c";CM["D"]="d";CM["E"]="e";
 CM["F"]="f";CM["G"]="g";CM["H"]="h";CM["I"]="i";CM["J"]="j";
 CM["K"]="k";CM["L"]="l";CM["M"]="m";CM["N"]="n";CM["O"]="o";
 CM["P"]="p";CM["Q"]="q";CM["R"]="r";CM["S"]="s";CM["T"]="t";
 CM["U"]="u";CM["V"]="v";CM["W"]="w";CM["X"]="x";CM["Y"]="y";
 CM["Z"]="z";CM["Ñ"]="ñ";CM["Ç"]="ç"

 }
{ ############ READING .GFF FILES  ############

  # skips those empty lines or comments "#"
  #
  while ($0~/^( )*$|^(\#)+/) { 
    if (getline<=0) break }

  # read gff element within source and strand
  #
  sources[$source]++;  
  n[$source,$strand]++;
  $feature=lcase($feature);
  element[$source,$strand,n[$source,$strand],feature] = $feature; 
  if (!($feature in FT_ary) && $feature!~/\./) FT_ary[$feature]=$feature;
  element[$source,$strand,n[$source,$strand],start]   = $start;
  element[$source,$strand,n[$source,$strand],end]     = $end;
  element[$source,$strand,n[$source,$strand],frame]   = $frame;  
  element[$source,$strand,n[$source,$strand],group]   = $group; 
  if (!($group in GP_ary) && $group!~/\./) GP_ary[$group]=$group;
  if ($NF>group) {
    for (i=(group+1);i<=$NF;i++) {
      if ($i~"Label")
        element[$source,$strand,n[$source,$strand],$i]= $(i+1);  
    }
  }

  # recompute scores between MINSCORE and MAXSCORE
  #
  if ($score < MINSCORE)
    element[$source,$strand,n[$source,$strand],score]  = MINSCORE;
  else if ($score > MAXSCORE)
    element[$source,$strand,n[$source,$strand],score]  = MAXSCORE;

  # place gff element in sort array by acceptor position
  #
  printf "%s\nSorting gff elements...\n%s\n",BigLINE,$0,BigLINE
  ns=n[$source,$strand]-1;
  while ($start < element[$source,$strand,S[$source,$strand,ns],start]) {
    S[$source,$strand,ns+1]=S[$source,$strand,ns];
    print S[$source,$strand,ns],$source,$strand,ns," :",showelem($source,$strand)
    ns--;
  }
  S[$source,$strand,ns+1]=n[$source,$strand]
  print S[$source,$strand,ns+1],$source,$strand,ns+1," :",showelem($source,$strand)

}
END{
  # Defining Object Properties
  #
  printf "%s\nDefining Object Properties..........\n%s\n",BigLINE,BigLINE
  CreateProps("C")
  if (loadcustom) RCFile(CFILE)
  CreateProps("P")

  # make groups. assumes elements sorted by increasing acceptor position
  #
  printf "%s\nMaking Groups...............\n%s\n",BigLINE,BigLINE
  for (sc in sources) {
    for (s in strands) {
      for (i=1;i<=n[sc,s];i++) {
	tgr=element[sc,s,S[sc,s,i],group];
	if (!grouping[sc,s,tgr,start]) {
	  grouping[sc,s,tgr,start]= element[sc,s,S[sc,s,i],start];
	  ng[sc,s]++;
	  group_[sc,s,ng[sc,s]]=tgr
    for (prop in FT_PROP) {
      print grouping[sc,s,tgr,start],sc,s,tgr,start," :",showelem(sc,s)," : ",prop," ",PLOT_FT[element[sc,s,S[sc,s,i],feature],":",prop]
    }
	}
####################
#        grouping[sc,s,tgr,end]= element[sc,s,S[sc,s,i],end];
#
#        # for gene mode. try to recompute relative frame and remainder
#        start_=element[sc,s,S[sc,s,i],start];
#        end_=element[sc,s,S[sc,s,i],end];
#        feature_=element[sc,s,S[sc,s,i],feature];
#
#        frame_[sc,s,tgr]= element[sc,s,S[sc,s,i],frame];
#
#        if (feature_=="First" || feature_=="Single") 
#          frame_[sc,s,tgr]=0;
#        else if (feature_=="Internal" || feature_=="Terminal" )
#          frame_[sc,s,tgr]=remainder_[sc,s,tgr];
#
#        remainder_[sc,s,tgr]=(3-(end_-(start_+frame_[sc,s,tgr])+1)%3)%3;
#
#        grouping[sc,s,tgr,group] = sprintf("%s %d %d %s %d %d %5.3f", grouping[sc,s,tgr,group], element[sc,s,S[sc,s,i],start], element[sc,s,S[sc,s,i],end], psc_feature[element[sc,s,S[sc,s,i],feature]], frame_[sc,s,tgr] ,remainder_[sc,s,tgr],  element[sc,s,S[sc,s,i],score]);
##################### 
	if (element[sc,s,S[sc,s,i],end]>grouping[sc,s,tgr,end]) {
	  grouping[sc,s,tgr,end]= element[sc,s,S[sc,s,i],end];
    for (prop in FT_PROP) {
      print grouping[sc,s,tgr,end],sc,s,tgr,end," :",showelem(sc,s)," : ",prop," ",PLOT_FT[element[sc,s,S[sc,s,i],feature],":",prop]
    }
          }
      }
    }
  }

  # make plotlines. Put non-overlapping groups into the same plotting line.
  #
  printf "%s\nPrinting Lines...............\n%s\n",BigLINE,BigLINE
  for (sc in sources) {
    for (s in strands) {
      for (i=1;i<=ng[sc,s];i++) {
	g=group_[sc,s,i];
	for (j=1;j<=nl[sc,s] && grouping[sc,s,g,start] < endline[sc,s,j];j++);
	nl[sc,s] = j==nl[sc,s]+1 ? j : nl[sc,s];
        endline[sc,s,j]=grouping[sc,s,g,end];
	# plot group in file
	printf "GROUP : %s : %s %d %d \n", g, s, grouping[sc,s,g,start], grouping[sc,s,g,end];        
        }
     }
  }
  
}
function lcase(string) {
  for (chr in CM) gsub(chr,CM[chr],string)
  return string
}
function CreateProps(flag) {
  ############ Create Properties Index for Objects ############
  if (flag=="P") { 
    printf "#\n# L ############PAGE LAYOUT############\n#\n" 
    for (feat in Default) printf "%s=%s\n", feat, Default[feat]
    print "#"
    }
  if (flag=="P") { printf "# F ############GENOMIC FEATURES############\n#\n" }
  for (feat in FT_ary) {
    for (prop in FT_PROP) {
      if (flag=="P") {
	printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] # | "sort"
        }
      else PLOT_FT[feat,":",prop]=FT_PROP[prop]
      }
    if (flag=="P") print "#"
    }
  if (flag=="P") { printf "# G ############GROUP FEATURES############\n#\n" }
  for (feat in GP_ary) {
    for (prop in GR_PROP) {
      if (flag=="P") {
	printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] # | "sort"
        }
      else PLOT_FT[feat,":",prop]=GR_PROP[prop]
      }
    if (flag=="P") {
      printf "# %s:%s=%s\n", feat, "feature_number", Nfeat[feat,":","feature_number"]
      print "#"
      }
    }
  if (flag=="P") { printf "# S ############SOURCE FEATURES############\n#\n" }
  for (feat in sources) {
    for (prop in SO_PROP) {
      if (flag=="P") {
	printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] # | "sort"
        }
      else PLOT_FT[feat,":",prop]=SO_PROP[prop]
      }
    if (flag=="P") {
      printf "# %s:%s=%s\n", feat, "group_number", Ngroup[feat,":","group_number"]
      print "#"
      }
    }
}
function RCFile(file) { ############ Read CustomFile
  while ((getline < file) > 0 ) {
    ChckLn(file)
    nothere=0
    split($0,defs,"=")
    split(defs[1],nwfeat,":")
    first=nwfeat[1]
    if (first=="*") first=".*" 
    gffirst=lcase(first)
    second=nwfeat[2]
    # for (feat in NAME)
    #  if (feat~first)
    #    if (feat in PLOT_FT) PLOT_FT[feat,":",second]=defs[2]
    for (feat in FT_ary) {
      if (match(feat,gffirst)) {
        # print "Feature Match between: " feat " & " first
	if ((feat,":",second) in PLOT_FT) {
          PLOT_FT[feat,":",second]=defs[2]
     	  nothere=1
        }
      }
    }
    for (feat in GP_ary) { 
      if (match(feat,first)) {
        # print "Group Match between: " feat " & " first
	if ((feat,":",second) in PLOT_FT) {
          PLOT_FT[feat,":",second]=defs[2]
	  nothere=1
        }
      }
    }
    for (feat in sources) {
      if (match(feat,first)) {
        # print "Source Match between: " feat " & " first
	if ((feat,":",second) in PLOT_FT) { 
          PLOT_FT[feat,":",second]=defs[2]
	  nothere=1
        }
      }
    }
    # print ">>>New Feature>>>" $0
    if (nothere==0) {
      # print "No Match found: " first      
      FT_ary[gffirst]=gffirst
      PLOT_FT[gffirst,":",second]=defs[2]
    }
  }
  close(file)  
}
function showelem(a,b){
  string=" : "
  string=string element[a,b,n[a,b],feature]" "
  string=string element[a,b,n[a,b],start]" "
  string=string element[a,b,n[a,b],end]" "
  string=string element[a,b,n[a,b],frame]" "
  string=string element[a,b,n[a,b],group]
  return string
 }
' "$@"

##############################################################
############ Main GFF2APLOT GNU awk Program DONE. ############
#

#
# PostScript end of page...
# 
cat <<'@@@EndTrailer@@@'
%%Trailer
%
%%EOF
@@@EndTrailer@@@

#
##################### EOF #####################
#
exit 0
