#!/bin/sh
######################################################################
#                               gff2ps                               #
######################################################################
#
#     Converting GFF files to PostScript.
#
#     Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
#                                 Roderic GUIGO SERRA       
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
######################################################################
#
# Creation Date: 01.03.1999
# Last Update:
#         $Id: gff2ps,v 1.26 1999-07-13 18:06:18 jabril Exp $	
#
# Autor : Josep Francesc ABRIL FERRANDO
# e-mail: jabril@imim.es
#
# ( ./gff2ps -vC mygffcustomfile -- samples/data.gff > samples/.ps ) > & samples/report.
#
#

##############################################################
#################### PROGRAM DEFINITIONS #####################
# 
CMDLine=$0" "$*
# 
# Defining Default Values...
Defaults () {
 # 
 # Constants: 
  PROGRAM="gff2ps"
  VERSION="v1.0"
  REVISION='$Revision: 1.26 $'
  DATERELEASE='$Date: 1999-07-13 18:06:18 $'
  PSPROGRAM="PostScript Output from gff2ps"
  AUTHOR="Josep Francesc ABRIL FERRANDO"
  EMAIL="jabril@imim.es"
  MAIL="%                  Dept. Informatica Medica
%          Institut Municipal d'Investigacio Medica
%                   C./ Doctor Aiguader 80
%                  08003 - BARCELONA (SPAIN)"
  USAGE=$PROGRAM" [-h][-H <option>] gff_file"
  COLORS="    black | verydarkgrey | darkgrey | grey | lightgrey | verylightgrey | white 
       verydarkgreen | darkgreen | green | lightgreen | verylightgreen 
   verydarkskyblue | darkskyblue | skyblue | lightskyblue | verylightskyblue 
          verydarkblue | darkblue | blue | lightblue | verylightblue 
         verydarkcyan | darkcyan | cyan | lightcyan | verylightcyan 
     verydarkviolet | darkviolet | violet | lightviolet | verylightviolet 
            verydarkred | darkred | red | lightred | verylightred 
     verydarkorange | darkorange | orange | lightorange | verylightorange 
     verydarkyellow | darkyellow | yellow | lightyellow | verylightyellow 
        verydarkbrown | darkbrown | brown | lightbrown | verylightbrown"

 # 
 # Default User-Defined Options: 
  CFDIR=`pwd`
  if [ $GFFDIR ]
    then
      if [ -d "$GFFDIR" ]                  ###### Environment variable for working directory.
        then
          CFDIR="$GFFDIR"
        fi
    fi
  bgcolor="white"
  fgcolor="black"
  v01=0; n01="load_customfile"
  v02=""; n02="customfile_name"
  if [ $GFF_CUSTOM_FILE ]         ###### Environment variable for default custom file name.
    then
      v03="$CFDIR/$GFF_CUSTOM_FILE"
    else
      v03="$CFDIR/.gff2psrc"
    fi
    n03="customfile_name_default"
  v04=0; n04="exist_default_customfile"
  v04_1=0; n04_1="create_default_customfile"
  v05=0; n05="print_report"
  v06="Landscape"; n06="page_orientation"
  v07="a4"; n07="page_size"
  v08=1; n08="page_number"
  v09=1; n09="blocks_x_page"
  v10=0; n10="nucleotides_x_line"
  v11=1; n11="show_blocks_top-bottom"
  v12="a4,595,842"; n12="page_bbox"
  v13=10; n13="major_tickmarks_num"
  v14=-1; n14="major_tickmarks_nucleotides"
  v15=10; n15="minor_tickmarks_num"
  v16=-1; n16="minor_tickmarks_nucleotides"
  v17="true"; n17="show_positions"
# Layout Properties
  c01="1cm"; m01="margin_left"
  c02="1cm"; m02="margin_right"
  c03="1cm"; m03="margin_upper"
  c04="1cm"; m04="margin_bottom"
  c05="FGcolor"; m05="foreground_color"
  c06="BGcolor"; m06="background_color"
  c07=5; m07="max_blocks_x_page"
  c08="on"; m08="strand_show_forward"
  c09="on"; m09="strand_show_reverse"
  c10="on"; m10="strand_show_independent"
  c11=$c05; m11="text_color"
  c12="none"; m12="label"
  c13="0.25cm"; m13="default_scale_width"
  c14="1cm";    m14="default_track_width"
  c15="1cm";    m15="default_track_spacing_width"
  c16="0.25cm"; m16="default_block_spacing_width"
  c17="blue";  m17="frame0_color"
  c18="red";   m18="frame1_color"
  c19="green"; m19="frame2_color"
  c20="orange";m20="frame_unknown_color"
  c21=1; m21="show_inner_scale"
  c22=1; m22="show_outer_scale"
  # c23="off"; m23="unfold_grouped_ungrouped";
  # c24="off"; m24="unfold_grouped_line";
  # c25="off"; m25="unfold_ungrouped_line";
} # End of Defaults

#  
# Default PageSizes:
#
pagesizes () {  # Size_name Portrait_minor-axes:X Portrait_major-axes:Y
cat <<'@@@PAGESIZES@@@'
a2         1190 1684
a3          842 1190
a4          595  842
a5          420  595
b4          708 1003
b5          516  729
executive   540  720
ledger     1224  792
legal       612 1008
letter      612  792
tabloid     792 1224
userdefined 595 2448
@@@PAGESIZES@@@
} # End of pagesizes

##############################################################
################### SHELL MAIN FUNCTIONS #####################
#
# Defining Help...
Help () {
#  echo ""
#  echo "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
#  echo "         1         2         3         4         5         6         7         8"
  echo ""
  echo "NAME           $PROGRAM"
  echo "VERSION        $VERSION"
  echo ""
  echo "Creation DATE: $SHCREATION"
  echo "Last REVISION: $SHREVISION"
  echo ""
  echo "SYNOPSIS"
  echo ""
  echo "      $USAGE"
  echo ""
  echo "DESCRIPTION"
  echo ""
  echo "       This program draws color-filled DotPlots"
  echo "       from files with gff-formatted data fields."
  echo "   "
  echo ""
  echo "OPTIONS"
  echo ""
  echo "     -h  Shows this help."
  echo "     -H <option> Shows only help for the especified option."
  echo "     -v Verbose mode, a report is sent to standard error."
  echo "     -S <page_size> Useful for modifying the page size (default is a4)."
  echo "     -p Switches page orientation to Portrait (default is Landscape)."
  echo "     -P <\#> Sets how many pages are needed to split your output (default is one)."
  echo "     -B <\#> Sets blocks per page (default is one)."
  echo "     -N <\#> Sets nucleotides per line (default is the largest sequence position from input gff-files)."
  echo "     -n Switch off element position labels." 
  echo "     -b Blocks from left to right and from top to bottom (default is top to bottom first)."
  echo "     -T <\#> Number of major tickmarks per line (default 10)."
  echo "     -t <\#> Number of minor tickmarks between major tickmarks (default 10)."
  echo "     -K <\#> Major tickmarks scale in nucleotides, default is nucleotide length for lines divided by major tickmarks number (see option -T)."
  echo "     -k <\#> Minor tickmarks scale in nucleotides default is major tickmarks size divided by minor tickmarks number (see option -t)."
  echo "     -d Write (or rewrite if exist) default customfile \"$v03\"."
  echo "     -D <default_custom_filename> Create a new default customfile with the given filename."
  echo "     -C <custom_filename>  Load given custom file and append to default custom file (.gff2psrc)."
  echo ""
  echo "ENVIRONMENT VARIABLES"
  echo ""
  echo "     You can specify the $PROGRAM path where it can find the default files with the shell variable GFFDIR."
  echo "     You can also define the default custom filename you will like with the variable GFF_CUSTOM_FILE, program default filename for custom file is \".gff2psrc\"."
  echo ""
  echo "COMMENTS"
  echo ""
  echo "  * Colors Defined are:"
  echo ""
  echo "$COLORS"
  echo ""
  echo "BUGS"
  echo ""
  echo "  Please, report bugs to:"
  echo "       $AUTHOR"
  echo "       e-mail: $EMAIL"
  echo "       Mail  : "
  gawk 'BEGIN{tt=ARGV[1];ARGV[1]="";gsub("\%\%","",tt);printf tt;print}' "$MAIL"
  echo ""
 return 0
} # End of Help

ShowHelpLine () {
 Help | gawk 'BEGIN{
  IGNORECASE=1; flg=0; srch=ARGV[1]; ARGV[1]=""
  gsub("-","",srch); srch="\ -"srch"\ " }
  { if ($0~srch) { print $0; flg=1 } }
  END{ if (!flg) printf "\n\tERROR: Option %s is not defined,\n\t\tmake sure which option you need help.\n",srch }' $1 
 echo ""
 return 0
} # End of ShowHelpLine

##############################################################
################# POSTSCRIPT MAIN FUNCTIONS ##################
#
# Printing PostScript Prolog (Constants,Variables and Functions)...
MAINPSHEADER () {
gawk 'BEGIN{ 
 # Find actual date...
 "date" | getline d
 split(d,dt," ")
 date = dt[3] "." dt[2] "." dt[6] " " substr(dt[4],1,5)
 # Finding logged user...
 "whoami" | getline usr
 # Printing PostScript Header...
 bg=  "%%\!PS-Adobe-3.0\n"
 bg=bg"%%%%Title: %s\n"
 bg=bg"%%%%Creator: %s\n"
 bg=bg"%%%%Version: %s\n"
 bg=bg"%%%%CreationDate: %s\n"
 bg=bg"%%%%For: %s\n"
 bg=bg"%%%%Pages: (atend)\n"
 bg=bg"%%%%Orientation: (atend)\n"
 bg=bg"%%%%BoundingBox: (atend)\n"
 bg=bg"%%%%EndComments\n%%\n"
 bg=bg"%% Author : %s\n"
 bg=bg"%% e-mail : %s\n"
 bg=bg"%% Mail Adress:\n%s\n%%\n"
 if (ARGV[1]!~"##dflt##") title=ARGV[1]
 else title="GFF to PostScript"
 printf bg, title, ARGV[2], ARGV[3], date, usr, ARGV[4], ARGV[5], ARGV[6]
 printf "%% ------------------------------------------------------------------------\n"
 printf "%%                     %s\n",ARGV[7]
 printf "%% ------------------------------------------------------------------------\n"
 for (i=1;i<=7;i++) ARGV[i]=""
}' "##dflt##" "$PROGRAM" "$VERSION" "$AUTHOR" "$EMAIL" "$MAIL" "$PSPROGRAM"

cat <<'@@@EndProlog@@@'
% 
%    $Id: gff2ps,v 1.26 1999-07-13 18:06:18 jabril Exp $
% 
% 
%        Converting GFF files to PostScript plots.
%
%        Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
%                                    Roderic GUIGO SERRA       
%
%    This program is free software; you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation; either version 2 of the License, or
%    (at your option) any later version.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program; if not, write to the Free Software
%    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
%
% ------------------------------------------------------------------------
%
%%BeginProlog
%
%%BeginProcSet: Basics 1.0 0
/tflg false def % test flag
/bdf { bind def } bind def
/xdf { exch def } bdf
/cm { 28.35 mul } bdf
/in { 72    mul } bdf
%%EndProcSet:   Basics 1.0 0
%
%%BeginProcSet: Constants 1.0 0
% Printing Offset
/VUpOS 0.25 cm def  % offset defines non printable
/VDnOS 0.25 cm def  % paper area for pages (printer outlimits).
/HLtOS 0.25 cm def
/HRtOS 0.25 cm def
% Fixed Color Variables (CMYK)
/colordict 80 dict def colordict begin % 52 colors + 28 definitions
/black            { 0.00 0.00 0.00 1.00 } def /verydarkgrey     { 0.00 0.00 0.00 0.90 } def
/darkgrey         { 0.00 0.00 0.00 0.75 } def /grey             { 0.00 0.00 0.00 0.50 } def
/lightgrey        { 0.00 0.00 0.00 0.25 } def /verylightgrey    { 0.00 0.00 0.00 0.10 } def
/white            { 0.00 0.00 0.00 0.00 } def /verydarkgreen    { 0.65 0.00 0.95 0.40 } def
/darkgreen        { 0.90 0.00 0.90 0.10 } def /green            { 1.00 0.00 1.00 0.00 } def
/lightgreen       { 0.50 0.00 1.00 0.00 } def /verylightgreen   { 0.25 0.00 0.75 0.00 } def
/verydarkskyblue  { 0.95 0.15 0.00 0.40 } def /darkskyblue      { 1.00 0.25 0.00 0.15 } def
/skyblue          { 1.00 0.25 0.00 0.00 } def /lightskyblue     { 0.80 0.20 0.10 0.00 } def
/verylightskyblue { 0.60 0.15 0.15 0.00 } def /verydarkblue     { 1.00 1.00 0.00 0.40 } def
/darkblue         { 1.00 1.00 0.00 0.10 } def /blue             { 1.00 1.00 0.00 0.00 } def
/lightblue        { 0.80 0.80 0.00 0.00 } def /verylightblue    { 0.50 0.50 0.00 0.00 } def
/verydarkcyan     { 0.65 0.15 0.00 0.25 } def /darkcyan         { 0.65 0.15 0.00 0.00 } def
/cyan             { 1.00 0.00 0.00 0.00 } def /lightcyan        { 0.50 0.00 0.00 0.00 } def
/verylightcyan    { 0.25 0.00 0.00 0.00 } def /verydarkviolet   { 0.40 0.80 0.20 0.00 } def
/darkviolet       { 0.45 0.85 0.00 0.00 } def /violet           { 0.30 0.60 0.00 0.00 } def
/lightviolet      { 0.15 0.55 0.00 0.00 } def /verylightviolet  { 0.05 0.45 0.00 0.00 } def
/verydarkred      { 0.00 0.90 0.90 0.30 } def /darkred          { 0.00 0.80 0.90 0.10 } def
/red              { 0.00 1.00 1.00 0.00 } def /lightred         { 0.05 0.80 0.90 0.00 } def
/verylightred     { 0.15 0.40 0.60 0.00 } def /verydarkorange   { 0.00 0.60 1.00 0.00 } def
/darkorange       { 0.00 0.55 0.90 0.00 } def /orange           { 0.00 0.50 0.70 0.00 } def
/lightorange      { 0.00 0.30 0.85 0.00 } def /verylightorange  { 0.00 0.30 0.55 0.00 } def
/verydarkyellow   { 0.00 0.10 0.85 0.25 } def /darkyellow       { 0.00 0.10 0.85 0.00 } def
/yellow           { 0.00 0.00 1.00 0.00 } def /lightyellow      { 0.00 0.00 0.50 0.00 } def
/verylightyellow  { 0.00 0.00 0.25 0.00 } def /verydarkbrown    { 0.00 0.85 1.00 0.70 } def
/darkbrown        { 0.00 0.75 1.00 0.60 } def /brown            { 0.00 0.70 1.00 0.40 } def
/lightbrown       { 0.30 0.60 0.70 0.00 } def /verylightbrown   { 0.15 0.45 0.55 0.00 } def
end % colordict
%  Paper Sizes  (in points)
@@@EndProlog@@@

pagesizes | gawk 'BEGIN{ i=0 } { count[i++]=$1; X[$1]=$2; Y[$1]=$3 }
 END{ 
  printf "/pagedict %s dict def pagedict begin\n",(i+1);
  for (j=0;j<i;j++) printf "/pg%-12s { %4s %4s } def\n", count[j], X[count[j]], Y[count[j]];
  printf "end %% pagedict\n%%%%EndProcSet:   Constants 1.0 0\n"
 }' -
} #### End of MAINPSHEADER function #### 

#
# Printing Main PostScript Routines...
MAINPSPROCS () { 
cat <<'@@@MAINProcs@@@'
%%EndProcSet:   Setting_Vars 1.0 0
%
%%BeginProcSet: Page_Layout 1.0 0
% checking if margins are within the defined offset
flglscape {
 UpM HLtOS lt { /UpM HLtOS def } if % Checking margins for flglscape mode
 DnM HRtOS lt { /DnM HRtOS def } if
 LtM VDnOS lt { /LtM VDnOS def } if
 RtM VUpOS lt { /RtM VUpOS def } if
 } {
  UpM VUpOS lt { /UpM VUpOS def } if % Checking margins for portrait mode
  DnM VDnOS lt { /DnM VDnOS def } if
  LtM HLtOS lt { /LtM HLtOS def } if
  RtM HRtOS lt { /RtM HRtOS def } if
  } ifelse
% defining pagelimits and X - Y scales (Xlim Ylim)
/pglim { Dpage pop LtM RtM add sub Dpage exch pop UpM DnM add sub } def
% Defining starting point on page.
/XORI LtM def
/YORI UpM def
% Defining page-elements layout.
/XSTitl pglim pop XOriTitl 2 mul sub def
/XSBlck pglim pop def
/YSBlck pglim exch pop YSTitl BlckSp NBlck mul add YOriTitl add sub NBlck div def
/XOriBlck 0 def
/YOriBlck YOriTitl YSTitl BlckSp add add def
/XSPlot { XSBlck FLftLbl { XLftLbl sub } if FRgtLbl { XRgtLbl sub } if } def
/XOriPlot { XOriBlck FLftLbl { XLftLbl add } if } def
/Xscale XSPlot MaxNuclPage div def
/YSLine YSBlck LnTot div def
/tracksize tracksize YSLine mul def
/spcrsize spcrsize YSLine mul def
/YSFwd LnFwd YSLine mul def
/YSBth LnBth YSLine mul def
/YSRvs LnRvs YSLine mul def
/YSTck LnTck YSLine mul def
% /is2tck LnBth 0 gt LnFwd 0 gt LnRvs 0 gt and LnFwd 0 eq LnRvs 0 eq and or and def % true if must plot two tickmark lines
 /is1tck LnFwd 0 gt LnBth 0 gt and LnFwd 0 gt LnRvs 0 gt and or LnBth 0 gt LnRvs 0 gt and or def
 /is2tck LnBth 0 gt LnFwd 0 gt LnRvs 0 gt and and def % true if must plot two tickmark lines
%%EndProcSet:   Page_Layout 1.0 0
%
%%BeginProcSet: functions 1.0 0
/min { 2 copy gt { exch } if pop } bdf 
/max { 2 copy lt { exch } if pop } bdf
/Xscm { Xscale mul } bdf /Xscme { Xscm exch } bdf
/ChkLimits { 3 copy pop 5 2 roll dup dup 5 1 roll 3 1 roll lt 3 1 roll gt or { pop false } { true } ifelse } def 
/nucdif { 2 copy exch sub } bdf
%%EndProcSet:   functions 1.0 0
%
%%BeginProcSet: text_functions 1.0 0
/sfont { findfont exch scalefont setfont } bdf
/stringheight  { gsave newpath 0 0 moveto (0) false charpath flattenpath pathbbox exch pop exch sub exch pop 0.95 mul grestore } bdf
/ct { gsave 0 translate sfont scmyk dup stringwidth pop 2 div neg stringheight 2 div neg moveto show grestore } bdf
% /ctr { gsave 0 translate sfont scmyk dup stringwidth pop 2 div neg stringheight 1.65 mul neg moveto show grestore } bdf
%%EndProcSet:   text_functions 1.0 0
%
%%BeginProcSet: painting_functions 1.0 0
/scmyk { setcmykcolor } bdf
/dotted { [ 1 ] 0 setdash } def
/bbox { 4 copy 3 1 roll exch 6 2 roll 8 -2 roll moveto lineto lineto lineto closepath } bdf
/tbbox { tflg { gsave setlinewidth scmyk stroke grestore } { pop pop } ifelse } def
/scolor { colordict exch get exec scmyk } bdf
%
colordict begin % adding definitions and functions
 /lup { /ku xdf /yu xdf /mu xdf /cu xdf } bdf
 /lmd { /km xdf /ym xdf /mm xdf /cm xdf } bdf
 /ldn { /kd xdf /yd xdf /md xdf /cd xdf } bdf
 /load2col { lup ldn /dk ku kd sub def /dy yu yd sub def /dm mu md sub def /dc cu cd sub def } bdf
 /load3col { lup lmd ldn /uk ku km sub def /uy yu ym sub def /um mu mm sub def /uc cu cm sub def /dk km kd sub def /dy ym yd sub def /dm mm md sub def /dc cm cd sub def } bdf
 /col2 { 2 dict begin /p xdf /pcd { p mul add } bdf cd dc pcd md dm pcd yd dy pcd kd dk pcd scmyk end } bdf
 /col3 { 3 dict begin /p xdf /pcd { p 2 mul mul add } bdf /pcu { p 0.5 sub 2 mul mul add } bdf p 0.5 le { cd dc pcd md dm pcd yd dy pcd kd dk pcd } { cm uc pcu mm um pcu ym uy pcu km uk pcu } ifelse scmyk end } bdf
 /rainbow { 1 dict begin /p xdf p 0.1 le { p 0.2 div 0.5 add 1 0 0 scmyk } { p 0.4 le { 1 1 p 0.1 sub 0.3 div sub 0 0 scmyk } { p 0.6 le { 1 0 p 0.4 sub 0.2 div 0 scmyk } { p 0.8 le { 1 p 0.6 sub 0.2 div sub 0 1 0  scmyk } { 0 p 0.8 sub 0.2 div 1 0 scmyk } ifelse } ifelse } ifelse } ifelse end } bdf
end % colordict
%%EndProcSet:   painting_functions 1.0 0
%
%%BeginProcSet: tickmarks 1.4 0
% Rule.ps ---> rules and scales
/tmdct 22 dict def tmdct begin
 /ShowGrid 0 def % 0 - none : 1 - MinTicks : 2 - MaxTicks : 3 - Both
 /Gridup true def /Griddn true def /flgup true def
 /TkMrkHW TkMrkW  2 div def
 /TkMrkDW TkMrkW 10 div def
 /TkFont { TkMrkHW /Helvetica } def
 /MaxWidthT { gsave MaxNuclPage 10 string cvs TkFont sfont stringwidth pop 2 mul grestore } bdf
 /CheckCloser { 3 copy pop MaxWidthT sub 3 1 roll MaxWidthT add 3 1 roll dup dup 5 1 roll 3 1 roll lt 3 1 roll gt or 4 1 roll 3 copy dup 3 1 roll ne 3 1 roll ne and 5 -1 roll and { pop false } { true } ifelse } bdf
 /ctextick { gsave TkFont sfont dup stringheight 2 div exch stringwidth pop 2 Xscm div neg Xscm exch 2 copy neg translate 2 mul exch 2 mul neg exch gsave 0 0 bbox BGcolor scmyk gsave tflg { FGcolor scmyk } if 2 setlinewidth stroke grestore fill grestore 0 0 moveto FGcolor scmyk show grestore } bdf
 /bltextick { gsave TkFont sfont dup stringwidth pop 2 Xscm div neg Xscm TkMrkHW 2 copy flgup { TkMrkDW add translate } { 2 mul translate 1 -1 scale } ifelse exch 2 mul neg exch gsave 0 0 bbox BGcolor scmyk gsave tflg { FGcolor scmyk } if 2 setlinewidth stroke grestore fill grestore 0 0 moveto FGcolor scmyk show grestore } bdf
 /tonormtick { 0 eq { dup dup 0 ne { MinTick mod } if sub exch dup dup 0 ne { MinTick mod } if sub exch } { dup dup 0 ne { MaxTick mod } if sub exch dup dup 0 ne { MaxTick mod } if sub exch } ifelse } bdf
 /Mkg { 0 0 moveto lineto FGcolor scmyk dotted stroke } bdf
 /MkVGrid { gsave setlinewidth Gridup flgup not { not } if { 0 up Mkg } if Griddn flgup not { not } if { 0 down neg Mkg } if  grestore } bdf
 /MkAtick { setlinewidth 0 TkMrkHW neg moveto 0 TkMrkHW lineto FGcolor scmyk stroke } bdf
 /MkBtick { gsave dup Xscm 0 translate ShowGrid 2 eq ShowGrid 3 eq or { 0.25 MkVGrid } if 1 MkAtick CheckCloser { 10 string cvs ctextick } if grestore } bdf
 /MkCtick { setlinewidth 0 0 moveto 0 TkMrkHW 3 -1 roll { TkMrkDW sub } if lineto FGcolor scmyk stroke } bdf
 /MkDtick { gsave dup Xscm 0 translate CheckCloser { 10 string cvs bltextick } if ShowGrid 2 eq ShowGrid 3 eq or { 0.25 MkVGrid } if false 1 MkCtick grestore } bdf
 /baseline { gsave Xscm TkMrkDW moveto Xscm TkMrkDW lineto TkMrkDW 2 mul setlinewidth FGcolor scmyk stroke grestore } bdf
 /r { /Gridup true def /Griddn true def /flgup true def 0 exch translate gsave 0 translate 1 -1 scale 5 { 2 copy } repeat pop neg Xscm 0 translate 0 tonormtick MinTick exch { ChkLimits { gsave Xscm 0 translate 0.25 MkAtick ShowGrid 1 eq ShowGrid 3 eq or { 0 MkVGrid } if grestore } if } for 1 tonormtick MaxTick exch { ChkLimits { MkBtick } if } for 2 { dup dup 0 ne { MaxTick mod } if 0 ne { MkBtick } { pop } ifelse } repeat grestore } bdf
 /x { 6 { 2 copy } repeat pop neg Xscm 0 translate baseline 0 tonormtick MinTick exch { ChkLimits { gsave Xscm 0 translate true 0.25 MkCtick ShowGrid 1 eq ShowGrid 3 eq or { 0 MkVGrid } if grestore } if } for 1 tonormtick MaxTick exch { ChkLimits { MkDtick } if } for 2 { dup dup 0 ne { MaxTick mod } if 0 ne { MkDtick } { pop } ifelse } repeat } bdf 
 /s { /Gridup false def /Griddn true def /flgup true def 0 exch TkMrkW add translate gsave 0 translate 1 -1 scale x grestore } bdf
 /z { /Gridup true def /Griddn false def /flgup false def 0 exch translate gsave 0 translate 1 1 scale x grestore } bdf
end % tmdct
%%EndProcSet:   tickmarks 1.4 0
%
%%BeginProcSet: objects 1.1 0
/shpdct 52 dict def shpdct begin
 /ShFont { TkMrkW 2 div /Helvetica } def
 /LY { tracksize } bdf % 0.75 mul } bdf
 /trackbb { LY 0.55 mul } bdf
 /RWTS { LY 1.5 mul } bdf
 /mtrx matrix def
% Shapes......
 /cpt { moveto { lineto } repeat closepath } bdf
 /hline { 0 0 moveto 1 0 lineto closepath } bdf
 /fline { hline trackbb sc mul setlinewidth } bdf
 /harw {  0.0    0.0  0.0   -1.0  0.745 -1.0  0.745 -1.1  0.75 -1.1  5  1.0  0.0  cpt } bdf
 /farw {  0.75   0.6  0.745  0.6  0.745  0.5  0.0    0.5  0.0  -0.5
          0.745 -0.5  0.745 -0.6  0.75  -0.6                         8  1.0  0.0  cpt } bdf
 /hend {  0.25   0.0  0.0   -1.0  1.0   -1.0                         3  1.0  0.0  cpt } bdf
 /fend {  0.0    0.5  1.0    0.5  1.0   -0.5  0.0 -0.5               4  0.25 0.0  cpt } bdf
 /hbox {  1.0    0.0  1.0   -1.0  0.0   -1.0                         3  0.0  0.0  cpt } bdf
 /fbox {  0.0    0.5  1.0    0.5  1.0   -0.5                         3  0.0 -0.5  cpt } bdf
 /hsgl {  0.25   0.0  0.0   -1.0  0.745 -1.0  0.745 -1.1  0.75 -1.1  5  1.0  0.0  cpt } bdf
 /fsgl {  0.75   0.6  0.745  0.6  0.745  0.5  0.0    0.5  0.25  0.0
          0.0   -0.5  0.745 -0.5  0.745 -0.6  0.75  -0.6             9  1.0  0.0  cpt } bdf
 /hcir {  0.5   -0.5  0.5    0   360 arc closepath } bdf
 /fcir {  0.5    0.0  0.5    0   360 arc closepath } bdf
 /hrtgl { 1.0    0.0  0.0   -1.0                                     2  0.0  0.0  cpt } bdf
 /frtgl { 0.0    0.5  0.0   -0.5                                     2  1.0  0.0  cpt } bdf
 /prmx {  gsave newpath
          1.0   -0.8  0.5   -0.8  0.5   -0.25 moveto lineto lineto
          FGcolor scmyk 0.1 setlinewidth stroke 
          1.0   -0.8  0.75  -0.60 0.75  -1.0  3  1.0   -0.8 cpt
          0.01 setlinewidth gsave stroke grestore fill grestore } bdf
 /hprm {  1.0    0.0  1.0   -0.25 0.0   -0.25 3  0.0  0.0  cpt prmx } bdf
 /fprm {  0.0    0.25 1.0    0.25 1.0   -0.25 3  0.0 -0.25 cpt prmx } bdf
 
% ......Shapes
 /getfrcol { dup (.) eq { pop frmN } { dup 0 eq { pop frm0 } { dup 1 eq { pop frm1 } { 2 eq { frm2 } if } ifelse } ifelse } ifelse } bdf
 /cmdln { 0 moveto sqdif 2 div 0 lineto scmyk stroke } bdf
 /lnfill { gsave RWTS setlinewidth sqdif 2 div cmdln 0 cmdln grestore } bdf
 /frmfill { frm getfrcol rmd getfrcol lnfill } bdf
 /rnbfill { 1 dict begin gsave /incr sqdif 100 div def 0 incr sqdif { dup dup incr add 0 exch 0 moveto lineto dup 0 gt { sqdif div } if rainbow RWTS setlinewidth stroke } for grestore end } bdf 
% /getvar { /ftlbl xdf /sc xdf /rmd xdf /frm xdf strnd (-) eq { exch } if 2 copy exch sub /sqdif exch Xscm def /sqdsc sqdif Xscale div def /seqend exch Xscm def /seqori exch Xscm def /cmod xdf } bdf
 /getvar { /ftlbl xdf /cmod xdf /sc xdf /rmd xdf /frm xdf nucdif /sqdif exch Xscm def /sqend exch def /sqori exch def /seqend sqend Xscm def /seqori sqori Xscm def } bdf
 /setcolmod { colordict begin cmod cvx exec dup 1 eq { pop scmyk fill } { dup 2 eq { pop lnfill } { dup 3 eq { pop frmfill } { dup 4 eq { pop rnbfill } { 0 eq { BGcolor scmyk fill } if } ifelse } ifelse } ifelse } ifelse end } bdf
 /shwpos { Flgshwpos { sqend sqori strnd (-) eq { exch } if sqdif exch 0 2 { gsave trackbb 1 mul moveto 10 string cvs gsave strnd (-) eq { -1 -1 scale -45 } { 45 } ifelse rotate ShFont sfont FGcolor scmyk show grestore grestore } repeat } if } bdf
 % /frshared { strnd (-) eq { -1 -1 scale } if 0.5 setlinewidth gsave /svmtrix mtrx currentmatrix def LY sc mul sqdif flglscape { exch } if scale cvx exec svmtrix setmatrix gsave FGcolor scmyk stroke grestore clip setcolmod grestore shwpos pop } bdf
 /frshared { strnd (-) eq { -1 -1 scale } if 0.5 setlinewidth gsave /svmtrix mtrx currentmatrix def sqdif LY sc mul scale cvx exec svmtrix setmatrix gsave FGcolor scmyk stroke grestore clip setcolmod grestore shwpos pop } bdf
 /f { gsave getvar strnd (-) eq { seqend } { seqori } ifelse 0 translate frshared grestore } bdf
 /gpuline { Flggbline { gsave gplmod 1 eq { 0 0 moveto grdif 0 rlineto /red scolor 1 setlinewidth stroke } if grestore } if } bdf
% /shgplbl { Flgglbl { gsave grori trackbb strnd (-) ne { neg } if translate gplmod 0 gt { gpuline } if grlbl FGcolor 8 /Helvetica grdif 2 div strnd (-) eq { ct } { ctr } ifelse grestore } if } bdf 
 /ctr { gsave 0 translate sfont scmyk dup stringwidth pop 2 div neg stringheight strnd (-) eq { 2 div } { 1.25 mul neg } ifelse moveto show grestore } bdf
 /shgplbl { Flgglbl { gsave grori trackbb strnd (+) eq { neg } if translate gplmod 0 gt { gpuline } if grlbl FGcolor 8 /Helvetica grdif 2 div ctr grestore } if } bdf 
 /g_end { end exit } bdf 
%
% functions for vectors-like data-sets
 /resizetrack tracksize 0.95 mul def
 /vtoffset vectoffset 2 div Xscm def
 /clrselc { colordict begin dup 2 eq { pop load2col /clrproc { {col2} } def } { dup 3 eq { pop load3col /clrproc { {col3} } def } { dup 0 eq { pop white black load2col /clrproc { {col2} } def } { dup 4 eq { pop /clrproc { {rainbow} } def } { 1 eq { white 8 4 roll load2col /clrproc { {col2} } def } if } ifelse } ifelse } ifelse } ifelse } bdf % no end for closing dict because grdct must be closed by calling function
 /v { gsave Xscm dup vtoffset sub exch vtoffset add 0 moveto 0 lineto resizetrack setlinewidth clrproc exec stroke grestore } bdf
 /v_end { end exit } bdf   % end is for grdct dict
end % shpdct
%%EndProcSet:   objects 1.1 0
%
%%BeginProcSet: blocks 1.0 0
/blckdct 32 dict def blckdct begin
 /Y 0 def
% /pbox { XOriBlck YOriBlck XSBlck YSBlck bbox clip tflg not { newpath } { 1 setlinewidth FGcolor scmyk stroke } ifelse } bdf
 /pbox { XOriBlck 5 sub 0 XSBlck 10 add YSBlck bbox clip tflg not { newpath } { 1 setlinewidth FGcolor scmyk stroke } ifelse } bdf
 /bline { Flgsbline { gsave FGcolor scmyk 0.25 setlinewidth 0 0 moveto XSPlot 0 lineto stroke grestore } if } bdf
 /shsrclbl { FLftLbl { Flgslbl { gsave srclbl FGcolor 10 /Courier XLftLbl 2 div neg ct grestore } if } if } bdf
 /srcbndbox { tracksize spcrsize add YSLine mul 2 cm add dup neg -5 exch XSPlot 10 add  4 -1 roll bbox clip tflg not { newpath } { 1 setlinewidth FGcolor scmyk stroke } ifelse } bdf
% /source { /strnd xdf /nxtspacer exch spcrsize mul def 2 dict begin /Yscl exch tracksize mul 2 div def /srclbl xdf /Y Y nxtspacer add Yscl add def 0 Y translate gsave XOriPlot 0 translate gsave 1 -1 scale bline shsrclbl srcbndbox blckori Xscm neg 0 translate } bdf
% ScValign 0:center 1:baseline -1:reverse
 /source { /ScValign xdf /Flgsbline xdf /Flgslbl xdf /strnd xdf /sclines xdf /nxtspacer exch spcrsize mul def /Yscl exch tracksize mul ScValign 0 eq { 2 div } if def /srclbl xdf /Y Y nxtspacer strnd (.) eq { 2 div } if add Yscl add def gsave 0 Y translate gsave XOriPlot 0 translate gsave 1 -1 scale bline shsrclbl srcbndbox blckori Xscm neg 0 translate } bdf
 /s_end { grestore grestore grestore /Y Y Yscl add strnd (.) eq { nxtspacer 2 div add } if def } bdf
%
 /gp { gsave shpdct begin /Flggbline xdf /Flgglbl xdf nucdif /grdif exch Xscm def /grend exch Xscm def /grori exch Xscm def /gplmod xdf /grlbl xdf shgplbl { currentfile token { exec } { exit } ifelse } loop grestore } bdf
%
 /ov { gsave vctdct begin exch Xscm exch translate { currentfile token { exec } { exit } ifelse } loop end grestore } bdf
%
 /tm { gsave tmdct begin /ShowGrid xdf exec end grestore } bdf
 /shwtck { /down   YSFwd def
           /up     YSRvs def
           blckori blckend XOriPlot 0 {s} 2 tm
  is1tck { blckori blckend XOriPlot YSTck YSFwd 0 gt { YSFwd add } { YSBth add } ifelse {r} 0 tm } if
  is2tck { blckori blckend XOriPlot YSTck 2 mul YSFwd add YSBth add {r} 0 tm } if
           blckori blckend XOriPlot YSBlck TkMrkW sub {z} 2 tm
           } bdf
%
 /ChangeStrand { /Y Y YSTck add def } bdf
 /b_end { end grestore } bdf
end
%%EndProcSet:   blocks 1.0 0
%
%%BeginProcSet: main_function_calls 1.0 0
%
/block { blckdct begin /blcknum exch 1 sub def /blckend xdf /blckori xdf /YB YOriBlck YSBlck blcknum mul add BlckSp blcknum mul add def gsave 0 YB translate pbox shwtck /Y YSTck def } bdf
%
%%EndProcSet:   main_function_calls 1.0 0
%
%%EndProlog
%
%%BeginSetup
%
% initgraphics
% true setpacking
true setstrokeadjust
0.125 setlinewidth
0 setlinejoin
0 setlinecap
%
%%EndSetup
%
@@@MAINProcs@@@
} #### End of MAINPSPROCS function

##############################################################
##################### SHELL FUNCTIONS ########################
#
# Testing parameters passed by User: Colors.
CheckColor () {
  gawk 'BEGIN{
    color=ARGV[1]
    if (color!~/^BG$|^FG$|^black$|^white$|^(very)?(light|dark)?(grey|green|(sky)?blue|cyan|violet|red|orange|yellow|brown)$/) {
      printf "\n<<<<ERROR>>>> \" %s \" is not a defined color.\n", color | "cat 1>&2"
      printf "              Default \" black \" is asigned to option.\n" | "cat 1>&2"
      printf "              You can choose one of this colors:\n" | "cat 1>&2"
      print ARGV[3] | "cat 1>&2"
      print "" | "cat 1>&2"
      color=ARGV[2]
      }
    print color
    ARGV[1]=ARGV[2]=ARGV[3]=""
    }' $1 $2 "$COLORS"
  return 0
} # End of CheckColor

#
# Testing parameters passed by User: Integer Numbers.
CheckInt () {
  if [ `expr $1 : '[0-9]*'` -eq `expr $1 : '.*'` ]
    then echo "1"; return 0
    else 
      echo "<<<<ERROR>>>> \" $1 \" is not an integer value." 1>&2
      echo "              You must especify an integer value to -$W_OPTION" 1>&2
      echo "              Program will take value from defaults..." 1>&2
      echo "" 1>&2
      echo "0";return 1
    fi
  return 1
} # End of CheckInt

#
# Testing parameters passed by User: Page Sizes.
chkpagesize () {
  pagesizes | gawk `BEGIN{
    pg=ARGV[1]; ARGV[1]=""; ec=0 }
    pg==$1 { ec=1; ps=sprintf("%s,%s,%s",$1,$2,$3) }
    END{ if (ec) { print ps };
         else { print "a4,595,842" }` $1 -
  return 0
} # End of chkpagesize

#
# Testing if exist a File.
ExistCustomfile () {
  if [ ! -f "$1" ]
    then echo "0"
      echo "Report: Default Custom File does not exist." 1>&2
      return 0
    else echo "1" # exist_default_customfile
      echo "Warning: Default Custom File exist." 1>&2
      echo "          Custom_Filename: $1" 1>&2
      return 1
    fi
} # End of ExistCustomfile

ExistFile () {
  if [ ! -f "$1" ]
    then echo "0"
      echo "Warning: File "$1" is empty or does not exist." 1>&2
      return 1
    else echo "1" # exist_file
      echo "Report: File "$1" exist, included as a gff file." 1>&2
      return 0
    fi
} # End of ExistFile

###################################################################
################## MAIN GFF2PS SHELL SCRIPT #######################
###################################################################
############### CONVERTING GFF TO POSTSCRIPT ######################
###################################################################

Defaults

#
# Checking if default custom file exists
#  else switch on flag to create.
echo "" 1>&2
echo "Report: You have typed the following command line:" 1>&2
echo "" 1>&2
echo $CMDLine 1>&2
echo "" 1>&2

#
# When no options, no parameters and 
#  no inputstream are given, print USAGE.
if [ $# -eq 0 ] 
  then
    echo; echo $USAGE; echo; exit 1
  fi

#
# Asking for Help, output it to screen. 
case $1 in
  -h) Help; exit 2;;
  -H) echo; echo $PROGRAM" : Option Definition Help."; echo;
      if [ $# -gt 1 ]; 
        then shift; fi;
      for temp in $@;
        do ShowHelpLine $temp; done;
      exit 2;;
  esac

#
# Processing all options and parameters passed to program.
while getopts :dD:C:vS:pP:B:bN:T:t:K:k:Hh W_OPTION
  do
    case $W_OPTION in
      H|h) Help; exit 2;;
      d) v04_1=1;;                    # create_default_customfile (.gff2psrc) or rewrite
      D) v04_1=1;                     # create_default_customfile or rename_it if exist
         v03="$CFDIR/$OPTARG";;
      C) if [ ! -f $CFDIR/$OPTARG ];    # load_customfile customfile_name
           then v01=0;
             echo "Error: Custom File $OPTARG does not exist...Not Loaded." 1>&2 ;
           else v01=1;
	         echo "Report: Adding $OPTARG Custom File to Default Custom File." 1>&2 ;
             v02="$CFDIR/$OPTARG";
           fi;;
      v) v05=1;;                        # print_report
      S) v07=$OPTARG;                   # page_bbox
         v12=`chkpagesize $v07`;;  
      p) v06="Portrait";;               # page_orientation
      P) if [ `CheckInt $OPTARG` ]
           then
             v08=$OPTARG;
           fi;;                  # page_number
      B) if [ `CheckInt $OPTARG` ]
           then
             v09=$OPTARG;
           fi;;                  # blocks_x_page
      b) v11=0;;                      # show_blocks_top-bottom
      N) if [ `CheckInt $OPTARG` ]
           then
             v10=$OPTARG;
           fi;;                  # nucleotides_x_line
      n) v17="false";;           # show_positions
      T) if [ `CheckInt $OPTARG` ]
           then
             v13=$OPTARG;
           fi;;                  # major_tickmarks_num
      t) if [ `CheckInt $OPTARG` ]
           then
             v15=$OPTARG;
           fi;;                  # minor_tickmarks_num
      K) if [ `CheckInt $OPTARG` ]
           then
             v14=$OPTARG;
           fi;;                  # major_tickmarks_nucleotides
      k) if [ `CheckInt $OPTARG` ]
           then
             v16=$OPTARG;
           fi;;                  # minor_tickmarks_nucleotides
       :) ShowHelpLine $1; exit 2;;
      \?) ShowHelpLine $1; exit 2;;
    esac # case $W_OPTION
  done   # while getopts
# Done GetOpts

#
# Shifting all options tested before,
# without removing files passed to shell...
 incr=1
 while [ $OPTIND -gt $incr ]
   do shift; incr=`expr $incr + 1`; done
 GFF_INPUT_FILES=""; ck=0
 for files in $@
   do
     if [ `ExistFile ./$files` ]  # $CFDIR/
       then 
         if [ $ck -eq 1 ] 
           then
              GFF_INPUT_FILES=$GFF_INPUT_FILES" "
           fi
         GFF_INPUT_FILES=$GFF_INPUT_FILES./$files;  # $CFDIR/
         shift; ck=1;
       fi
   done

#
# Defining PLOToptions STRING for GNU awk programs.
 v04=`ExistCustomfile "$v03"`
   P="BACKGROUND_COLOR:="$bgcolor"::FOREGROUND_COLOR:="$fgcolor"::"$n04_1":="$v04_1"::"
 P=$P$n01":="$v01"::"$n02":="$v02"::"$n03":="$v03"::"$n04":="$v04"::"$n05":="$v05"::"
 P=$P$n06":="$v06"::"$n07":="$v07"::"$n08":="$v08"::"$n09":="$v09"::"$n10":="$v10"::"
 P=$P$n11":="$v11"::"$n12":="$v12"::"$n13":="$v13"::"$n14":="$v14"::"$n15":="$v15"::"
 P=$P$n16":="$v16"::"$n17":="$v17"::"
 P=$P$m01":="$c01"::"$m02":="$c02"::"$m03":="$c03"::"$m04":="$c04"::"$m05":="$c05"::"
 P=$P$m06":="$c06"::"$m07":="$c07"::"$m08":="$c08"::"$m09":="$c09"::"$m10":="$c10"::"
 P=$P$m11":="$c11"::"$m12":="$c12"::"$m13":="$c13"::"$m14":="$c14"::"$m15":="$c15"::"
 P=$P$m16":="$c16"::"$m17":="$c17"::"$m18":="$c18"::"$m19":="$c19"::"$m20":="$c20"::"
 P=$P$m21":="$c21"::"$m22":="$c22"::DCF:=$CFDIR/.gff2psrc"
 PLOToptions=$P
 if [ $v05 -eq 1 ]
   then
     echo "" 1>&2
     echo "********************************************" 1>&2
     echo ">>>>> Option String Passed to Program <<<<<<" 1>&2
     echo "********************************************" 1>&2
     echo "" 1>&2
     echo $PLOToptions 1>&2
     echo "" 1>&2
   fi

MAINPSHEADER

# (cat <<'@@@EndPROGRAM@@@') |
# @@@EndPROGRAM@@@
# gawk -v CUSTOMFILE=$v03 -f - "$@"
#
(echo "$PLOToptions"; MAINPSPROCS) |
gawk 'BEGIN{
############ INITIALITATION ############
# gff data structure
  seqname  = 1;   gpname     = 1;
  source   = 2;   gpstart    = 2;
  feature  = 3;   gpend      = 3;
  start    = 4;   is_grouped = 4;
  end      = 5;
  score    = 6;
  strand   = 7;
  frame    = 8;
  group    = 9;
  label    = 10;
  color    = 11;
  pos_score= 12;
# gff strand-frame codification
  strands["+"]=strands["."]=strands["-"]=1;
  wstr[1]="+";wstr[2]=".";wstr[3]="-";
  Frames["."]=Frames["0"]=Frames["1"]=Frames["2"]=1;
# coding shape-names
  shpnm["box"]="box";
  shpnm["arrow"]=shpnm["right_arrow"]="arw";
  shpnm["end_arrow"]=shpnm["end_right_arrow"]="end";
  shpnm["circle"]="cir";
  shpnm["single"]=shpnm["right_single"]="sgl";
  shpnm["line"]="line";
  shpnm["center"]="f";
  shpnm["baseline"]="h";
# Loading PSMainProgram. Line 0 is the Command Line Parameter String.
  psline=0;
  while ((getline < ARGV[1])>0) { PSMAIN[psline++]=$0 };
  ARGV[1]="";
############## Defining pre-variables by CommandLine ############ 
 npar=split(PSMAIN[0],parm,"::");
 for (r=1;r<=npar;r++) {
   split(parm[r],elem,":=");
   if (elem[2]!="##dflt##") {
     if (elem[1]~/COLOR\$/) {
       ecolor=elem[2];
       if (ChkColor(ecolor)) {
         if (ecolor~/^BG\$|(##DEFAULT##)/) elem[2]=Var["BACKGROUND_COLOR"]
         else if (ecolor~/^FG\$/) elem[2]=Var["FOREGROUND_COLOR"] } # if ChkColor
       else elem[2]=Var["BACKGROUND_COLOR"] } # if elem[1]
     Var[elem[1]]=elem[2] } # if elem[2]
   } # for
  delete PSMAIN[0]
  for (v in Var) printf "VAR: %-28s :: Value: %s\n", v, Var[v] | "sort | cat 1>&2"
  close("sort | cat 1>&2")
# Layout Properties
  Default["load_customfile"]=Var["load_customfile"];  # in this case we need to force variables.
  Default["customfile_name"]=Var["customfile_name"];  # in this case we need to force variables.
  Default["customfile_name_default"]=Var["DCF"];      # DCF="$CFDIR/.gff2psrc"
  Default["page_size"]="a4";               # Var["page_size"]
  Default["page_bbox"]="a4,595,842";       # Var["page_bbox"]
  Default["page_orientation"]="Landscape"; # Var["page_orientation"] : Landscape (default), Portrait.
  Default["margin_left"]="1cm";            # cm, in, pt
  Default["margin_right"]="1cm";           #
  Default["margin_upper"]="1cm";           #
  Default["margin_bottom"]="1cm";          #
  Default["foreground_color"]="FGcolor";  #
  Default["background_color"]="BGcolor";  #
  Default["nucleotides_x_line"]=0;     # Var["nucleotides_x_line"] : Default=0,gets the seqlenght from data
  Default["blocks_x_page"]=1;          # Var["blocks_x_page"] : Default=1
  Default["show_blocks_top-bottom"]=1; # Var["show_blocks_top-bottom"] : 1->TopBottom, 2->LeftRight.
  Default["page_number"]=1;            # Var["page_number"] : Default=1
  Default["strand_show_forward"]="on";     #
  Default["strand_show_reverse"]="on";     #
  Default["strand_show_independent"]="on"; #
# General Properties
  Default["text_color"]=Default["foreground_color"];
  Default["default_scale_width"]="0.25cm";         #
  Default["default_track_width"]="1cm";            #
  Default["default_track_spacing_width"]="1cm";    #
  Default["default_block_spacing_width"]="0.25cm"; #
  Default["label"]="none";
  Default["major_tickmarks_num"]=10;           #
  Default["major_tickmarks_nucleotides"]=-1;   #
  Default["minor_tickmarks_num"]=10;           #
  Default["minor_tickmarks_nucleotides"]=-1;   #
  Default["frame_unknown_color"]="orange" #
  Default["frame0_color"]="blue";    #
  Default["frame1_color"]="red";     #
  Default["frame2_color"]="green";   #
  Default["show_inner_scale"]=1;
  Default["show_outer_scale"]=1;
  Default["show_positions"]="true"; #
# Features Properties
  FT_PROP["fill_shape_mode"]="default"; # none(BGcolor), default(FGcolor 1color), 1_color, 2_color, frame-remainder, rainbow
  FT_PROP["fill_vector_mode"]="default"; # none(0 BGcolor grad), default(0 black grad), rainbow(1), 1_color(BGcolor color 2), 2_color(color1 color2 2), 3_color(col1 col2 col3 2)
  FT_PROP["label"]="default";       # none , default , "user-def"
  FT_PROP["color"]=Default["foreground_color"]; # 1color(color),2color(color..color),3color(color..color..color)
  FT_PROP["shape"]="box";           # box, arrow, end_arrow, circle # still not implemented: vector, spike, block
  FT_PROP["vert_align"]="baseline"; # center,baseline # still not implemented: reverse
  FT_PROP["layer"]=0;               # now is implemented, first sorting for feature lines is made on FT_PROP["layer"]
  FT_PROP["join"]="on";
  FT_PROP["show"]="on";
# Group Properties
  GR_PROP["color"]="default";        # 
  GR_PROP["label"]="default";        # none , default , "user-def"
  GR_PROP["label_show"]="on";        # none , default , "user-def"
  GR_PROP["group_line_show"]="on";   #
  GR_PROP["group_line"]="default";   # none , default (red line) , ...
  GR_PROP["range"]="0:1";            # range of lower-upper scores
  GR_PROP["vert_align"]="center";    # center or baseline
  GR_PROP["join_align"]="center";
  GR_PROP["join_color"]=Default["foreground_color"];
  GR_PROP["join_linetype"]="solid";
  GR_PROP["join_show"]="off";
# Lines (Method-Source) Properties
  SO_PROP["color"]="default";         # 
  SO_PROP["label"]="default";         # none , default , "user-def"
  SO_PROP["label_show"]="on";    #
  SO_PROP["baseline_show"]="on"; #
  SO_PROP["vert_align"]="center";     # center,baseline(down), 
  SO_PROP["baseline_align"]="center";
  SO_PROP["baseline_color"]=Default["foreground_color"];
  SO_PROP["baseline_linetype"]="dotted";
  SO_PROP["bbox_color"]=Default["foreground_color"];
  SO_PROP["bbox_show"]="off";
  SO_PROP["track_scale"]=1;           #
  SO_PROP["track_spacing_scale"]=0.5; #
  SO_PROP["rule_scale"]="nucleotide";
  SO_PROP["rule_rel"]="none";
  SO_PROP["rule_abs"]="none";
  SO_PROP["unfold_grouped_ungrouped"]="off";
  SO_PROP["unfold_grouped_line"]="off";
  SO_PROP["unfold_ungrouped_line"]="off";
# Data for upper-case to lower-case function #lcase()#
 CM["A"]="a";CM["B"]="b";CM["C"]="c";CM["D"]="d";CM["E"]="e";
 CM["F"]="f";CM["G"]="g";CM["H"]="h";CM["I"]="i";CM["J"]="j";
 CM["K"]="k";CM["L"]="l";CM["M"]="m";CM["N"]="n";CM["O"]="o";
 CM["P"]="p";CM["Q"]="q";CM["R"]="r";CM["S"]="s";CM["T"]="t";
 CM["U"]="u";CM["V"]="v";CM["W"]="w";CM["X"]="x";CM["Y"]="y";
 CM["Z"]="z";CM["Ñ"]="ñ";CM["Ç"]="ç";
# Initialization for some vars.
 BigLINE="########################################";
 MINSCORE=0.10;
 MAXSCORE=1.00;
 FIRST_POS=0;
 LAST_POS=0;
 nordcnt=ordcnt=0;
 grouped_=1;ungrouped_=0;
#
 if (Var["print_report"])
  printf "\n%s\nInput File...\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"

}
{ ############ READING .GFF FILES  ############
  is_EOF=0;
# skips those comment lines (starting with "#") or empty lines
# also checking if input line is gff_formated.
  while (!ChkInput()) { 
    if (Var["print_report"]) { printf ">>> %10s :: Not Read :: %s\n", NR, $0 | "cat 1>&2" };
    if (getline<=0) { is_EOF=1; break };
    }; # while
 if (!is_EOF) {
# Printing Input Lines
  if (Var["print_report"]) { printf "%10s : %s\n", NR, $0 | "cat 1>&2" };
# getting source order from file...
  if (($strand=="+" || $strand=="-") && !($source in sources)) {
    order["strand",ordcnt]=$source; ordcnt++ } # order for sources input.
  else if ($strand=="." && !($source in sources)) {
    order["none",nordcnt]=$source; nordcnt++ };
# Reading gff-line elements.
  ReadElements()
# place gff element in sort array by acceptor position
   NS=N[$source,$strand,$group]-1;
   while ($start < element[$source,$strand,$group,S[$source,$strand,$group,NS],start]) {
     S[$source,$strand,$group,NS+1]=S[$source,$strand,$group,NS]; NS-- } # while
   S[$source,$strand,$group,NS+1]=N[$source,$strand,$group]
  } # if (!is_EOF)
 }  # Main Loop END
END{
  #
  # Defining Object Properties.
  SET_VARS()
  # Sorting groups
  SortGroups()
  #
  # Making Lines...
  MakeGroupLines()
  #
  # Printing groups and elements sorted
  PrtSorted()
  #
  # Defining Page variables.
  SET_PAGE_VARS()
  #
  # PostScript Variables Setup.
  defPSvars()
  #
  # PostScript Main Procs.
  for (i=1;i<psline;i++) print PSMAIN[i]; 
  #
  ###############################################################
  # Pages MAIN LOOP: Start
  for (pages=1;pages<=P;pages++) {
    BORI=PORI
    startPSpage(pages,pages)  # PostSCript PageSetup.
    for (blocks=1;blocks<=B;blocks++) {
      BEND=BORI+NOFFSET
      printf "%%\n%% Block Num: %s Page: %s\n%%\n",blocks,pages
      printf "%s %s %s block\n", BORI, BEND, blocks
      # make groups. assumes elements sorted by increasing acceptor position
      # PostScript Drawing strands, sources, groups, features
      # make plotlines. Put non-overlapping groups into the same plotting line.
      if (Var["print_report"]) printf "\n%s\nPrinting Lines......\nPage: %s Block: %s\nNuc_Ori: %s - Nuc_End: %s\n%s\n\n",BigLINE,pages,blocks,BORI,BEND,BigLINE | "cat 1>&2"
      PRINTGROUPS()
      if (Var["print_report"]) close(" sort +6 | cat 1>&2")
      # Closing Pages MAIN LOOP.
      printf "b_end\n"
      BORI+=BOFFSET
      } # for blocks
    # PostSCript Page Trailer.
    endPSpage(pages)
    PORI+=POFFSET
  } # for pages
  # Pages MAIN LOOP: End
  ###############################################################
  #
  # Closing PostScript document.
  PSTrailer(P)
  #
  # If not exist, create custom file (.gff2psrc)
  CREATECUSTOM()
 }
function lcase(string,    chr) { for (chr in CM) gsub(chr,CM[chr],string); return string }
function min(a,b) { if (a<=b) return a; else return b }
function max(a,b) { if (a>=b) return a; else return b }
function ChkInput() { # some changes will be made on input line if some defaults were present.
 flg_grp=1
 f=split($0,ln,/ \#/);$0="";
 $0=ln[1];for (s=1;s<=f;s++) { delete ln[s] };
 if (!($0~/^(\#)+/ || NF<8) && ($start<$end)) { 
   if (!($frame in Frames)) { 
     printf ">>>WARNING<<< Unknown frame %s (replaced by \".\") in : %s\n",$frame,$0 | "cat 1>&2"
     $frame="." }
   if (!($strand in strands)) {
     printf ">>>WARNING<<< Unknown strand %s (replaced by \".\") in : %s\n",$strand,$0 | "cat 1>&2"
     $strand="." }
   if ($group=="" || $group==".") {
     if (!OnOff(PLOT_FT["unfold_ungrouped_line"])) $group="#" $source $strand $seqname "#";
     else $group="#" NR "#" $source $strand $seqname "#";    # empty group defined as default (none==".")
     # CP_PLOT_FT[$group]=$source   # source from which lines are defined.
     flg_grp=0
     } 
   $feature=lcase($feature);
   }
 if ($0~/^[^\#]+[ \t]+.+[ \t]+.+[ \t]+[+-]?[0-9]+[ \t]+[+-]?[0-9]+[ \t]+[+-]?[0-9]*[.]?[0-9]*[ \t]+[+-.][ \t]+[.012][ \t]+.*/) return 1;
 else {
   if ($0~/^(\#)+.*/ || NF==0) printf ">>>Comment Line: %s\n", $0 | "cat 1>&2"
   else {
     if (NF<8) printf ">>>WARNING<<< Non-standard gff-formatted input line: %s\n\t\tThere are %s fields left: Standard gff lines need a minimum of 8 fields.\n", 8-NF,$0 | "cat 1>&2"
     else if ($start>$end) printf ">>>WARNING<<< Non-standard gff-formatted input line: %s\n\t\t START(%s) must be lower than END(%s)\n", $0,$start,$end | "cat 1>&2"
     else printf ">>>WARNING<<< Non-standard gff-formatted input line: %s\n", $0 | "cat 1>&2"
     }
   return 0 }
 } # End function ChkInput
function ChkLimits(o,O,e,E) { if (e<=O || o>=E) return 0; else return 1 } # start_,BORI,end_,BEND
function OnOff(v) { if (lcase(v)~/^1$|^on$|^y(es)?$|^t(rue)?$/) return 1; else return 0 }
function TxtBool(n) { if (n) return "true"; else return "false" }
function DoUnFoldMixed(SC) {
 if (!OnOff(PLOT_FT[SC,":","unfold_grouped_ungrouped"])&&((OnOff(PLOT_FT[SC,":","unfold_grouped_line"]) || OnOff(PLOT_FT[SC,":","unfold_ungrouped_line"]))))
   return 1; 
 else return 0 } # end of DoUnFoldMixed
function ChkColor(ncolor) {
 if (ncolor~/^FG$|^black$|^white$|^(very)?(light|dark)?(grey|green|(sky)?blue|cyan|violet|red|orange|yellow|brown)$/)
   return 1
 else return 0 } # also when ncolor == ^BG$|(##DEFAULT##)
function checklbl(chain) {   gsub(/[\(]/,"\\050",chain); gsub(/[\)]/,"\\051",chain);
 gsub(/[\<]/,"\\074",chain); gsub(/[\>]/,"\\076",chain); gsub(/[\/]/,"\\057",chain);
 gsub(/[\%]/,"\\045",chain); gsub(/[\[]/,"\\133",chain); gsub(/[\]]/,"\\135",chain);
 gsub(/[\{]/,"\\173",chain); gsub(/[\}]/,"\\175",chain); return chain } # checklbl
function chkpo(v) { if (v=="Portrait") return "false"; else return "true" }
function chkps(v,    vv) {
 vv=lcase(v)
 if (vv~/^(a)(2|3|4|5)$|^(b)(4|5)$|^executive$|^(le)(tter|gal|dger)$|^tabloid$|^userdefined$/)
   return vv
 else return "a4" }
function chkun(st,    t,p) {
 t=lcase(st);
 if (gsub(/cm(s)?/,"",t)>0) { p=t" cm"; return p }
 else {
   if (gsub(/in(ch)?(s)?/,"",t)>0) { p=t" in"; return p }
   else {
     if (gsub(/pt(s)?/,"",t)>0) return t
     else return "1 cm" }}}
function calcpt(st,    t,p) { # return points
 t=lcase(st);
 if (gsub(/cm(s)?/,"",t)>0) { p=t*28.35; return p }
 else {
   if (gsub(/in(ch)?(s)?/,"",t)>0) { p=t*72; return p }
   else {
     if (gsub(/pt(s)?/,"",t)>0) return t
     else return 0 }}} # End of chkps
function Nuc_round(nm,flg,    sign,nmp,i,mlt,smm,t) { # flg=0 then floor; flg=1 then ceiling.
 sign=nm<0?-1:1;
 if (sign==-1) { nm=-nm; flg=!(flg) }
 nmp=nm; for (i=1;nmp>10;i++) { nmp=nmp/10 };
 if (nm>=1000) mlt=2; else mlt=1;
 if (flg) {
   if (nm>0) {
     if (nm%10^(i-mlt)==0) smm=0; else smm=1;
	 t=nm>=100?sign*((int(nmp*10^(mlt-1))+smm)*10^(i-mlt)):sign*100 }
   else t=0 }
 else { if (nm>0) t=nm>=100?sign*((int(nmp*10^(mlt-1)))*10^(i-mlt)):0; else t=0 }
 return t } # End of Nuc_round
function Plot_Lbl(gff_feat,    fl_gp,s,lbl,vn) {
 vn=PLOT_FT[gff_feat,":","label"]
 if (vn=="none") lbl=" ";
 else if (vn=="default") { lbl=gff_feat; if (gff_feat in sources) lbl=lbl"("fl_gp""s")" }
 else lbl=vn;
 return checklbl(lbl) } # End of Plot_Lbl
function Set_feat_Clr(gff_feat,gp,sc,    clrmode,color1,color2,vn,clm) { # remaining to add vector definition colors.
 clrmode=0; color1=""; color2=""; # "none" or not defined
 k=split(PLOT_FT[gff_feat,":","color"],clm,/\.\./);
 vn=PLOT_FT[gff_feat,":","fill_shape_mode"]
 if ((PLOT_FT[gp,":","color"]=="default" || PLOT_FT[gp,":","color"]=="") && (PLOT_FT[sc,":","color"]=="default" || PLOT_FT[sc,":","color"]=="")) {
   if (vn=="default") { clrmode=1; color1="FGcolor " }
   else {
     if (vn=="1_color") { 
       clrmode=1; color1=PLOT_FT[gff_feat,":","color"]" " }
     else {
       if (vn=="2_color") {
         clrmode=2; color1=clm[1]" "; if (k>1) color2=clm[2]" "; else color2="FGcolor " }
       else {
         if (vn=="frame-remainder") { clrmode=3 }
         else if (vn=="rainbow") { clrmode=4 }
         }}}
   tmp=color1""color2""clrmode }
 else {
   if (PLOT_FT[gp,":","color"]!="default" && PLOT_FT[gp,":","color"]!="") tmp=PLOT_FT[gp,":","color"]" "1
   if (PLOT_FT[sc,":","color"]!="default" && PLOT_FT[gp,":","color"]!="") tmp=PLOT_FT[sc,":","color"]" "1
   }
 return tmp } # End of Set_feat_Clr
function Set_feat_Shape(gff_feat,src    ,shp,pos,tmp,vn) {
 vn=PLOT_FT[gff_feat,":","shape"]
 if (vn~/box|(end_)?(right_)?arrow|circle|(right_)?single|line/) shp=shpnm[vn];
 else shp=shpnm["line"];  # (vn==" vector, spike, block ")
 if (PLOT_FT[src,":","vert_align"]~/center|baseline/) pos=shpnm[PLOT_FT[src,":","vert_align"]]
 else pos=shpnm["center"]
 tmp=pos""shp;
 return tmp } # End of Set_feat_Shape
function VertPos(pos,    tt) {
 tt=lcase(pos);
 if (tt=="center" || tt=="default") return 0;
 else if (tt=="baseline" || tt=="down") return 1;
 else if (tt=="reverse" || tt=="up") return -1;
 return 0 } # End of VertPos
function ReadElements() { # read gff element within source, strand, and group 
  sources[$source]++;                       # field 2 (source) counter
  tmp=$source SUBSEP $strand SUBSEP $group;
  if (!(tmp in N)) {
    G[$source,$strand]++;
    gp[$source,$strand,G[$source,$strand],gpname]=$group;
    gp[$source,$strand,G[$source,$strand],gpstart]=$start;
    gp[$source,$strand,G[$source,$strand],gpend]=$end;
    gp[$source,$strand,G[$source,$strand],is_grouped]=flg_grp;
    if (Var["print_report"]) printf "********* Creating Group DataSet : {%s} %s %s %s ( %s %s ) : is_grouped? %s\n",G[$source,$strand],$source,$strand,$group,gp[$source,$strand,G[$source,$strand],gpstart],gp[$source,$strand,G[$source,$strand],gpend],TxtBool(gp[$source,$strand,G[$source,$strand],is_grouped]) | "cat 1>&2"
    } # if N
  N[$source,$strand,$group]++;
  GP_ary[$group]++;                         # field 9 (group) counter
  FT_ary[$feature]++ ;                       # field 3 (gff-feature) counter
   element[$source,$strand,$group,N[$source,$strand,$group],feature] = $feature; 
   element[$source,$strand,$group,N[$source,$strand,$group],start]   = $start;
   element[$source,$strand,$group,N[$source,$strand,$group],end]     = $end;
   element[$source,$strand,$group,N[$source,$strand,$group],frame]   = $frame;  
   element[$source,$strand,$group,N[$source,$strand,$group],score]   = $score;  
   element[$source,$strand,$group,N[$source,$strand,$group],group]   = $group; 
   if (NF>group) {
     for (i=(group+1);i<=NF;i++) {
       if ($i~"Label") { element[$source,$strand,$group,N[$source,$strand,$group],label]= $(i+1); i++ }  
       if ($i~"Color") { element[$source,$strand,$group,N[$source,$strand,$group],color]= $(i+1); i++ }  
       if ($i~"Vector") {
         element[$source,$strand,$group,N[$source,$strand,$group],pos_score]= $(i+1); i++;
         while (i<=NF) {
           element[$source,$strand,$group,N[$source,$strand,$group],pos_score]=element[$source,$strand,$group,N[$source,$strand,$group],pos_score]":"$(i++)"-"$(i++) } # while
         }  # if $i==Vector
       } # for i
     } # if NF
  if (FIRST_POS>$start) FIRST_POS=$start;
  if (LAST_POS<$end) LAST_POS=$end;
# start-end for each group-sc-strand  
  gp[$source,$strand,G[$source,$strand],gpstart]=min(gp[$source,$strand,G[$source,$strand],gpstart],$start) 
  gp[$source,$strand,G[$source,$strand],gpend]  =max(gp[$source,$strand,G[$source,$strand],gpend],$end)
  if (Var["print_report"]) printf "*** Checking group boundaries : {%s} %s %s %s %s %s\n",G[$source,$strand],$source,$strand,$group,gp[$source,$strand,G[$source,$strand],gpstart],gp[$source,$strand,G[$source,$strand],gpend] | "cat 1>&2"
# getting score - boundaries 
    if ($score < MINSCORE) {
      element[$source,$strand,$group,N[$source,$strand,$group],score]=MINSCORE }
    else {
      if ($score > MAXSCORE) element[$source,$strand,$group,N[$source,$strand,$group],score]=MAXSCORE }
 } # End of ReadElements
function SortGroups() {
  if (Var["print_report"]) printf "\n%s\nReordering groups...\n%s\n",BigLINE,BigLINE | "cat 1>&2"
  for (sc in sources) {
    for (s in strands) {
      if (G[sc,s]>0) {
        for (t=1;t<=G[sc,s];t++) {
          gs=t-1
          gpstrt_=gp[sc,s,t,gpstart]
          if (Var["print_report"]) printf "------- %s : (%s) %s\n",t,gp[sc,s,t,gpname],gpstrt_  | "cat 1>&2"
          while (gpstrt_ < gp[sc,s,SG[sc,s,gs],gpstart]) {
           if (Var["print_report"]) printf "------- %s < %s\n",gp[sc,s,t,gpstart],gp[sc,s,SG[sc,s,gs],gpstart]  | "cat 1>&2"
           SG[sc,s,gs+1]=t; gs--
           } # while
          SG[sc,s,gs+1]=t;
         } # for t 
        for (t=1;t<=G[sc,s];t++) {
          if (Var["print_report"]) printf "*** Reordering groups : {%s} %s %s %s ( %s %s )\n",t,sc,s,gp[sc,s,SG[sc,s,t],gpname],gp[sc,s,SG[sc,s,t],gpstart],gp[sc,s,SG[sc,s,t],gpend] | "cat 1>&2"
         } # for t 
        } # if 
      } # for strands
    } # for sources
 } # End of SortGroups
function MakeGroupLines() {
  if (Var["print_report"]) printf "\n%s\nPlacing groups on lines...\n%s\n",BigLINE,BigLINE | "cat 1>&2"
  for (stp=1;stp<=3;stp++) { # for s in strand
    s=wstr[stp]
    for (sc in sources) { 
      if (G[sc,s]>0) {
         lastpos[sc,s,grouped_,1]=lastpos[sc,s,ungrouped_,1]=PORI;
         lines[sc,s,grouped_]=lines[sc,s,ungrouped_]=1;
#        for (t=1;t<=G[sc,s];t++) {
          for (g=1;g<=SG[sc,s,G[sc,s]];g++) {
            # g=SG[sc,s,t]
            gp_nm =gp[sc,s,g,gpname];
            gp_ori=gp[sc,s,g,gpstart];
            gp_end=gp[sc,s,g,gpend];
            gp_gpd= OnOff(PLOT_FT[sc,":","unfold_grouped_ungrouped"]) ? gp[sc,s,g,is_grouped] : 1; # 1 (grouped_) or 0 (ungrouped_)
            if (Var["print_report"]) printf ">>>>>>>%s %s %s (%s %s) G %s SG %s\n",sc,s,gp_nm,gp_ori,gp_end,G[sc,s],g | "cat 1>&2"
            LN=1;
            if ((gp_gpd==1 && OnOff(PLOT_FT[sc,":","unfold_grouped_line"])) || (gp_gpd==0 && OnOff(PLOT_FT[sc,":","unfold_ungrouped_line"]))) { # || OnOff(PLOT_FT[sc,":","unfold_mixed_grouped_ungrouped"])) {
             if (Var["print_report"]) printf "A........%s : %s (%s) G %s SG %s %s %s %s \n",LN,lastpos[sc,s,gp_gpd,LN],gp_ori,G[sc,s],g,sc,s,gp_nm | "cat 1>&2"
             while (lastpos[sc,s,gp_gpd,LN] >= gp_ori) {
              LN++;
              ttt=sc SUBSEP s SUBSEP gp_gpd SUBSEP LN;
              if (!(ttt in lastpos)) lastpos[sc,s,gp_gpd,LN]=PORI;
              if (Var["print_report"]) printf ".........%s : %s : %s (%s)\n",LN,ttt,lastpos[sc,s,gp_gpd,LN],gp_ori | "cat 1>&2"
              } # while lastpos
             lastpos[sc,s,gp_gpd,LN]=gp_end;
             if (Var["print_report"]) printf "B........%s : %s (%s %s) G %s SG %s\n",LN,lastpos[sc,s,gp_gpd,LN],gp_ori,gp_end,G[sc,s],g | "cat 1>&2"
             } # if checking
            lines[sc,s,gp_gpd]=max(lines[sc,s,gp_gpd],LN);
            LE[sc,s,gp_gpd,LN]++;
            LNelem[sc,s,gp_gpd,LN,LE[sc,s,gp_gpd,LN]]=g;
            } # for g(SG)
#         } # for t(G)
        } # if G>0
      } # for sources
    } # for strands
 } # End of MakeGroupLines
function showelemGS(s,p,g,q,  string){
  string=" : ";
  string=string" "element[s,p,g,q,feature]" ";
  string=string" "element[s,p,g,q,start]" ";
  string=string" "element[s,p,g,q,end]" ";
  string=string" "element[s,p,g,q,frame]" ";
  string=string" "element[s,p,g,q,group];
  return string } # End of showelemS
function PrtSorted() {
  if (Var["print_report"]) {
    printf "\n%s\nGroups were sorted...\n%s\n",BigLINE,BigLINE | "cat 1>&2"
    for (sc in sources) {
      for (s in strands) {
        for (ppd=grouped_;ppd>=ungrouped_;ppd--) {
          if (s=="-") pd=1-ppd; else pd=ppd
          for (h=1;h<=lines[sc,s,pd];h++) {
            if (LE[sc,s,pd,h]>0) {
             printf "%s %s : is_grouped %s : Line %s \>\n",sc,s,TxtBool(pd),h | "cat 1>&2"
             for (t=1;t<=LE[sc,s,pd,h];t++) {
               elm_=LNelem[sc,s,pd,h,t];
               printf "\tgpd_%s:line_%s:le_%s:LNel_%s (%s:%s-%s)\n",TxtBool(pd),h,t,elm_,gp[sc,s,elm_,gpname],gp[sc,s,elm_,gpstart],gp[sc,s,elm_,gpend] | "cat 1>&2"
               } # for t
             } # if LE
            } # for h
          } # for pd
        } # for strands
      } # for sources
    close("cat 1>&2")
    printf "\n%s\ngff elements were sorted...\n%s\n",BigLINE,BigLINE | "cat 1>&2"
      for (sc in sources) {
        for (s in strands) {
          printf "\nSOURCE: %s\nSTRAND: %s\n",sc,s | "cat 1>&2"
          if (G[sc,s]>0) {
            for (g=1;g<=G[sc,s];g++) {
              gs=SG[sc,s,g]
              gnm=gp[sc,s,gs,gpname];
              printf "     GROUP : %s (%s:%s)\n",gnm,gp[sc,s,gs,gpstart],gp[sc,s,gs,gpend] | "cat 1>&2"
              if (N[sc,s,gnm]>0) {
                for (i=1;i<=N[sc,s,gnm];i++)
                  printf "%10s %s\n", S[sc,s,gnm,i],showelemGS(sc,s,gnm,S[sc,s,gnm,i]) | "cat 1>&2"
                } # if N
              } # for G
            } # if G
          } # for s
        } # for sc
   } # if print_report
 } # End of PrtSorted
function SET_VARS() {
  # Variable definition hierarchy:
  # Program Defaults < Default Custom File < Custom File < Command Line.
  CreateProps(0)
  ECF=0
  if (Var["exist_default_customfile"]) { # Modifying Defaults with default custom file
    if (Var["print_report"]) printf "\n%s\nReading Default Custom File...\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    RCFile(Var["customfile_name_default"])
    ECF=1
    }
  if (Default["load_customfile"]) { # Modifying Defaults with custom file
    if (Var["print_report"]) printf "\n%s\nReading Custom File...........\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    RCFile(Default["customfile_name"])
    ECF=1
    }
  if (ECF==0) { # Modifying Defaults with Vars if no exist custom file
    if (Var["print_report"]) printf "\n%s\nModified options...........\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    for (lytdef in Default) {
      dft=Default[lytdef]
      if (dft!=Var[lytdef] && Var[lytdef]!="") Default[lytdef]=Var[lytdef]
      if (Var["print_report"]) printf "%s : Default Value=%s Custom File=%s Command-Line=%s : Using=%s\n", lytdef,dft,PLOT_LY[lytdef],Var[lytdef],Default[lytdef] | "sort | cat 1>&2"
      } # for lytdef
    close("sort | cat 1>&2")
    }   # if ECF==0
  # Calculating Page Number, Blocks and NucxLine
  PORI=Nuc_round(FIRST_POS,0) # floor
  PEND=Nuc_round(LAST_POS,1)  # ceiling
  # Zoom must be defined here
  if (PORI!=0) PDIF=PEND-PORI+1
  else PDIF=PEND
 } # End of function SET_VARS
function SET_PAGE_VARS() {
  P=Default["page_number"]
  B=Default["blocks_x_page"]
  if (Default["nucleotides_x_line"]==0) {
    if (B>1 || P>1) NOFFSET=Nuc_round((PDIF/(B*P)),1)
    else NOFFSET=PDIF
    }
  else NOFFSET=Default["nucleotides_x_line"]
  if (NOFFSET>PDIF) NOFFSET=PDIF # necessary if it is defined a Zoom.
  B1= PDIF%NOFFSET!=0 ? ((PDIF-(PDIF%NOFFSET))/NOFFSET)+1 : ((PDIF-(PDIF%NOFFSET))/NOFFSET)
  P = B1%B!=0 ? ((B1-(B1%B))/B)+1 : ((B1-(B1%B))/B)
  if (Default["show_blocks_top-bottom"]) { BOFFSET=NOFFSET; POFFSET=B*NOFFSET }
  else { BOFFSET=P*NOFFSET; POFFSET=NOFFSET }
  if (Var["print_report"]) printf "\n%s\nPostScript Page Definitions...\n%s\n",BigLINE,BigLINE | "cat 1>&2"  
  if (Var["print_report"]) printf "\npage_number %s\nblocks_x_page %s\nnucleotides_x_line %s\nshow_blocks_top-bottom %s\n",Default["page_number"],Default["blocks_x_page"],Default["nucleotides_x_line"],Default["show_blocks_top-bottom"] | "cat 1>&2"  
  if (Var["print_report"]) printf "\nPORI %s\nPEND %s\nP %s\nB %s\nNOFFSET %s\nBOFFSET %s\n\n",PORI,PEND,P,B,NOFFSET,BOFFSET | "cat 1>&2"  
  # Calculating Block scale factor.
  StrSize=0; NStSize=0; # for strands...
  aS=calcpt(Default["default_track_width"]);
  bS=calcpt(Default["default_track_spacing_width"]);
  for (ws in order) {
    split(ws,wsb,SUBSEP)
    if (wsb[1]=="strand") {
      if (!OnOff(PLOT_FT[order[ws],":","unfold_grouped_ungrouped"]) && !OnOff(PLOT_FT[order[ws],":","unfold_grouped_line"]) && !OnOff(PLOT_FT[order[ws],":","unfold_ungrouped_line"]))
        cl=1
      else {
        if (DoUnFoldMixed(order[ws]) && !OnOff(PLOT_FT[order[ws],":","unfold_grouped_ungrouped"]))
          cl=max(lines[order[ws],"+",grouped_],lines[order[ws],"-",grouped_])
        else
          cl=max(lines[order[ws],"+",grouped_],lines[order[ws],"-",grouped_])+max(lines[order[ws],"+",ungrouped_],lines[order[ws],"-",ungrouped_])
        }
      StrSize=StrSize+cl*((aS*PLOT_FT[order[ws],":","track_scale"])+(bS*PLOT_FT[order[ws],":","track_spacing_scale"]))
      }
    else {
     if (wsb[1]=="none") {
      if (!OnOff(PLOT_FT[order[ws],":","unfold_grouped_ungrouped"]) && !OnOff(PLOT_FT[order[ws],":","unfold_grouped_line"]) && !OnOff(PLOT_FT[order[ws],":","unfold_ungrouped_line"]))
        cl=1
      else { 
        if (DoUnFoldMixed(order[ws]) && !OnOff(PLOT_FT[order[ws],":","unfold_grouped_ungrouped"]))
          cl=lines[order[ws],".",grouped_]
        else
          cl=lines[order[ws],".",grouped_]+lines[order[ws],".",ungrouped_]
        }
      NStSize=NStSize+cl*((aS*PLOT_FT[order[ws],":","track_scale"])+(bS*PLOT_FT[order[ws],":","track_spacing_scale"]))
      } # if wsb==none
     } # else if wsb 
    } # for order
  if (OnOff(Default["strand_show_forward"])) StrSizeFwd=StrSize; else StrSizeFwd=0
  if (OnOff(Default["strand_show_reverse"])) StrSizeRvs=StrSize; else StrSizeRvs=0
  if (!OnOff(Default["strand_show_independent"])) NStSize=0
  cpsc=calcpt(Default["default_scale_width"])
  SclSize=2*cpsc # for scales...
  if (OnOff(Default["show_inner_scale"])) {
   if (StrSizeFwd>0 && (NStSize>0 || StrSizeRvs>0)) SclSize=SclSize+cpsc
   if (NStSize>0 && StrSizeRvs>0) SclSize=SclSize+cpsc
  }
  BSize=StrSizeFwd+StrSizeRvs+NStSize+SclSize # (points)
  # Major Minor Tickmarks ratio
  if (Default["major_tickmarks_nucleotides"]==-1) {
    Default["major_tickmarks_nucleotides"]=Nuc_round((PDIF/Default["major_tickmarks_num"]),0) }
  if (Default["minor_tickmarks_nucleotides"]==-1) {
    Default["minor_tickmarks_nucleotides"]=Default["major_tickmarks_nucleotides"]/Default["minor_tickmarks_num"] }
 } # End of function SET_PAGE_VARS
function PRINTGROUPS() { # print groups PlotSeqComp-like.
  for (stp=1;stp<=3;stp++) { # for s in strand
    prtrule=0
    s=wstr[stp]
   if ((s=="+" && OnOff(Default["strand_show_forward"])) || (s=="." && OnOff(Default["strand_show_independent"])) || (s=="-" && OnOff(Default["strand_show_reverse"]))) {
    if (s=="+" || s=="-") lastcnt=ordcnt
    else { lastcnt=nordcnt; prtrule=1 }
    printf "GP------ Source: --- Strand: %s Counter: %s\n", s, lastcnt | "cat 1>&2" 
    if (prtrule && (StrSizeFwd>0 && NStSize>0)) printf "ChangeStrand\n"
    printf "%% ------------------ Strand(%s) Begin\n",s
    for (srcord=0;srcord<lastcnt;srcord++) { # for sc in sources
      if (s=="-") { ngcnt=lastcnt-(srcord+1); sc=order["strand",ngcnt] }
      else {
        if (s=="+") sc=order["strand",srcord]
        else sc=order["none",srcord]      # (s==".")
        }
      if (!OnOff(PLOT_FT[sc,":","unfold_grouped_ungrouped"])) ungp=grouped_; else ungp=ungrouped_; 
      for (pd=grouped_;pd>=ungp;pd--) {
       if (s=="-" && OnOff(PLOT_FT[sc,":","unfold_grouped_ungrouped"])) i=!pd; else i=pd
        for (pl=1;pl<=lines[sc,s,i];pl++) {
          if (s=="-") l=lines[sc,s,i]-pl+1; else l=pl
          printf "GP------ Source: %10s Strand: %s Counter: %s\n", sc, s, srcord | "cat 1>&2" 
          if (DoUnFoldMixed(sc) || (!OnOff(PLOT_FT[sc,":","unfold_grouped_ungrouped"]) && !OnOff(PLOT_FT[sc,":","unfold_grouped_line"]) && !OnOff(PLOT_FT[sc,":","unfold_ungrouped_line"]))) fl_gp="M";
          else { if (i) fl_gp="G"; else fl_gp="U" }
          printf "(%s) %s %s %s (%s) %s %s %s source\n", Plot_Lbl(sc,fl_gp,s), PLOT_FT[sc,":","track_scale"], PLOT_FT[sc,":","track_spacing_scale"],(lines[sc,s,grouped_]+lines[sc,s,ungrouped_]),s,TxtBool(OnOff(PLOT_FT[sc,":","label_show"])),TxtBool(OnOff(PLOT_FT[sc,":","baseline_show"])),VertPos(PLOT_FT[sc,":","vert_align"])
          for (gl=1;gl<=LE[sc,s,i,l];gl++) {
            g=LNelem[sc,s,i,l,gl];
            ng_=gp[sc,s,g,gpname];
            sg_=gp[sc,s,g,gpstart];
            eg_=gp[sc,s,g,gpend];
            if (ChkLimits(sg_,BORI,eg_,BEND)) {
              # plot group in file
              if (Var["print_report"])
                printf "GROUP : %-15s : line_%s order_%s %10d %10d (%s)\n", ng_, l, gl, sg_, eg_, N[sc,s,ng_] | "cat 1>&2";
              if (PLOT_FT[ng_,":","group_line"]=="none") gplt=0         # group without lines
              else if (PLOT_FT[ng_,":","group_line"]=="default") gplt=1 # group red-line
              printf "(%s) %s %s %s %s %s gp \n", Plot_Lbl(ng_), gplt, sg_, eg_, TxtBool(OnOff(PLOT_FT[ng_,":","label_show"])),TxtBool(OnOff(PLOT_FT[ng_,":","group_line_show"]))
              for (el=1;el<=N[sc,s,ng_];el++) {
                sel=S[sc,s,ng_,el];
                start_=element[sc,s,ng_,sel,start];
                end_=element[sc,s,ng_,sel,end];
                if (Var["print_report"]) printf "Element %s : %s : %s - %s\n",el,sel,start_,end_ | "cat 1>&2";
                if (Var["print_report"]) printf "Start %s - BORI %s : end %s - BEND %s\n",start_,BORI,end_,BEND | "cat 1>&2";
                if (ChkLimits(start_,BORI,end_,BEND)) {
                  feature_=element[sc,s,ng_,sel,feature];
                  score_=element[sc,s,ng_,sel,score];
                  # for gene mode. try to recompute relative frame and remainder
                  if (Var["print_report"]) printf "Element %s : %s : %s - %s : %s %s %s/%s \n",el,sel,start_,end_,feature_, score_,frame_,remainder_ | "cat 1>&2";
                  if (element[sc,s,ng_,sel,frame]!=".") {
                      frame_=element[sc,s,ng_,sel,frame];
                      remainder_=(3-(end_-(start_+frame_)+1)%3)%3 }
                  else { frame_="(.)"; remainder_="(.)" }
                if (Var["print_report"]) printf "Element* %s : %s : %s - %s : %s %s %s/%s \n",el,sel,start_,end_,feature_, score_,frame_,remainder_ | "cat 1>&2";
                  if (Var["print_report"])
                    printf "%s %s %s : %s \/%s %d %d %s %s %4.2f (%s) (%s) f\n", sc,s,i, PLOT_FT[feature_,":","layer"], Set_feat_Shape(feature_,sc), start_, end_, frame_ , remainder_, score_, Set_feat_Clr(feature_,tgr,sc), Plot_Lbl(feature_) | "cat 1>&2"
                  printf "%s \/%s %d %d %s %s %4.2f (%s) (%s) f\n", PLOT_FT[feature_,":","layer"], Set_feat_Shape(feature_,sc), start_, end_, frame_ , remainder_, score_, Set_feat_Clr(feature_,tgr,sc), Plot_Lbl(feature_) # | "cat | sort +0nr -1 +6nr -7 +2n -3 +3nr -4"
                  } # if element checklimits
                } # for elements in group             
              # close("cat | sort +0nr -1 +6nr -7 +2n -3 +3nr -4")
              printf "g_end\n"
              } # if group checklimits
            } # for LE
          printf "s_end\n"
          }   # for lines
        } # for grpd
      }   # for scord(source_ordering)
      printf "%% ------------------ Strand(%s) End\n",s
      if (prtrule && (StrSizeRvs>0 && (StrSizeFwd>0 || NStSize>0))) printf "ChangeStrand\n"
     }    # if strand_show
    }     # for strands(stp)
 } # End of function PRINTGROUPS
function CreateProps(flag,    STRING,prop,dffeat,feat,gpfeat,sofeat) {
  ############ Create Properties Index for Objects ############ 
  STRING="#\n# L ######PAGE LAYOUT \& PROGRAM OPTIONS######\n#\n"
  if (flag==1) { 
    printf STRING | "cat 1>&2"
    for (dffeat in Default)
      printf "%s=%s\n", dffeat, Default[dffeat] | "sort 1>&2"
    }
  else if (flag==2) { 
    printf STRING > Default["customfile_name_default"]
    for (dffeat in Default)
      printf "%s=%s\n", dffeat, Default[dffeat] > Default["customfile_name_default"]
    }
  STRING="#\n# F ############GENOMIC FEATURES############\n#\n"
  if (flag==1) {
    close("sort 1>&2"); close("cat 1>&2")
    printf STRING | "cat 1>&2"
    }
  else if (flag==2) {
    close(Var["customfile_name_default"])
    printf STRING >> Default["customfile_name_default"]
    }
  for (feat in FT_ary) {
    for (prop in FT_PROP) {
      if (flag==0) PLOT_FT[feat,":",prop]=FT_PROP[prop]
      else if (flag==1)
	    printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] | "sort 1>&2"
      else if (flag==2)
	    printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] >> Default["customfile_name_default"]
      }
    if (flag==1)
      printf "# %s:%s=%s\n#\n", feat, "feature_number", FT_ary[feat] | "cat 1>&2"
    }
  STRING="#\n# G ############GROUP FEATURES############\n#\n"
  if (flag==1) { 
    close("sort 1>&2"); close("cat 1>&2")
    printf STRING | "cat 1>&2"
    }
  else if (flag==2) {
    close(Var["customfile_name_default"])
    printf STRING >> Default["customfile_name_default"]
    }
  for (gpfeat in GP_ary) {
    for (prop in GR_PROP) {
      if (flag==0) PLOT_FT[gpfeat,":",prop]=GR_PROP[prop]
      else if (flag==1)
	    printf "%s:%s=%s\n", gpfeat, prop, PLOT_FT[gpfeat,":",prop] | "sort 1>&2"
      else if (flag==2)
	    printf "%s:%s=%s\n", gpfeat, prop, PLOT_FT[gpfeat,":",prop] >> Default["customfile_name_default"] 
      }
    if (flag==1)
      printf "# %s:%s=%s\n#\n", gpfeat, "feature_number", GP_ary[gpfeat] | "cat 1>&2"
    }
  STRING="#\n# S ############SOURCE FEATURES############\n#\n"
  if (flag==1) { 
    close("sort 1>&2"); close("cat 1>&2")
    printf STRING | "cat 1>&2"
    }
  else if (flag==2) {
    close(Var["customfile_name_default"])
    printf STRING >> Default["customfile_name_default"]
    }
  for (sofeat in sources) {
    for (prop in SO_PROP) {
      if (flag==0) PLOT_FT[sofeat,":",prop]=SO_PROP[prop]
      else if (flag==1)
	    printf "%s:%s=%s\n", sofeat, prop, PLOT_FT[sofeat,":",prop] | "sort 1>&2"
      else if (flag==2)
	    printf "%s:%s=%s\n", sofeat, prop, PLOT_FT[sofeat,":",prop] >> Default["customfile_name_default"]
      }
    if (flag==1)
      printf "# %s:%s=%s\n#\n", sofeat, "group_number", sources[sofeat] | "cat 1>&2"
    }
  if (flag==1) { close("sort 1>&2"); close("cat 1>&2") }
  else if (flag==2) close(Default["customfile_name_default"])
 } # End of CreateProps
function RCFile(file,    STRING,nothere,first,gffirst,second,ft_type,feat,lytdef,dft) { ############ Read CustomFile
  STRING="Match between: %s & %s : %s=%s\n"
  while ((getline < file) > 0 ) {
   if ( $1!~/^(\#)+/ && NF>0 ) { 
    nothere=0;global=0
    split($0,defs,"=")
    split(defs[1],nwfeat,":")
    first=nwfeat[1]
    if (first=="*") { first=".*"; global=1 }
    gffirst=lcase(first)
    second=nwfeat[2]
    if (ft_type=="F") {
      for (feat in FT_ary) {
        if (match(feat,gffirst)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) {
            PLOT_FT[feat,":",second]=defs[2]
            nothere=1
            }
          if (Var["print_report"])
            printf "Feature "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      if (nothere==0 && !global) {
        FT_ary[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["print_report"])
          printf "No Match found - New Feature: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="G") {
      for (feat in GP_ary) { 
        if (match(feat,first)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) {
            PLOT_FT[feat,":",second]=defs[2]
            nothere=1
            }
          if (Var["print_report"])
            printf "Group "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      if (nothere==0 && !global) {
        GP_ary[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["print_report"])
          printf "No Match found - New Feature: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="S") {
      for (feat in sources) {
        if (match(feat,first)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) { 
            PLOT_FT[feat,":",second]=defs[2]
	        nothere=1
            }
          if (Var["print_report"])
            printf "Source "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      if (nothere==0 && !global) {
        sources[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["print_report"])
          printf "No Match found - New Feature: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="L") {
      if (defs[1] in Default) {
        PLOT_LY[defs[1]]=defs[2]
        if (Var["print_report"])
            printf "Layout "STRING,defs[1],first,defs[1],defs[2] | "cat 1>&2"
        }
      }
   }# if not empty or comment line 
   else 
     if ( $1~/^(\#)$/ && $2~/^[LFGS]$/) ft_type=$2
  } # while getline
  close(file) 
  # Modifying Vars
  if (Var["print_report"]) printf "\n%s\nCommand-Line Modified options...........\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
  for (lytdef in Default) {
    dft=Default[lytdef]
    if (dft==Var[lytdef] && PLOT_LY[lytdef]!="") Default[lytdef]=PLOT_LY[lytdef]
      else Default[lytdef]=Var[lytdef]
    if (Var["print_report"]) printf "%s : Default Value=%s Custom File=%s Command-Line=%s : Using=%s\n", lytdef,dft,PLOT_LY[lytdef],Var[lytdef],Default[lytdef] | "sort | cat 1>&2"
    }
    if (OnOff(PLOT_LY["load_customfile"])) Default["load_customfile"]=PLOT_LY["load_customfile"]
  close("sort | cat 1>&2")
 } # End of RCFile
function CREATECUSTOM() {
  if (Var["create_default_customfile"]) { 
    printf "\n%s\nCustom File:\n%s\n\n%s\n\n", BigLINE,BigLINE, Default["customfile_name_default"] | "cat 1>&2"
    if (Var["exist_default_customfile"]) {
      printf "Warning: I am going to rewrite your Default Custom File.\n" | "cat 1>&2"
      printf "         Moving last Default Custom File to %s.old\n",Default["customfile_name_default"] | "cat 1>&2"
      system("cp -v " Default["customfile_name_default"] " " Default["customfile_name_default"] ".old")
      }
    else {
      printf "Warning: Writing Default Custom File %s.\n",Default["customfile_name_default"] | "cat 1>&2"
      }
    CreateProps(2)
    }
  else {
    printf "\n%s%s\nWarning: Defaults were taken from program defaults,\n",BigLINE,BigLINE | "cat 1>&2"
    printf "         if you want to force program to write default file,\n" | "cat 1>&2"
    printf "         you must pass the command-line option -d to the program.\n" | "cat 1>&2"
    printf "         Default custom-file name: %s\n\n",Default["customfile_name_default"] | "cat 1>&2"
    printf "         ...See help for -d and -D <filename> options...\n" | "cat 1>&2"
    printf "%s%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    }
# Object Properties Report...
  if (Var["print_report"]) {
    printf "\n%s\nObject Properties Defined....\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    CreateProps(1) }
 } # End of function CREATECUSTOM
function defPSvars() {
 printf "%% BG \& FG colors\n";
 printf "/BGcolor { colordict begin %s end } def\n", Var["BACKGROUND_COLOR"];
 printf "/FGcolor { colordict begin %s end } def\n", Var["FOREGROUND_COLOR"];
 printf "/frmN { colordict begin %s end } def\n", Default["frame_unknown_color"];
 printf "/frm0 { colordict begin %s end } def\n", Default["frame0_color"];
 printf "/frm1 { colordict begin %s end } def\n", Default["frame1_color"];
 printf "/frm2 { colordict begin %s end } def\n", Default["frame2_color"];
 printf "%% page orientation flag\n";
 printf "/flglscape %s def\n", chkpo(Default["page_orientation"]);
 printf "%%%% page size in points used for plot % pgA4 == 595  842\n";
 printf "/Dpage { pagedict begin pg%s flglscape { exch } if end } bdf\n", chkps(Default["page_size"]);
 printf "%% margins (1 cm) (Up Down Left Right - margins are XY independent)\n";
 printf "/UpM %s def\n", chkun(Default["margin_upper"]);
 printf "/DnM %s def\n", chkun(Default["margin_bottom"]);
 printf "/LtM %s def\n", chkun(Default["margin_left"]);
 printf "/RtM %s def\n%%\n", chkun(Default["margin_right"]);
 printf "/TkMrkW %s def %% Defining tickmark-width.\n", chkun(Default["default_scale_width"]);
 printf "/BlckSp %s def %% Defining blocks-spacing\n%%\n", chkun(Default["default_block_spacing_width"]);
 printf "/SeqLen %s def\n", PDIF; 
 printf "/XNucOffSet %s def\n", PORI; 
 printf "/NPages %s def\n", P; 
 printf "/NBlck %s def\n", B; 
 printf "/MaxNuclPage %s def\n", NOFFSET;
 printf "/MaxTick %s def\n", Default["major_tickmarks_nucleotides"];
 printf "/MinTick %s def\n%%\n", Default["minor_tickmarks_nucleotides"];
 printf "/tracksize %s def\n", chkun(Default["default_track_width"]);
 printf "/spcrsize  %s def\n", chkun(Default["default_track_spacing_width"]);
 printf "/LnTot  %s def\n", BSize;     # size in points (size is relative here)
 printf "/LnFwd %s def\n", StrSizeFwd; # if they are 0 then not showed
 printf "/LnRvs %s def\n", StrSizeRvs;
 printf "/LnBth %s def\n", NStSize;
 printf "/LnTck %s def\n", cpsc;
 printf "/vectoffset 10 def\n%%\n";
 printf "/Flgshwpos %s def\n%%\n", TxtBool(OnOff(Default["show_positions"]));
 printf "/XLftLbl 4 cm  def\n";
 printf "/FLftLbl true  def\n";
 printf "/XRgtLbl 4 cm  def\n";
 printf "/FRgtLbl false  def\n%%\n";
 printf "/XOriTitl 1 cm def\n";
 printf "/YOriTitl 0 cm def\n";
 printf "/YSTitl 1 cm def\n";
 printf "/FlgTitl true def\n";
 printf "%%\n" } # End of defPSvars
function startPSpage(num,tot) {
 printf "%%%%Page: %s %s\n",num,num;
 printf "%%%%BeginPageSetup\n%%\n";
 printf "%% Saving current page settings\n";
 printf "/pgsave save def\n";
 printf "%% Defining pagenumber\n";
 printf "/PageNumber (Page %s/%s) def\n",num,tot;
 printf "%% Defining page variables\n";
 # printf "/Y YOriBlck def\n";
 printf "%% Setting BGcolor for sheet \n";
 printf "Dpage flglscape { exch } if 0 0 bbox FGcolor 1 tbbox BGcolor scmyk fill\n";
 printf "%% setting coordinate axes for page orientation\n";
 printf "flglscape\n";
 printf " { 90 rotate 1 -1 scale XORI YORI translate }                  %% (0,0) - Ori for landscape pages\n";
 printf " { XORI Dpage exch pop YORI sub translate 1 -1 scale } ifelse  %% (0,0) - Ori for portrait pages\n";
 printf "%% If testing output print bounding_boxes for page elements\n";
 printf "%%tflg { TB } if\n%%\n%% /FGcolor scolor\n%%\n";
 printf "%% Header\n%%\n";
 printf "%%%%EndPageSetup\n";
 printf "%%\n" } # End of startPSpage
function endPSpage(p) {
 printf "%%\ngrestoreall\npgsave restore\nshowpage\n"
 printf "%%\n%% PageEND: %s %s\n%%\n",p,p } # End of endPSpage
function PSTrailer(pages,    bbm,bbx,bby) {
 split(Default["page_bbox"],bbm,",")
 if (Default["page_orientation"]=="Landscape") { bbx=bbm[2]; bby=bbm[1] }
 else { bbx=bbm[1]; bby=bbm[2] }
 # PostScript end of page (Trailer)
 printf "%%%%Trailer\n%%\n";
 printf "%%%%Pages: %s\n", pages;
 printf "%%%%Orientation: %s\n", Default["page_orientation"];
 printf "%%%%BoundingBox: 0 0 %s %s\n%%%%EOF\n", bbx, bby;
 } # End of PSTrailer
' - $GFF_INPUT_FILES
#### Main GFF2APLOT GNU awk Program DONE.

#
##################### EOF #####################
exit 0
