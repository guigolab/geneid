#!/bin/sh
######################################################################
#                               gff2ps                               #
######################################################################
#
#     Converting GFF files to PostScript.
#
#     Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
#                                 Roderic GUIGO SERRA       
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
######################################################################
#
# Creation Date: 01.03.1999
# Last Update:
#         $Id: gff2ps,v 1.18 1999-06-22 20:58:32 jabril Exp $	
#
# Autor : Josep Francesc ABRIL FERRANDO
# e-mail: jabril@imim.es
#
# ( ./gff2ps -vC mygffcustomfile -- samples/data.gff > samples/.ps ) > & samples/report.
#

 CMDLine=$0" "$*
# CMDLine=`history | gawk '{last=$0}END{print last}' -`
# CMDLine=`history | gawk '{$1=$2="";last[NR]=$0}END{print last[NR-1]}' -`

##############################################################
#################### PROGRAM DEFINITIONS #####################
# 
# Defining Default Values...
#
Defaults () {
 # 
 # Constants: 
  PROGRAM="gff2ps"
  VERSION="v1.0"
  REVISION='$Revision: 1.18 $'
  DATERELEASE='$Date: 1999-06-22 20:58:32 $'
  PSPROGRAM="PostScript Output from gff2ps"
  AUTHOR="Josep Francesc ABRIL FERRANDO"
  EMAIL="jabril@imim.es"
  MAIL="%                  Dept. Informatica Medica
%          Institut Municipal d'Investigacio Medica
%                   C./ Doctor Aiguader 80
%                  08003 - BARCELONA (SPAIN)"
  USAGE=$PROGRAM" [-h][-H <option>] gff_file"
  COLORS="    black | verydarkgrey | darkgrey | grey | lightgrey | verylightgrey | white 
       verydarkgreen | darkgreen | green | lightgreen | verylightgreen 
   verydarkskyblue | darkskyblue | skyblue | lightskyblue | verylightskyblue 
          verydarkblue | darkblue | blue | lightblue | verylightblue 
         verydarkcyan | darkcyan | cyan | lightcyan | verylightcyan 
     verydarkviolet | darkviolet | violet | lightviolet | verylightviolet 
            verydarkred | darkred | red | lightred | verylightred 
     verydarkorange | darkorange | orange | lightorange | verylightorange 
     verydarkyellow | darkyellow | yellow | lightyellow | verylightyellow 
        verydarkbrown | darkbrown | brown | lightbrown | verylightbrown"

 # 
 # Default User-Defined Options: 
  CFDIR=`pwd`
  if [ $GFFDIR ]
    then
      if [ -d "$GFFDIR" ]                  ###### Environment variable for working directory.
        then
          CFDIR="$GFFDIR"
        fi
    fi
  bgcolor="white"
  fgcolor="black"
  v01=0; n01="load_customfile"
  v02=""; n02="customfile_name"
  if [ $GFF_CUSTOM_FILE ]         ###### Environment variable for default custom file name.
    then
      v03="$CFDIR/$GFF_CUSTOM_FILE"
    else
      v03="$CFDIR/.gff2psrc"
    fi
    n03="customfile_name_default"
  v04=0; n04="exist_default_customfile"
  v04_1=0; n04_1="create_default_customfile"
  v05=0; n05="print_report"
  v06="Landscape"; n06="page_orientation"
  v07="a4"; n07="page_size"
  v08=1; n08="page_number"
  v09=1; n09="blocks_x_page"
  v10=0; n10="nucleotides_x_line"
  v11=1; n11="show_blocks_top-bottom"
  v12="a4,595,842"; n12="page_bbox"
# Layout Properties
  c01="1cm"; m01="margin_left"
  c02="1cm"; m02="margin_right"
  c03="1cm"; m03="margin_upper"
  c04="1cm"; m04="margin_bottom"
  c05="FGcolor"; m05="foreground_color"
  c06="BGcolor"; m06="background_color"
  c07=5; m07="max_blocks_x_page"
  c08="on"; m08="strand_show_forward"
  c09="on"; m09="strand_show_reverse"
  c10="on"; m10="strand_show_independent"
  c11=$c05; m11="text_color"
  c12="none"; m12="label"
  c13="0.25cm"; m13="default_scale_width"
  c14="1cm";    m14="default_track_width"
  c15="1cm";    m15="default_track_spacing_width"
  c16="0.25cm"; m16="default_block_spacing_width"
  c17="blue";  m17="frame0_color"
  c18="red";   m18="frame1_color"
  c19="green"; m19="frame2_color"
  c20=1; m20="show_inner_scale"
  c21=1; m21="show_outer_scale"
}

#  
# Default PageSizes:
#
pagesizes () {  # Size_name Portrait_minor-axes:X Portrait_major-axes:Y
cat <<'@@@PAGESIZES@@@'
a2         1190 1684
a3          842 1190
a4          595  842
a5          420  595
b4          708 1003
b5          516  729
executive   540  720
ledger     1224  792
legal       612 1008
letter      612  792
tabloid     792 1224
userdefined 595 2448
@@@PAGESIZES@@@
}

#
# Defining Help...
#
Help () {
#  echo ""
#  echo "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
#  echo "         1         2         3         4         5         6         7         8"
  echo ""
  echo "NAME           $PROGRAM"
  echo "VERSION        $VERSION"
  echo ""
  echo "Creation DATE: $SHCREATION"
  echo "Last REVISION: $SHREVISION"
  echo ""
  echo "SYNOPSIS"
  echo ""
  echo "      $USAGE"
  echo ""
  echo "DESCRIPTION"
  echo ""
  echo "       This program draws color-filled DotPlots"
  echo "       from files with gff-formatted data fields."
  echo "   "
  echo ""
  echo "OPTIONS"
  echo ""
  echo "     -h  Shows this help."
  echo "     -H <option> Shows only help for the especified option."
  echo "     -v Verbose mode, a report is sent to standard error."
  echo "     -S <page_size> Useful for modifying the page size (default is a4)."
  echo "     -p Switches page orientation to Portrait (default is Landscape)."
  echo "     -P <\#> Sets how many pages are needed to split your output (default is one)."
  echo "     -B <\#> Sets blocks per page (default is one)."
  echo "     -N <\#> Sets nucleotides per line (default is the largest sequence position from input gff-files)."
  echo "     -b Blocks from left to right and from top to bottom (default is top to bottom first)."
  echo "     -d Write (or rewrite if exist) default customfile \".gff2psrc\"."
  echo "     -D <default_custom_filename> Create a new default customfile with the given filename."
  echo "     -C <custom_filename>  Load given custom file and append to default custom file (.gff2psrc)."
  echo ""
  echo "ENVIRONMENT VARIABLES"
  echo ""
  echo "     You can specify the $PROGRAM path where it can find the default files with the shell variable GFFDIR."
  echo "     You can also define the default custom filename you will like with the variable GFF_CUSTOM_FILE, program default filename for custom file is \".gff2psrc\"."
  echo ""
  echo "COMMENTS"
  echo ""
  echo "  * Colors Defined are:"
  echo ""
  echo "$COLORS"
  echo ""
  echo "BUGS"
  echo ""
  echo "  Please, report bugs to:"
  echo "       $AUTHOR"
  echo "       e-mail: $EMAIL"
  echo "       Mail  : "
  gawk 'BEGIN{tt=ARGV[1];ARGV[1]="";gsub("\%\%","",tt);printf tt;print}' "$MAIL"
  echo ""
 return 0
}

ShowHelpLine () {
 Help | gawk 'BEGIN{
  IGNORECASE=1; flg=0; srch=ARGV[1]; ARGV[1]=""
  gsub("-","",srch); srch="\ -"srch"\ " }
  { if ($0~srch) { print $0; flg=1 } }
  END{ if (!flg) printf "\n\tERROR: Option %s is not defined,\n\t\tmake sure which option you need help.\n",srch }' $1 
 echo ""
 return 0
}

##############################################################
################# POSTSCRIPT MAIN FUNCTIONS ##################

#
# Printing PostScript Prolog (Constants,Variables and Functions)...
#
MAINPSHEADER () {

gawk 'BEGIN{ 
 # Find actual date...
 "date" | getline d
 split(d,dt," ")
 date = dt[3] "." dt[2] "." dt[6] " " substr(dt[4],1,5)
 # Finding logged user...
 "whoami" | getline usr
 # Printing PostScript Header...
 bg=  "%%\!PS-Adobe-3.0\n"
 bg=bg"%%%%Title: %s\n"
 bg=bg"%%%%Creator: %s\n"
 bg=bg"%%%%Version: %s\n"
 bg=bg"%%%%CreationDate: %s\n"
 bg=bg"%%%%For: %s\n"
 bg=bg"%%%%Pages: (atend)\n"
 bg=bg"%%%%Orientation: (atend)\n"
 bg=bg"%%%%BoundingBox: (atend)\n"
 bg=bg"%%%%EndComments\n%%\n"
 bg=bg"%% Author : %s\n"
 bg=bg"%% e-mail : %s\n"
 bg=bg"%% Mail Adress:\n%s\n%%\n"
 if (ARGV[1]!~"##dflt##") title=ARGV[1]
 else title="GFF to PostScript"
 printf bg, title, ARGV[2], ARGV[3], date, usr, ARGV[4], ARGV[5], ARGV[6]
 printf "%% ------------------------------------------------------------------------\n"
 printf "%%                     %s\n",ARGV[7]
 printf "%% ------------------------------------------------------------------------\n"
 for (i=1;i<=7;i++) ARGV[i]=""
}' "##dflt##" "$PROGRAM" "$VERSION" "$AUTHOR" "$EMAIL" "$MAIL" "$PSPROGRAM"

cat <<'@@@EndProlog@@@'
% 
%    $Id: gff2ps,v 1.18 1999-06-22 20:58:32 jabril Exp $
% 
% 
%        Converting GFF files to PostScript plots.
%
%        Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
%                                    Roderic GUIGO SERRA       
%
%    This program is free software; you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation; either version 2 of the License, or
%    (at your option) any later version.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program; if not, write to the Free Software
%    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
%
% ------------------------------------------------------------------------
%
%%BeginProlog
%
%%BeginProcSet: Basics 1.0 0
/tflg false def % test flag
/bdf { bind def } bind def
/xdf { exch def } bdf
/cm { 28.35 mul } bdf
/in { 72    mul } bdf
%%EndProcSet:   Basics 1.0 0
%
%%BeginProcSet: Constants 1.0 0
% Printing Offset
/VUpOS 0.25 cm def  % offset defines non printable
/VDnOS 0.25 cm def  % paper area for pages (printer outlimits).
/HLtOS 0.25 cm def
/HRtOS 0.25 cm def
% Fixed Color Variables (CMYK)
/colordict 80 dict def colordict begin % 52 colors + 28 definitions
/black            { 0.00 0.00 0.00 1.00 } def /verydarkgrey     { 0.00 0.00 0.00 0.90 } def
/darkgrey         { 0.00 0.00 0.00 0.75 } def /grey             { 0.00 0.00 0.00 0.50 } def
/lightgrey        { 0.00 0.00 0.00 0.25 } def /verylightgrey    { 0.00 0.00 0.00 0.10 } def
/white            { 0.00 0.00 0.00 0.00 } def /verydarkgreen    { 0.65 0.00 0.95 0.40 } def
/darkgreen        { 0.90 0.00 0.90 0.10 } def /green            { 1.00 0.00 1.00 0.00 } def
/lightgreen       { 0.50 0.00 1.00 0.00 } def /verylightgreen   { 0.25 0.00 0.75 0.00 } def
/verydarkskyblue  { 0.95 0.15 0.00 0.40 } def /darkskyblue      { 1.00 0.25 0.00 0.15 } def
/skyblue          { 1.00 0.25 0.00 0.00 } def /lightskyblue     { 0.80 0.20 0.10 0.00 } def
/verylightskyblue { 0.60 0.15 0.15 0.00 } def /verydarkblue     { 1.00 1.00 0.00 0.40 } def
/darkblue         { 1.00 1.00 0.00 0.10 } def /blue             { 1.00 1.00 0.00 0.00 } def
/lightblue        { 0.80 0.80 0.00 0.00 } def /verylightblue    { 0.50 0.50 0.00 0.00 } def
/verydarkcyan     { 0.65 0.15 0.00 0.25 } def /darkcyan         { 0.65 0.15 0.00 0.00 } def
/cyan             { 1.00 0.00 0.00 0.00 } def /lightcyan        { 0.50 0.00 0.00 0.00 } def
/verylightcyan    { 0.25 0.00 0.00 0.00 } def /verydarkviolet   { 0.40 0.80 0.20 0.00 } def
/darkviolet       { 0.45 0.85 0.00 0.00 } def /violet           { 0.30 0.60 0.00 0.00 } def
/lightviolet      { 0.15 0.55 0.00 0.00 } def /verylightviolet  { 0.05 0.45 0.00 0.00 } def
/verydarkred      { 0.00 0.90 0.90 0.30 } def /darkred          { 0.00 0.80 0.90 0.10 } def
/red              { 0.00 1.00 1.00 0.00 } def /lightred         { 0.05 0.80 0.90 0.00 } def
/verylightred     { 0.15 0.40 0.60 0.00 } def /verydarkorange   { 0.00 0.60 1.00 0.00 } def
/darkorange       { 0.00 0.55 0.90 0.00 } def /orange           { 0.00 0.50 0.70 0.00 } def
/lightorange      { 0.00 0.30 0.85 0.00 } def /verylightorange  { 0.00 0.30 0.55 0.00 } def
/verydarkyellow   { 0.00 0.10 0.85 0.25 } def /darkyellow       { 0.00 0.10 0.85 0.00 } def
/yellow           { 0.00 0.00 1.00 0.00 } def /lightyellow      { 0.00 0.00 0.50 0.00 } def
/verylightyellow  { 0.00 0.00 0.25 0.00 } def /verydarkbrown    { 0.00 0.85 1.00 0.70 } def
/darkbrown        { 0.00 0.75 1.00 0.60 } def /brown            { 0.00 0.70 1.00 0.40 } def
/lightbrown       { 0.30 0.60 0.70 0.00 } def /verylightbrown   { 0.15 0.45 0.55 0.00 } def
end % colordict
%  Paper Sizes  (in points)
@@@EndProlog@@@

pagesizes | gawk 'BEGIN{ i=0 } { count[i++]=$1; X[$1]=$2; Y[$1]=$3 }
 END{ 
  printf "/pagedict %s dict def pagedict begin\n",(i+1);
  for (j=0;j<i;j++) printf "/pg%-12s { %4s %4s } def\n", count[j], X[count[j]], Y[count[j]];
  printf "end %% pagedict\n%%%%EndProcSet:   Constants 1.0 0\n"
 }' -

}
#### End of MAINPSHEADER function

#
# Printing Main PostScript Routines...
#
MAINPSPROCS () { 
cat <<'@@@MAINProcs@@@'
%%EndProcSet:   Setting_Vars 1.0 0
%
%%BeginProcSet: Page_Layout 1.0 0
% checking if margins are within the defined offset
flglscape {
 UpM HLtOS lt { /UpM HLtOS def } if % Checking margins for flglscape mode
 DnM HRtOS lt { /DnM HRtOS def } if
 LtM VDnOS lt { /LtM VDnOS def } if
 RtM VUpOS lt { /RtM VUpOS def } if
 } {
  UpM VUpOS lt { /UpM VUpOS def } if % Checking margins for portrait mode
  DnM VDnOS lt { /DnM VDnOS def } if
  LtM HLtOS lt { /LtM HLtOS def } if
  RtM HRtOS lt { /RtM HRtOS def } if
  } ifelse
% defining pagelimits and X - Y scales (Xlim Ylim)
/pglim { Dpage pop LtM RtM add sub Dpage exch pop UpM DnM add sub } def
% Defining starting point on page.
/XORI LtM def
/YORI UpM def
% Defining page-elements layout.
/XSTitl pglim pop XOriTitl 2 mul sub def
/XSBlck pglim pop def
/YSBlck pglim exch pop YSTitl BlckSp NBlck mul add YOriTitl add sub NBlck div def
/XOriBlck 0 def
/YOriBlck YOriTitl YSTitl BlckSp add add def
/XSPlot { XSBlck FLftLbl { XLftLbl sub } if FRgtLbl { XRgtLbl sub } if } def
/XOriPlot { XOriBlck FLftLbl { XLftLbl add } if } def
/Xscale XSPlot MaxNuclPage div def
/YSLine YSBlck LnTot div def
/tracksize tracksize YSLine mul def
/spcrsize spcrsize YSLine mul def
/YSFwd LnFwd YSLine mul def
/YSBth LnBth YSLine mul def
/YSRvs LnRvs YSLine mul def
/YSTck LnTck YSLine mul def
% /is2tck LnBth 0 gt LnFwd 0 gt LnRvs 0 gt and LnFwd 0 eq LnRvs 0 eq and or and def % true if must plot two tickmark lines
 /is2tck LnBth 0 gt LnFwd 0 gt LnRvs 0 gt and and def % true if must plot two tickmark lines
%%EndProcSet:   Page_Layout 1.0 0
%
%%BeginProcSet: functions 1.0 0
/min { 2 copy gt { exch } if pop } bdf 
/max { 2 copy lt { exch } if pop } bdf
/Xscm { Xscale mul } bdf /Xscme { Xscm exch } bdf
/ChkLimits { 3 copy pop 5 2 roll dup dup 5 1 roll 3 1 roll lt 3 1 roll gt or { pop false } { true } ifelse } def 
/nucdif { 2 copy exch sub } bdf
%%EndProcSet:   functions 1.0 0
%
%%BeginProcSet: text_functions 1.0 0
/sfont { findfont exch scalefont setfont } bdf
/stringheight  { gsave newpath 0 0 moveto (0) false charpath flattenpath pathbbox exch pop exch sub exch pop 0.95 mul grestore } bdf
/ct { gsave 0 translate sfont scmyk dup stringwidth pop 2 div neg stringheight 2 div moveto show grestore } bdf
/ctr { gsave 0 translate sfont scmyk dup stringwidth pop 2 div neg stringheight 1.65 mul neg moveto show grestore } bdf
%%EndProcSet:   text_functions 1.0 0
%
%%BeginProcSet: painting_functions 1.0 0
/scmyk { setcmykcolor } bdf
/dotted { [ 1 ] 0 setdash } def
/bbox { 4 copy 3 1 roll exch 6 2 roll 8 -2 roll moveto lineto lineto lineto closepath } bdf
/tbbox { tflg { gsave setlinewidth scmyk stroke grestore } { pop pop } ifelse } def
/scolor { colordict exch get exec scmyk } bdf
%
colordict begin % adding definitions and functions
 /lup { /ku xdf /yu xdf /mu xdf /cu xdf } bdf
 /lmd { /km xdf /ym xdf /mm xdf /cm xdf } bdf
 /ldn { /kd xdf /yd xdf /md xdf /cd xdf } bdf
 /load2col { lup ldn /dk ku kd sub def /dy yu yd sub def /dm mu md sub def /dc cu cd sub def } bdf
 /load3col { lup lmd ldn /uk ku km sub def /uy yu ym sub def /um mu mm sub def /uc cu cm sub def /dk km kd sub def /dy ym yd sub def /dm mm md sub def /dc cm cd sub def } bdf
 /col2 { 2 dict begin /p xdf /pcd { p mul add } bdf cd dc pcd md dm pcd yd dy pcd kd dk pcd scmyk end } bdf
 /col3 { 3 dict begin /p xdf /pcd { p 2 mul mul add } bdf /pcu { p 0.5 sub 2 mul mul add } bdf p 0.5 le { cd dc pcd md dm pcd yd dy pcd kd dk pcd } { cm uc pcu mm um pcu ym uy pcu km uk pcu } ifelse scmyk end } bdf
 /rainbow { 1 dict begin /p xdf p 0.1 le { p 0.2 div 0.5 add 1 0 0 scmyk } { p 0.4 le { 1 1 p 0.1 sub 0.3 div sub 0 0 scmyk } { p 0.6 le { 1 0 p 0.4 sub 0.2 div 0 scmyk } { p 0.8 le { 1 p 0.6 sub 0.2 div sub 0 1 0  scmyk } { 0 p 0.8 sub 0.2 div 1 0 scmyk } ifelse } ifelse } ifelse } ifelse end } bdf
end % colordict
%%EndProcSet:   painting_functions 1.0 0
%
%%BeginProcSet: tickmarks 1.4 0
% Rule.ps ---> rules and scales
/tmdct 22 dict def tmdct begin
 /ShowGrid 0 def % 0 - none : 1 - MinTicks : 2 - MaxTicks : 3 - Both
 /Gridup true def /Griddn true def /flgup true def
 /TkMrkHW TkMrkW  2 div def
 /TkMrkDW TkMrkW 10 div def
 /TkFont { TkMrkHW /Helvetica } def
 /MaxWidthT { gsave MaxNuclPage 10 string cvs TkFont sfont stringwidth pop 2 mul grestore } bdf
 /CheckCloser { 3 copy pop MaxWidthT sub 3 1 roll MaxWidthT add 3 1 roll dup dup 5 1 roll 3 1 roll lt 3 1 roll gt or 4 1 roll 3 copy dup 3 1 roll ne 3 1 roll ne and 5 -1 roll and { pop false } { true } ifelse } bdf
 /ctextick { gsave TkFont sfont dup stringheight 2 div exch stringwidth pop 2 Xscm div neg Xscm exch 2 copy neg translate 2 mul exch 2 mul neg exch gsave 0 0 bbox BGcolor scmyk gsave tflg { FGcolor scmyk } if 2 setlinewidth stroke grestore fill grestore 0 0 moveto FGcolor scmyk show grestore } bdf
 /bltextick { gsave TkFont sfont dup stringwidth pop 2 Xscm div neg Xscm TkMrkHW 2 copy flgup { TkMrkDW add translate } { 2 mul translate 1 -1 scale } ifelse exch 2 mul neg exch gsave 0 0 bbox BGcolor scmyk gsave tflg { FGcolor scmyk } if 2 setlinewidth stroke grestore fill grestore 0 0 moveto FGcolor scmyk show grestore } bdf
 /tonormtick { 0 eq { dup dup 0 ne { MinTick mod } if sub exch dup dup 0 ne { MinTick mod } if sub exch } { dup dup 0 ne { MaxTick mod } if sub exch dup dup 0 ne { MaxTick mod } if sub exch } ifelse } bdf
 /Mkg { 0 0 moveto lineto FGcolor scmyk dotted stroke } bdf
 /MkVGrid { gsave setlinewidth Gridup flgup not { not } if { 0 up Mkg } if Griddn flgup not { not } if { 0 down neg Mkg } if  grestore } bdf
 /MkAtick { setlinewidth 0 TkMrkHW neg moveto 0 TkMrkHW lineto FGcolor scmyk stroke } bdf
 /MkBtick { gsave dup Xscm 0 translate ShowGrid 2 eq ShowGrid 3 eq or { 0.25 MkVGrid } if 1 MkAtick CheckCloser { 10 string cvs ctextick } if grestore } bdf
 /MkCtick { setlinewidth 0 0 moveto 0 TkMrkHW 3 -1 roll { TkMrkDW sub } if lineto FGcolor scmyk stroke } bdf
 /MkDtick { gsave dup Xscm 0 translate CheckCloser { 10 string cvs bltextick } if ShowGrid 2 eq ShowGrid 3 eq or { 0.25 MkVGrid } if false 1 MkCtick grestore } bdf
 /baseline { gsave Xscm TkMrkDW moveto Xscm TkMrkDW lineto TkMrkDW 2 mul setlinewidth FGcolor scmyk stroke grestore } bdf
 /r { /Gridup true def /Griddn true def /flgup true def 0 exch translate gsave 0 translate 1 -1 scale 5 { 2 copy } repeat pop neg Xscm 0 translate 0 tonormtick MinTick exch { ChkLimits { gsave Xscm 0 translate 0.25 MkAtick ShowGrid 1 eq ShowGrid 3 eq or { 0 MkVGrid } if grestore } if } for 1 tonormtick MaxTick exch { ChkLimits { MkBtick } if } for 2 { dup dup 0 ne { MaxTick mod } if 0 ne { MkBtick } { pop } ifelse } repeat grestore } bdf
 /x { 6 { 2 copy } repeat pop neg Xscm 0 translate baseline 0 tonormtick MinTick exch { ChkLimits { gsave Xscm 0 translate true 0.25 MkCtick ShowGrid 1 eq ShowGrid 3 eq or { 0 MkVGrid } if grestore } if } for 1 tonormtick MaxTick exch { ChkLimits { MkDtick } if } for 2 { dup dup 0 ne { MaxTick mod } if 0 ne { MkDtick } { pop } ifelse } repeat } bdf 
 /s { /Gridup false def /Griddn true def /flgup true def 0 exch TkMrkW add translate gsave 0 translate 1 -1 scale x grestore } bdf
 /z { /Gridup true def /Griddn false def /flgup false def 0 exch translate gsave 0 translate 1 1 scale x grestore } bdf
end % tmdct
%%EndProcSet:   tickmarks 1.4 0
%
%%BeginProcSet: objects 1.1 0
/shpdct 46 dict def shpdct begin
 /ShFont { TkMrkW 2 div /Helvetica } def
 /LY { tracksize 0.75 mul } bdf
 /trackbb { LY 0.55 mul } bdf
 /RWTS { LY 1.5 mul } bdf
 /mtrx matrix def
% Shapes......
 /cpt { moveto { lineto } repeat closepath } bdf
 /hline { 0 0 moveto 1 0 lineto closepath } bdf
 /fline { hline trackbb sc mul setlinewidth } bdf
 /harw {  0.0    0.0  0.0   -1.0  0.745 -1.0  0.745 -1.1  0.75 -1.1  5  1.0  0.0  cpt } bdf
 /farw {  0.75   0.6  0.745  0.6  0.745  0.5  0.0    0.5  0.0  -0.5
          0.745 -0.5  0.745 -0.6  0.75  -0.6                         8  1.0  0.0  cpt } bdf
 /hend {  0.25   0.0  0.0   -1.0  1.0   -1.0                         3  1.0  0.0  cpt } bdf
 /fend {  0.0    0.5  1.0    0.5  1.0   -0.5  0.0 -0.5               4  0.25 0.0  cpt } bdf
 /hbox {  1.0    0.0  1.0   -1.0  0.0   -1.0                         3  0.0  0.0  cpt } bdf
 /fbox {  0.0    0.5  1.0    0.5  1.0   -0.5                         3  0.0 -0.5  cpt } bdf
 /hsgl {  0.25   0.0  0.0   -1.0  0.745 -1.0  0.745 -1.1  0.75 -1.1  5  1.0  0.0  cpt } bdf
 /fsgl {  0.75   0.6  0.745  0.6  0.745  0.5  0.0    0.5  0.25  0.0
          0.0   -0.5  0.745 -0.5  0.745 -0.6  0.75  -0.6             9  1.0  0.0  cpt } bdf
 /hcir {  0.5   -0.5  0.5    0   360 arc closepath } bdf
 /fcir {  0.5    0.0  0.5    0   360 arc closepath } bdf
% ......Shapes
 /getfrcol { dup 0 eq { pop frm0 } { dup 1 eq { pop frm1 } { 2 eq { frm2 } if } ifelse } ifelse } bdf
 /cmdln { 0 moveto sqdif 2 div 0 lineto scmyk stroke } bdf
 /lnfill { gsave RWTS setlinewidth sqdif 2 div cmdln 0 cmdln grestore } bdf
 /frmfill { frm getfrcol rmd getfrcol lnfill } bdf
 /rnbfill { 1 dict begin gsave /incr sqdif 100 div def 0 incr sqdif { dup dup incr add 0 exch 0 moveto lineto dup 0 gt { sqdif div } if rainbow RWTS setlinewidth stroke } for grestore end } bdf 
% /getvar { /ftlbl xdf /sc xdf /rmd xdf /frm xdf strnd (-) eq { exch } if 2 copy exch sub /sqdif exch Xscm def /sqdsc sqdif Xscale div def /seqend exch Xscm def /seqori exch Xscm def /cmod xdf } bdf
 /getvar { /ftlbl xdf /cmod xdf /sc xdf /rmd xdf /frm xdf nucdif /sqdif exch Xscm def /sqend exch def /sqori exch def /seqend sqend Xscm def /seqori sqori Xscm def } bdf
 /setcolmod { colordict begin cmod cvx exec dup 1 eq { pop scmyk fill } { dup 2 eq { pop lnfill } { dup 3 eq { pop frmfill } { dup 4 eq { pop rnbfill } { 0 eq { BGcolor scmyk fill } if } ifelse } ifelse } ifelse } ifelse end } bdf
 /shwpos { flpos { sqend sqori strnd (-) eq { exch } if sqdif exch 0 2 { gsave trackbb 1 mul moveto 10 string cvs gsave strnd (-) eq { -1 -1 scale -45 } { 45 } ifelse rotate ShFont sfont FGcolor scmyk show grestore grestore } repeat } if } bdf
 % /frshared { strnd (-) eq { -1 -1 scale } if 0.5 setlinewidth gsave /svmtrix mtrx currentmatrix def LY sc mul sqdif flglscape { exch } if scale cvx exec svmtrix setmatrix gsave FGcolor scmyk stroke grestore clip setcolmod grestore shwpos pop } bdf
 /frshared { strnd (-) eq { -1 -1 scale } if 0.5 setlinewidth gsave /svmtrix mtrx currentmatrix def sqdif LY sc mul scale cvx exec svmtrix setmatrix gsave FGcolor scmyk stroke grestore clip setcolmod grestore shwpos pop } bdf
 /f { gsave getvar strnd (-) eq { seqend } { seqori } ifelse 0 translate frshared grestore } bdf
 /gpuline { gsave gplmod 1 eq { 0 0 moveto grdif 0 rlineto /red scolor 1 setlinewidth stroke } if grestore } bdf
 /shgplbl { FgpLbl { gsave grori trackbb strnd (-) ne { neg } if translate gplmod 0 gt { gpuline } if grlbl FGcolor 8 /Helvetica grdif 2 div strnd (-) eq { ct } { ctr } ifelse grestore } if } bdf 
 /g_end { end exit } bdf 
%
% functions for vectors-like data-sets
 /resizetrack tracksize 0.95 mul def
 /vtoffset vectoffset 2 div Xscm def
 /clrselc { colordict begin dup 2 eq { pop load2col /clrproc { {col2} } def } { dup 3 eq { pop load3col /clrproc { {col3} } def } { dup 0 eq { pop white black load2col /clrproc { {col2} } def } { dup 4 eq { pop /clrproc { {rainbow} } def } { 1 eq { white 8 4 roll load2col /clrproc { {col2} } def } if } ifelse } ifelse } ifelse } ifelse } bdf % no end for closing dict because grdct must be closed by calling function
 /v { gsave Xscm dup vtoffset sub exch vtoffset add 0 moveto 0 lineto resizetrack setlinewidth clrproc exec stroke grestore } bdf
 /v_end { end exit } bdf   % end is for grdct dict
end % shpdct
%%EndProcSet:   objects 1.1 0
%
%%BeginProcSet: blocks 1.0 0
/blckdct 30 dict def blckdct begin
 /Y 0 def
% /pbox { XOriBlck YOriBlck XSBlck YSBlck bbox clip tflg not { newpath } { 1 setlinewidth FGcolor scmyk stroke } ifelse } bdf
 /pbox { XOriBlck 5 sub 0 XSBlck 10 add YSBlck bbox clip tflg not { newpath } { 1 setlinewidth FGcolor scmyk stroke } ifelse } bdf
 /bline { Fbline { gsave FGcolor scmyk 0.25 setlinewidth 0 0 moveto XSPlot 0 lineto stroke grestore } if } bdf
 /shsrclbl { FLftLbl { gsave srclbl FGcolor 10 /Courier XLftLbl 2 div neg ct grestore } if } bdf
 /srcbndbox { tracksize spcrsize add YSLine mul dup neg -5 exch XSPlot 10 add  4 -1 roll bbox clip tflg not { newpath } { 1 setlinewidth FGcolor scmyk stroke } ifelse } bdf
% /source { /strnd xdf /nxtspacer exch spcrsize mul def 2 dict begin /Yscl exch tracksize mul 2 div def /srclbl xdf /Y Y nxtspacer add Yscl add def 0 Y translate gsave XOriPlot 0 translate gsave 1 -1 scale bline shsrclbl srcbndbox blckori Xscm neg 0 translate } bdf
 /source { /strnd xdf /nxtspacer exch spcrsize mul def /Yscl exch tracksize mul 2 div def /srclbl xdf /Y Y nxtspacer strnd (.) eq { 2 div } if add Yscl add def gsave 0 Y translate gsave XOriPlot 0 translate gsave 1 -1 scale bline shsrclbl srcbndbox blckori Xscm neg 0 translate } bdf
 /s_end { grestore grestore grestore /Y Y Yscl add strnd (.) eq { nxtspacer 2 div add } if def } bdf
%
 /gp { gsave shpdct begin nucdif /grdif exch Xscm def /grend exch Xscm def /grori exch Xscm def /gplmod xdf /grlbl xdf shgplbl { currentfile token { exec } { exit } ifelse } loop grestore } bdf
%
 /ov { gsave vctdct begin exch Xscm exch translate { currentfile token { exec } { exit } ifelse } loop end grestore } bdf
%
 /tm { gsave tmdct begin /ShowGrid xdf exec end grestore } bdf
 /shwtck { /down   YSFwd YSTck 1.5 mul add def
           /up     YSRvs def
           blckori blckend XOriPlot 0 {s} 2 tm
           blckori blckend XOriPlot YSTck YSFwd 0 gt { YSFwd add } { YSBth add } ifelse {r} 0 tm
  is2tck { blckori blckend XOriPlot YSTck 2 mul YSFwd add YSBth add {r} 0 tm } if
           blckori blckend XOriPlot YSBlck TkMrkW sub {z} 2 tm
           } bdf
%
 /ChangeStrand { /Y Y YSTck def } bdf
 /b_end { end grestore } bdf
end
%%EndProcSet:   blocks 1.0 0
%
%%BeginProcSet: main_function_calls 1.0 0
%
/block { blckdct begin /blcknum exch 1 sub def /blckend xdf /blckori xdf /YB YOriBlck YSBlck blcknum mul add BlckSp blcknum mul add def gsave 0 YB translate pbox shwtck /Y 0 def } bdf
%
%%EndProcSet:   main_function_calls 1.0 0
%
%%EndProlog
%
%%BeginSetup
%
% initgraphics
% true setpacking
true setstrokeadjust
0.125 setlinewidth
0 setlinejoin
0 setlinecap
%
%%EndSetup
%
@@@MAINProcs@@@
} 
#### End of MAINPSPROCS function

##############################################################
####################### PROGRAM FUNCTIONS ####################
#
# Testing parameters passed by User: Colors.
#
CheckColor () {
  gawk 'BEGIN{
    color=ARGV[1]
    if (color!~/^BG$|^FG$|^black$|^white$|^(very)?(light|dark)?(grey|green|(sky)?blue|cyan|violet|red|orange|yellow|brown)$/) {
      printf "\n<<<<ERROR>>>> \" %s \" is not a defined color.\n", color | "cat 1>&2"
      printf "              Default \" black \" is asigned to option.\n" | "cat 1>&2"
      printf "              You can choose one of this colors:\n" | "cat 1>&2"
      print ARGV[3] | "cat 1>&2"
      print "" | "cat 1>&2"
      color=ARGV[2]
      }
    print color
    ARGV[1]=ARGV[2]=ARGV[3]=""
    }' $1 $2 "$COLORS"
  return 0
}

#
# Testing parameters passed by User: Integer Numbers.
#
CheckInt () {
  if [ `expr $1 : '[0-9]*'` -eq `expr $1 : '.*'` ]
    then echo "1"; return 0
    else 
      echo "<<<<ERROR>>>> \" $1 \" is not an integer value." 1>&2
      echo "              You must especify an integer value to -$W_OPTION" 1>&2
      echo "              Program will take value from defaults..." 1>&2
      echo "" 1>&2
      echo "0";return 1
    fi
  return 1
}

#
# Testing parameters passed by User: Page Sizes.
#
chkpagesize () {
  pagesizes | gawk `BEGIN{
    pg=ARGV[1]; ARGV[1]=""; ec=0 }
    pg==$1 { ec=1; ps=sprintf("%s,%s,%s",$1,$2,$3) }
    END{ if (ec) { print ps };
         else { print "a4,595,842" }` $1 -
  return 0
}

#
# Testing if exist a File.
#
ExistCustomfile () {
  if [ ! -f "$1" ]
    then echo "0"
      echo "Report: Default Custom File does not exist." 1>&2
      return 0
    else echo "1" # exist_default_customfile
      echo "Warning: Default Custom File exist." 1>&2
      echo "          Custom_Filename: $1" 1>&2
      return 1
    fi
}

ExistFile () {
  if [ ! -f "$1" ]
    then echo "0"
      echo "Warning: File "$1" is empty or does not exist." 1>&2
      return 1
    else echo "1" # exist_file
      echo "Report: File "$1" exist, included as a gff file." 1>&2
      return 0
    fi
}

###################################################################
################## MAIN GFF2PS SHELL SCRIPT #######################
#
###################################################################
################## Choosing Options for GFF2PS ####################
#
# Resetting default program variables.
#
Defaults

#
# Checking if default custom file exists
#  else switch on flag to create.
#
echo "" 1>&2
echo "Report: You have typed the following command line:" 1>&2
echo "" 1>&2
echo $CMDLine 1>&2
echo "" 1>&2

#
# When no options, no parameters and 
#  no inputstream are given, print USAGE.
#
if [ $# -eq 0 ] 
  then
    echo; echo $USAGE; echo; exit 1
  fi

#
# Asking for Help, output it to screen. 
#
case $1 in
  -h) Help; exit 2;;
  -H) echo; echo $PROGRAM" : Option Definition Help."; echo;
      if [ $# -gt 1 ]; 
        then shift; fi;
      for temp in $@;
        do ShowHelpLine $temp; done;
      exit 2;;
  esac

#
# Processing all options and parameters passed to program.
#
while getopts :dD:C:vS:pP:B:N:bHh W_OPTION
  do
    case $W_OPTION in
      H|h) Help; exit 2;;
      d) v04_1=1;;                    # create_default_customfile (.gff2psrc) or rewrite
      D) v04_1=1;                     # create_default_customfile or rename_it if exist
         v03="$CFDIR/$OPTARG";;
      C) if [ ! -f $CFDIR/$OPTARG ];    # load_customfile customfile_name
           then v01=0;
             echo "Error: Custom File $OPTARG does not exist...Not Loaded." 1>&2 ;
           else v01=1;
	         echo "Report: Adding $OPTARG Custom File to Default Custom File." 1>&2 ;
             v02="$CFDIR/$OPTARG";
           fi;;
      v) v05=1;;                        # print_report
      S) v07=$OPTARG;                   # page_bbox
         v12=`chkpagesize $v07`;;  
      p) v06="Portrait";;               # page_orientation
      P) v08=$OPTARG;;                  # page_number
      B) v09=$OPTARG;;                  # blocks_x_page
      N) v10=$OPTARG;;                  # nucleotides_x_line
      b) v11=0;;                      # show_blocks_top-bottom
       :) ShowHelpLine $1; exit 2;;
      \?) ShowHelpLine $1; exit 2;;
    esac # case $W_OPTION
  done   # while getopts

#
# Shifting all options tested before,
# without removing files passed to shell...
#
 incr=1
 while [ $OPTIND -gt $incr ]
   do shift; incr=`expr $incr + 1`; done

 GFF_INPUT_FILES=""; ck=0
 for files in $@
   do
     if [ `ExistFile ./$files` ]  # $CFDIR/
       then 
         if [ $ck -eq 1 ] 
           then
              GFF_INPUT_FILES=$GFF_INPUT_FILES" "
           fi
         GFF_INPUT_FILES=$GFF_INPUT_FILES./$files;  # $CFDIR/
         shift; ck=1;
       fi
   done

#
# Defining PLOToptions STRING for GNU awk programs.
#
 v04=`ExistCustomfile "$v03"`
   P="BACKGROUND_COLOR:="$bgcolor"::FOREGROUND_COLOR:="$fgcolor"::"$n04_1":="$v04_1"::"
 P=$P$n01":="$v01"::"$n02":="$v02"::"$n03":="$v03"::"$n04":="$v04"::"$n05":="$v05"::"
 P=$P$n06":="$v06"::"$n07":="$v07"::"$n08":="$v08"::"$n09":="$v09"::"$n10":="$v10"::"
 P=$P$n11":="$v11"::"$n12":="$v12"::"
 P=$P$m01":="$c01"::"$m02":="$c02"::"$m03":="$c03"::"$m04":="$c04"::"$m05":="$c05"::"
 P=$P$m06":="$c06"::"$m07":="$c07"::"$m08":="$c08"::"$m09":="$c09"::"$m10":="$c10"::"
 P=$P$m11":="$c11"::"$m12":="$c12"::"$m13":="$c13"::"$m14":="$c14"::"$m15":="$c15"::"
 P=$P$m16":="$c16"::"$m17":="$c17"::"$m18":="$c18"::"$m19":="$c19"::"$m20":="$c20"::"
 P=$P$m21":="$c21"::DCF:=$CFDIR/.gff2psrc"
 PLOToptions=$P
 if [ $v05 -eq 1 ]
   then
     echo "" 1>&2
     echo "********************************************" 1>&2
     echo ">>>>> Option String Passed to Program <<<<<<" 1>&2
     echo "********************************************" 1>&2
     echo "" 1>&2
     echo $PLOToptions 1>&2
     echo "" 1>&2
   fi

###################################################################
############### CONVERTING GFF TO POSTSCRIPT ######################
###################################################################
#
# PostScript Header.
#
MAINPSHEADER

#
# Main GFF2PS GNU awk Program...
#
# (cat <<'@@@EndPROGRAM@@@') |
# @@@EndPROGRAM@@@
# gawk -v CUSTOMFILE=$v03 -f - "$@"
#
(echo "$PLOToptions"; MAINPSPROCS) |
gawk 'BEGIN{
############ INITIALITATION ############
# gff data structure
  seqname  = 1;
  source   = 2;
  feature  = 3;
  start    = 4;
  end      = 5;
  score    = 6;
  strand   = 7;
  frame    = 8;
  group    = 9;
# gff strand codification
  strands["+"]=strands["."]=strands["-"]=1;
  wstr[1]="+";wstr[2]=".";wstr[3]="-";
# Loading PSMainProgram. Line 0 is the Command Line Parameter String.
  psline=0;
  while ((getline < ARGV[1])>0) { PSMAIN[psline++]=$0 };
  ARGV[1]="";
############## Defining pre-variables by CommandLine ############ 
 npar=split(PSMAIN[0],parm,"::");
 for (r=1;r<=npar;r++) {
   split(parm[r],elem,":=");
   if (elem[2]!="##dflt##") {
     if (elem[1]~/COLOR\$/) {
       ecolor=elem[2];
       if (ChkColor(ecolor)) {
         if (ecolor~/^BG\$|(##DEFAULT##)/) elem[2]=Var["BACKGROUND_COLOR"]
         else if (ecolor~/^FG\$/) elem[2]=Var["FOREGROUND_COLOR"] } # if ChkColor
       else elem[2]=Var["BACKGROUND_COLOR"] } # if elem[1]
     Var[elem[1]]=elem[2] } # if elem[2]
   } # for
  delete PSMAIN[0]
  for (v in Var) printf "VAR: %-25s :: Value: %s\n", v, Var[v] | "cat 1>&2"
# Layout Properties
  Default["load_customfile"]=Var["load_customfile"];  # in this case we need to force variables.
  Default["customfile_name"]=Var["customfile_name"];  # in this case we need to force variables.
  Default["customfile_name_default"]=Var["DCF"];      # DCF="$CFDIR/.gff2psrc"
  Default["page_size"]="a4";               # Var["page_size"]
  Default["page_bbox"]="a4,595,842";       # Var["page_bbox"]
  Default["page_orientation"]="Landscape"; # Var["page_orientation"] : Landscape (default), Portrait.
  Default["margin_left"]="1cm";            # cm, in, pt
  Default["margin_right"]="1cm";           #
  Default["margin_upper"]="1cm";           #
  Default["margin_bottom"]="1cm";          #
  Default["foreground_color"]="FGcolor";  #
  Default["background_color"]="BGcolor";  #
  Default["nucleotides_x_line"]=0;     # Var["nucleotides_x_line"] : Default=0,gets the seqlenght from data
  Default["blocks_x_page"]=1;          # Var["blocks_x_page"] : Default=1
  Default["show_blocks_top-bottom"]=1; # Var["show_blocks_top-bottom"] : 1->TopBottom, 2->LeftRight.
  Default["page_number"]=1;            # Var["page_number"] : Default=1
  Default["strand_show_forward"]="on";     #
  Default["strand_show_reverse"]="on";     #
  Default["strand_show_independent"]="on"; #
# General Properties
  Default["text_color"]=Default["foreground_color"];
  Default["default_scale_width"]="0.25cm";         #
  Default["default_track_width"]="1cm";            #
  Default["default_track_spacing_width"]="1cm";    #
  Default["default_block_spacing_width"]="0.25cm"; #
  Default["label"]="none";
  Default["frame0_color"]="blue";
  Default["frame1_color"]="red";
  Default["frame2_color"]="green";
  Default["show_inner_scale"]=1;
  Default["show_outer_scale"]=1;
# Features Properties
  FT_PROP["fill_shape_mode"]="default"; # none(BGcolor), default(FGcolor 1color), 1_color, 2_color, frame-remainder, rainbow
  FT_PROP["fill_vector_mode"]="default"; # none(0 BGcolor grad), default(0 black grad), rainbow(1), 1_color(BGcolor color 2), 2_color(color1 color2 2), 3_color(col1 col2 col3 2)
  FT_PROP["label"]="default"; # none , default , "user-def"
  FT_PROP["color"]=Default["foreground_color"]; # 1color(color),2color(color..color),3color(color..color..color)
  FT_PROP["shape"]="box"; #box, arrow, end_arrow, circle # still not implemented: vector, spike, block
  FT_PROP["vert_align"]="baseline"; #center,baseline # still not implemented: reverse
  FT_PROP["layer"]=0;     # now is implemented, first sorting for feature lines is made on FT_PROP["layer"]
  FT_PROP["join"]="on";
  FT_PROP["show"]="on";
# Group Properties
  GR_PROP["label"]="default";        # none , default , "user-def"
  GR_PROP["group_line"]="default";   # none , default (red line) , ...
  GR_PROP["range"]="0:1";            # range of lower-upper scores
  GR_PROP["vert_align"]="center"; # center or baseline
  GR_PROP["join_align"]="center";
  GR_PROP["join_color"]=Default["foreground_color"];
  GR_PROP["join_linetype"]="solid";
  GR_PROP["join_show"]="off";
# Lines (Method-Source) Properties
  SO_PROP["label"]="default";     # none , default , "user-def"
  SO_PROP["vert_align"]="center"; # center or baseline
  SO_PROP["baseline_align"]="center";
  SO_PROP["baseline_color"]=Default["foreground_color"];
  SO_PROP["baseline_linetype"]="dotted";
  SO_PROP["baseline_show"]="off";
  SO_PROP["bbox_color"]=Default["foreground_color"];
  SO_PROP["bbox_show"]="off";
  SO_PROP["track_scale"]=1;
  SO_PROP["track_spacing_scale"]=0.5;
  SO_PROP["rule_scale"]="nucleotide";
  SO_PROP["rule_rel"]="none";
  SO_PROP["rule_abs"]="none";
# Data for upper-case to lower-case function #lcase()#
 CM["A"]="a";CM["B"]="b";CM["C"]="c";CM["D"]="d";CM["E"]="e";
 CM["F"]="f";CM["G"]="g";CM["H"]="h";CM["I"]="i";CM["J"]="j";
 CM["K"]="k";CM["L"]="l";CM["M"]="m";CM["N"]="n";CM["O"]="o";
 CM["P"]="p";CM["Q"]="q";CM["R"]="r";CM["S"]="s";CM["T"]="t";
 CM["U"]="u";CM["V"]="v";CM["W"]="w";CM["X"]="x";CM["Y"]="y";
 CM["Z"]="z";# CM["Ñ"]="ñ";CM["Ç"]="ç";
# Initialization for some vars.
 BigLINE="########################################";
 MINSCORE=0.10;
 MAXSCORE=1.00;
 FIRST_POS=0;
 LAST_POS=0;
 nordcnt=ordcnt=0;
#
 if (Var["print_report"])
  printf "\n%s\nInput File...\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"

}
{ ############ READING .GFF FILES  ############
# skips those comment lines (starting with "#") or empty lines
  is_EOF=0;
  while ($0~/^(\#)+/ || NF==0 ) { 
    if (Var["print_report"]) { printf "%10s :: Not Read :: %s\n", NR, $0 | "cat 1>&2" };
    if (getline<=0) { is_EOF=1; break };
    }; # while
 if (!is_EOF) {
# Printing Input Lines
  if (Var["print_report"]) { printf "%10s : %s\n", NR, $0 | "cat 1>&2" };
# getting source order from file...
  if (($strand=="+" || $strand=="-") && !($source in sources)) {
    order["strand",ordcnt]=$source; ordcnt++ } # order for sources input.
  else if ($strand=="." && !($source in sources)) {
    order["none",nordcnt]=$source; nordcnt++ };
# read gff element within source and strand
  sources[$source]++;                       # field 2 (source) counter
  if ($group=="") $group=".";               # empty group defined as default (none==".")
  GP_ary[$group]++;                         # field 9 (group) counter
  $feature=lcase($feature);
  FT_ary[$feature]++ ;                       # field 3 (gff-feature) counter
  n[$source,$strand]++ ;                     # elements per source and strand
  element[$source,$strand,n[$source,$strand],feature] = $feature; 
  element[$source,$strand,n[$source,$strand],start]   = $start;
  element[$source,$strand,n[$source,$strand],end]     = $end;
  element[$source,$strand,n[$source,$strand],frame]   = $frame;  
  element[$source,$strand,n[$source,$strand],score]   = $score;  
  element[$source,$strand,n[$source,$strand],group]   = $group; 
  if (NF>group) {
    for (i=(group+1);i<=NF;i++) {
      if ($i~"Label") element[$source,$strand,n[$source,$strand],$i]= $(i+1);  
      } # for i
    } # if NF
  if (FIRST_POS>$start) FIRST_POS=$start;
  if (LAST_POS<$end) LAST_POS=$end;
# recompute scores between MINSCORE and MAXSCORE
  if ($score < MINSCORE) {
    element[$source,$strand,n[$source,$strand],score]=MINSCORE }
  else {
    if ($score > MAXSCORE) element[$source,$strand,n[$source,$strand],score]=MAXSCORE }
# place gff element in sort array by acceptor position
  ns=n[$source,$strand]-1;
  while ($start < element[$source,$strand,S[$source,$strand,ns],start]) {
    S[$source,$strand,ns+1]=S[$source,$strand,ns]; ns-- } # while
  S[$source,$strand,ns+1]=n[$source,$strand]
  } # if (!is_EOF)
 }  # Main Loop END
END{
# Printing elements sorted
  if (Var["print_report"]) {
   printf "\n%s\ngff elements are sorted...\n%s\n",BigLINE,BigLINE | "cat 1>&2"
   for (sc in sources) 
    for (s in strands) {
      printf "\nSOURCE: %s\nSTRAND: %s\n",sc,s | "cat 1>&2"
      if (n[sc,s]>0) {
        for (i=1;i<=n[sc,s];i++)
          printf "%10s %s\n", S[sc,s,i],showelemS(sc,s,S[sc,s,i]) | "cat 1>&2"
        }
      else
        printf "%10s This block is empty ##\n", "##" | "cat 1>&2"
      }
   close("cat 1>&2")
   }
########## Defining Object Properties ##########
# Variable definition hierarchy:
# Program Defaults < Default Custom File < Custom File < Command Line.
  CreateProps(0)
  ECF=0
  if (Var["exist_default_customfile"]) { # Modifying Defaults with default custom file
    if (Var["print_report"]) printf "\n%s\nReading Default Custom File...\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    RCFile(Var["customfile_name_default"])
    ECF=1
    }
  if (Default["load_customfile"]) { # Modifying Defaults with custom file
    if (Var["print_report"]) printf "\n%s\nReading Custom File...........\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    RCFile(Default["customfile_name"])
    ECF=1
    }
  if (ECF==0) { # Modifying Defaults with Vars if no exist custom file
    if (Var["print_report"]) printf "\n%s\nModified options...........\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    for (lytdef in Default) {
      dft=Default[lytdef]
      if (dft!=Var[lytdef] && Var[lytdef]!="") Default[lytdef]=Var[lytdef]
      if (Var["print_report"]) printf "%s : Default Value=%s Custom File=%s Command-Line=%s : Using=%s\n", lytdef,dft,PLOT_LY[lytdef],Var[lytdef],Default[lytdef] | "sort | cat 1>&2"
    } # for lytdef
  }   # if ECF==0
# Calculating Page Number, Blocks and NucxLine
  PORI=Nuc_round(FIRST_POS,0) # floor
  PEND=Nuc_round(LAST_POS,1)  # ceiling
# Zoom must be defined here
  if (PORI!=0) PDIF=PEND-PORI+1
  else PDIF=PEND
  P=Default["page_number"]
  B=Default["blocks_x_page"]
  if (Default["nucleotides_x_line"]==0) {
    if (B>1 || P>1) NOFFSET=Nuc_round((PDIF/(B*P)),1)
    else NOFFSET=PDIF
    }
  else NOFFSET=Default["nucleotides_x_line"]
  if (NOFFSET>PDIF) NOFFSET=PDIF # necessary if it is defined a Zoom.
  B1= PDIF%NOFFSET!=0 ? ((PDIF-(PDIF%NOFFSET))/NOFFSET)+1 : ((PDIF-(PDIF%NOFFSET))/NOFFSET)
  P = B1%B!=0 ? ((B1-(B1%B))/B)+1 : ((B1-(B1%B))/B)
  if (Default["show_blocks_top-bottom"]) { BOFFSET=NOFFSET; POFFSET=B*NOFFSET }
  else { BOFFSET=P*NOFFSET; POFFSET=NOFFSET }
  printf "\n%s\nPostScript Page Definitions...\n%s\n",BigLINE,BigLINE | "cat 1>&2"  
  printf "\npage_number %s\nblocks_x_page %s\nnucleotides_x_line %s\nshow_blocks_top-bottom %s\n",Default["page_number"],Default["blocks_x_page"],Default["nucleotides_x_line"],Default["show_blocks_top-bottom"] | "cat 1>&2"  
  printf "\nPORI %s\nPEND %s\nP %s\nB %s\nNOFFSET %s\nBOFFSET %s\n\n",PORI,PEND,P,B,NOFFSET,BOFFSET | "cat 1>&2"  
# Calculating Block scale factor.
  StrSize=0; NStSize=0; # for strands...
  aS=calcpt(Default["default_track_width"]);
  bS=calcpt(Default["default_track_spacing_width"]);
  for (ws in order) {
    split(ws,wsb,SUBSEP)
    if (wsb[1]=="strand")
      StrSize=StrSize+(aS*PLOT_FT[order[ws],":","track_scale"])+(bS*PLOT_FT[order[ws],":","track_spacing_scale"])
    else if (wsb[1]=="none")
      NStSize=NStSize+(aS*PLOT_FT[order[ws],":","track_scale"])+(bS*PLOT_FT[order[ws],":","track_spacing_scale"])
    }
  if (OnOff(Default["strand_show_forward"])) StrSizeFwd=StrSize; else StrSizeFwd=0
  if (OnOff(Default["strand_show_reverse"])) StrSizeRvs=StrSize; else StrSizeRvs=0
  if (!OnOff(Default["strand_show_independent"])) NStSize=0
  cpsc=calcpt(Default["default_scale_width"])
  SclSize=2*cpsc # for scales...
  if (OnOff(Default["show_inner_scale"])) {
   if (StrSizeFwd>0 && (NStSize>0 || StrSizeRvs>0)) SclSize=SclSize+cpsc
   if (NStSize>0 && StrSizeRvs>0) SclSize=SclSize+cpsc
  }
  BSize=StrSizeFwd+StrSizeRvs+NStSize+SclSize # (points)
# PostScript Variables Setup.
  defPSvars()
# PostScript Main Procs.
  for (i=1;i<psline;i++) print PSMAIN[i]; 
# Pages MAIN LOOP.
  for (pages=1;pages<=P;pages++) {
    BORI=PORI
    startPSpage(pages,pages)  # PostSCript PageSetup.
    for (blocks=1;blocks<=B;blocks++) {
      BEND=BORI+NOFFSET
      printf "%%\n%% Block Num: %s Page: %s\n%%\n",blocks,pages
      printf "%s %s %s block\n", BORI, BEND, blocks
# make groups. assumes elements sorted by increasing acceptor position
  cntstr_fwd=cntstr_bth=cntstr_rvs=0
  printf "\n%s\nPostScript Code...\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
  for (sc in sources) {
    for (s in strands) {
      for (i=1;i<=n[sc,s];i++) {
        start_=element[sc,s,S[sc,s,i],start];
        end_=element[sc,s,S[sc,s,i],end];
	    tgr=element[sc,s,S[sc,s,i],group];
	    if (!grouping[sc,s,tgr,start]) {
	      grouping[sc,s,tgr,start]=element[sc,s,S[sc,s,i],start];
	      ng[sc,s]++;
	      group_[sc,s,ng[sc,s]]=tgr
          }
        if (grouping[sc,s,tgr,end]<element[sc,s,S[sc,s,i],end])
          grouping[sc,s,tgr,end]= element[sc,s,S[sc,s,i],end];
     # only goes on when features are inside page limits.
       if (ChkLimits(start_,BORI,end_,(BEND))) {
        feature_=element[sc,s,S[sc,s,i],feature];
        score_=element[sc,s,S[sc,s,i],score];
     # for gene mode. try to recompute relative frame and remainder
        frame_[sc,s,tgr]= element[sc,s,S[sc,s,i],frame];
        if (feature_=="First" || feature_=="Single") 
          frame_[sc,s,tgr]=0;
        else if (feature_=="Internal" || feature_=="Terminal" )
          frame_[sc,s,tgr]=remainder_[sc,s,tgr];
        remainder_[sc,s,tgr]=(3-(end_-(start_+frame_[sc,s,tgr])+1)%3)%3;
        printf "%s %s %s : %s \/%s %d %d %d %d %4.2f (%s) (%s) f\n", sc,s,i, PLOT_FT[feature_,":","layer"], Set_feat_Shape(feature_,sc), start_, end_, frame_[sc,s,tgr] ,remainder_[sc,s,tgr], score_, Set_feat_Clr(feature_), Plot_Lbl(feature_) | "cat 1>&2"
        grouping[sc,s,tgr,group,blocks,pages] = sprintf("%s%s \/%s %d %d %d %d %4.2f (%s) (%s) f\n", grouping[sc,s,tgr,group,blocks,pages], PLOT_FT[feature_,":","layer"], Set_feat_Shape(feature_,sc), start_, end_, frame_[sc,s,tgr] ,remainder_[sc,s,tgr], score_, Set_feat_Clr(feature_), Plot_Lbl(feature_))
        plot_group[tgr,blocks,pages]=1
       } # if ChkLimits
      }  # for i
      printf "\n" | "cat 1>&2"
    }    # for s
  }      # for sc
# PostScript Drawing strands, sources, groups, features
# make plotlines. Put non-overlapping groups into the same plotting line.
  if (Var["print_report"]) printf "\n%s\nPrinting Lines......\nPage: %s Block: %s\nNuc_Ori: %s - Nuc_End: %s\n%s\n\n",BigLINE,pages,blocks,BORI,BEND,BigLINE | "cat 1>&2"
  for (stp=1;stp<=3;stp++) { # for s in strand
    prtrule=0
    s=wstr[stp]
    if (s=="+" || s=="-") lastcnt=ordcnt
    else { lastcnt=nordcnt; prtrule=1 }
    printf "------ Source: --- Strand: %s Counter: %s\n", s, lastcnt | "cat 1>&2" 
    if (prtrule && (StrSizeFwd>0 && NStSize>0)) printf "ChangeStrand\n"
    printf "%% ------------------ Strand(%s) Begin\n",s
    for (srcord=0;srcord<lastcnt;srcord++) { # for sc in sources
      if (s=="-") { ngcnt=lastcnt-(srcord+1); sc=order["strand",ngcnt] }
      else {
        if (s=="+") sc=order["strand",srcord]
        else sc=order["none",srcord]      # (s==".")
        }
      printf "------ Source: %10s Strand: %s Counter: %s\n", sc, s, srcord | "cat 1>&2" 
      printf "(%s) %s %s (%s) source\n", Plot_Lbl(sc)"("s")", PLOT_FT[sc,":","track_scale"], PLOT_FT[sc,":","track_spacing_scale"],s
      scnt=0
      for (i=1;i<=ng[sc,s];i++) {
        scnt++
        g=group_[sc,s,i];
        for (j=1;j<=nl[sc,s] && grouping[sc,s,g,start] < endline[sc,s,j];j++);
        nl[sc,s] = j==nl[sc,s]+1 ? j : nl[sc,s];
        endline[sc,s,j]=grouping[sc,s,g,end];
    # plot group in file
        if (Var["print_report"])
          printf "GROUP : %-10s : %s %10d %10d \n", g, s, grouping[sc,s,g,start], grouping[sc,s,g,end] | " sort +6 | cat 1>&2";
        if (PLOT_FT[g,":","group_line"]=="none") gplt=0         # group without lines
        else if (PLOT_FT[g,":","group_line"]=="default") gplt=1 # group red-line
        if (plot_group[g,blocks,pages]==1) {
          printf "(%s) %s %s %s gp \n", Plot_Lbl(g), gplt, grouping[sc,s,g,start], grouping[sc,s,g,end]
          printf "%s", grouping[sc,s,g,group,blocks,pages] | "sort +0nr +6nr +2n +3nr"
          close("sort +0nr +6nr +2n +3nr")
          printf "g_end\n"
          } # if plot_group
        } # for ng[]
        printf "s_end\n"
      }   # for sources
      printf "%% ------------------ Strand(%s) End\n",s
      if (prtrule && (StrSizeRvs>0 && (StrSizeFwd>0 || NStSize>0))) printf "ChangeStrand\n"
    }     # for strands
  if (Var["print_report"]) close(" sort +6 | cat 1>&2")
# Closing Pages MAIN LOOP.
    printf "b_end\n"
    BORI+=BOFFSET
    } # for blocks
# PostSCript Page Trailer.
  printf "%%\ngrestoreall\npgsave restore\nshowpage\n%%\n%% PageEND: %s %s\n%%\n",pages,pages;
  PORI+=POFFSET
  } # for pages
# Closing PostScript document.
  split(Default["page_bbox"],bbm,",")
  if (Default["page_orientation"]=="Landscape") { bbx=bbm[2]; bby=bbm[1] }
  else { bbx=bbm[1]; bby=bbm[2] }
  # PostScript end of page (Trailer)
  printf "%%%%Trailer\n%%\n";
  printf "%%%%Pages: %s\n", P;
  printf "%%%%Orientation: %s\n", Default["page_orientation"];
  printf "%%%%BoundingBox: 0 0 %s %s\n%%%%EOF\n", bbx, bby;
# If not exist, create custom file (.gff2psrc)
  if (Var["create_default_customfile"]) { 
    printf "\n%s\nCustom File:\n%s\n\n%s\n\n", BigLINE,BigLINE, Default["customfile_name_default"] | "cat 1>&2"
    if (Var["exist_default_customfile"]) {
      printf "Warning: I am going to rewrite your Default Custom File.\n" | "cat 1>&2"
      printf "         Moving last Default Custom File to %s.old\n",Default["customfile_name_default"] | "cat 1>&2"
      system("cp -v " Default["customfile_name_default"] " " Default["customfile_name_default"] ".old")
      }
    else {
      printf "Warning: Writing Default Custom File %s.\n",Default["customfile_name_default"] | "cat 1>&2"
      }
    CreateProps(2)
    }
  else {
    printf "\n%s%s\nWarning: Defaults were taken from program defaults,\n",BigLINE,BigLINE | "cat 1>&2"
    printf "         if you want to force program to write default file,\n" | "cat 1>&2"
    printf "         you must pass the command-line option -d to the program.\n" | "cat 1>&2"
    printf "         Default custom-file name: %s\n\n",Default["customfile_name_default"] | "cat 1>&2"
    printf "         ...See help for -d and -D <filename> options...\n" | "cat 1>&2"
    printf "%s%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    }
# Object Properties Report...
  if (Var["print_report"]) {
    printf "\n%s\nObject Properties Defined....\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
    CreateProps(1) }
}
function lcase(string,    chr) { for (chr in CM) gsub(chr,CM[chr],string); return string }
function min(a,b) { if (a<=b) return a; else return b }
function max(a,b) { if (a>=b) return a; else return b }
function ChkLimits(o,O,e,E) { if (e<=O || o>=E) return 0; else return 1 } # start_,BORI,end_,BEND
function OnOff(v) { if (lcase(v)~/^1$|^(on)$|^(y)(es)?$|^(t)(rue)?$/) return 1; else return 0 }
function ChkColor(ncolor) {
 if (ncolor~/^FG$|^black$|^white$|^(very)?(light|dark)?(grey|green|(sky)?blue|cyan|violet|red|orange|yellow|brown)$/)
   return 1
 else return 0 } # also when ncolor == ^BG$|(##DEFAULT##)
function checklbl(chain) {   gsub(/[\(]/,"\\050",chain); gsub(/[\)]/,"\\051",chain);
 gsub(/[\<]/,"\\074",chain); gsub(/[\>]/,"\\076",chain); gsub(/[\/]/,"\\057",chain);
 gsub(/[\%]/,"\\045",chain); gsub(/[\[]/,"\\133",chain); gsub(/[\]]/,"\\135",chain);
 gsub(/[\{]/,"\\173",chain); gsub(/[\}]/,"\\175",chain); return chain }
function chkpo(v) { if (v=="Portrait") return "false"; else return "true" }
function chkps(v,    vv) {
 vv=lcase(v)
 if (vv~/^(a)(2|3|4|5)$|^(b)(4|5)$|^executive$|^(le)(tter|gal|dger)$|^tabloid$|^userdefined$/)
   return vv
 else return "a4" }
function chkun(st,    t,p) {
 t=lcase(st);
 if (gsub(/cm(s)?/,"",t)>0) { p=t" cm"; return p }
 else {
   if (gsub(/in(ch)?(s)?/,"",t)>0) { p=t" in"; return p }
   else {
     if (gsub(/pt(s)?/,"",t)>0) return t
     else return "1 cm" }}}
function calcpt(st,    t,p) { # return points
 t=lcase(st);
 if (gsub(/cm(s)?/,"",t)>0) { p=t*28.35; return p }
 else {
   if (gsub(/in(ch)?(s)?/,"",t)>0) { p=t*72; return p }
   else {
     if (gsub(/pt(s)?/,"",t)>0) return t
     else return 0 }}}
function Nuc_round(nm,flg,    sign,nmp,i,mlt,smm,t) { # flg=0 then floor; flg=1 then ceiling.
 sign=nm<0?-1:1;
 if (sign==-1) { nm=-nm; flg=!(flg) }
 nmp=nm; for (i=1;nmp>10;i++) { nmp=nmp/10 };
 if (nm>=1000) mlt=2; else mlt=1;
 if (flg) {
   if (nm>0) {
     if (nm%10^(i-mlt)==0) smm=0; else smm=1;
	 t=nm>=100?sign*((int(nmp*10^(mlt-1))+smm)*10^(i-mlt)):sign*100 }
   else t=0 }
 else { if (nm>0) t=nm>=100?sign*((int(nmp*10^(mlt-1)))*10^(i-mlt)):0; else t=0 }
 return t }
function Plot_Lbl(gff_feat,    lbl,vn) {
 vn=PLOT_FT[gff_feat,":","label"]
 if (vn=="none") lbl=" ";
 else if (vn=="default") lbl=gff_feat;
 else lbl=vn;
 return checklbl(lbl) }
function Set_feat_Clr(gff_feat,    clrmode,color1,color2,vn,clm) { # remaining to add vector definition colors.
 clrmode=0; color1=""; color2=""; # "none" or not defined
 k=split(PLOT_FT[gff_feat,":","color"],clm,/\.\./);
 vn=PLOT_FT[gff_feat,":","fill_shape_mode"]
 if (vn=="default") { clrmode=1; color1="FGcolor " }
 else {
   if (vn=="1_color") { 
     clrmode=1; color1=PLOT_FT[gff_feat,":","color"]" " }
   else {
     if (vn=="2_color") {
       clrmode=2; color1=clm[1]" "; if (k>1) color2=clm[2]" "; else color2="FGcolor " }
     else {
       if (vn=="frame-remainder") { clrmode=3 }
       else if (vn=="rainbow") { clrmode=4 }
       }}}
 tmp=color1""color2""clrmode
 return tmp }
function Set_feat_Shape(gff_feat,src    ,shp,pos,tmp,vn) {
 vn=PLOT_FT[gff_feat,":","shape"]
 if (vn=="box") shp="box";
 else if (vn=="arrow") shp="arw";
 else if (vn=="end_arrow") shp="end";
 else if (vn=="circle") shp="cir";
 else if (vn=="single") shp="sgl";
 else shp="line";
  # else if (vn==" vector, spike, block ")
 if (PLOT_FT[src,":","vert_align"]=="center") pos="f";
 else if (PLOT_FT[src,":","vert_align"]=="baseline") pos="h";
 tmp=pos""shp;
 return tmp }
function showelemS(s,p,q,  string){
  string=" : ";
  string=string" "element[s,p,q,feature]" ";
  string=string" "element[s,p,q,start]" ";
  string=string" "element[s,p,q,end]" ";
  string=string" "element[s,p,q,frame]" ";
  string=string" "element[s,p,q,group];
  return string }
function showelem(a,b,     c,string){ c=n[a,b]; string=showelemS(s,p,q); return string }
function CreateProps(flag,    STRING,prop,dffeat,feat,gpfeat,sofeat) {
  ############ Create Properties Index for Objects ############ 
  STRING="#\n# L ######PAGE LAYOUT \& PROGRAM OPTIONS######\n#\n"
  if (flag==1) { 
    printf STRING | "cat 1>&2"
    for (dffeat in Default)
      printf "%s=%s\n", dffeat, Default[dffeat] | "sort 1>&2"
    }
  else if (flag==2) { 
    printf STRING > Default["customfile_name_default"]
    for (dffeat in Default)
      printf "%s=%s\n", dffeat, Default[dffeat] > Default["customfile_name_default"]
    }
  STRING="#\n# F ############GENOMIC FEATURES############\n#\n"
  if (flag==1) {
    close("sort 1>&2"); close("cat 1>&2")
    printf STRING | "cat 1>&2"
    }
  else if (flag==2) {
    close(Var["customfile_name_default"])
    printf STRING >> Default["customfile_name_default"]
    }
  for (feat in FT_ary) {
    for (prop in FT_PROP) {
      if (flag==0) PLOT_FT[feat,":",prop]=FT_PROP[prop]
      else if (flag==1)
	    printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] | "sort 1>&2"
      else if (flag==2)
	    printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] >> Default["customfile_name_default"]
      }
    if (flag==1)
      printf "# %s:%s=%s\n#\n", feat, "feature_number", FT_ary[feat] | "cat 1>&2"
    }
  STRING="#\n# G ############GROUP FEATURES############\n#\n"
  if (flag==1) { 
    close("sort 1>&2"); close("cat 1>&2")
    printf STRING | "cat 1>&2"
    }
  else if (flag==2) {
    close(Var["customfile_name_default"])
    printf STRING >> Default["customfile_name_default"]
    }
  for (gpfeat in GP_ary) {
    for (prop in GR_PROP) {
      if (flag==0) PLOT_FT[gpfeat,":",prop]=GR_PROP[prop]
      else if (flag==1)
	    printf "%s:%s=%s\n", gpfeat, prop, PLOT_FT[gpfeat,":",prop] | "sort 1>&2"
      else if (flag==2)
	    printf "%s:%s=%s\n", gpfeat, prop, PLOT_FT[gpfeat,":",prop] >> Default["customfile_name_default"] 
      }
    if (flag==1)
      printf "# %s:%s=%s\n#\n", gpfeat, "feature_number", GP_ary[gpfeat] | "cat 1>&2"
    }
  STRING="#\n# S ############SOURCE FEATURES############\n#\n"
  if (flag==1) { 
    close("sort 1>&2"); close("cat 1>&2")
    printf STRING | "cat 1>&2"
    }
  else if (flag==2) {
    close(Var["customfile_name_default"])
    printf STRING >> Default["customfile_name_default"]
    }
  for (sofeat in sources) {
    for (prop in SO_PROP) {
      if (flag==0) PLOT_FT[sofeat,":",prop]=SO_PROP[prop]
      else if (flag==1)
	    printf "%s:%s=%s\n", sofeat, prop, PLOT_FT[sofeat,":",prop] | "sort 1>&2"
      else if (flag==2)
	    printf "%s:%s=%s\n", sofeat, prop, PLOT_FT[sofeat,":",prop] >> Default["customfile_name_default"]
      }
    if (flag==1)
      printf "# %s:%s=%s\n#\n", sofeat, "group_number", sources[sofeat] | "cat 1>&2"
    }
  if (flag==1) { close("sort 1>&2"); close("cat 1>&2") }
  else if (flag==2) close(Default["customfile_name_default"])
 }
function RCFile(file,    STRING,nothere,first,gffirst,second,ft_type,feat,lytdef,dft) { ############ Read CustomFile
  STRING="Match between: %s & %s : %s=%s\n"
  while ((getline < file) > 0 ) {
   if ( $1!~/^(\#)+/ && NF>0 ) { 
    nothere=0;global=0
    split($0,defs,"=")
    split(defs[1],nwfeat,":")
    first=nwfeat[1]
    if (first=="*") { first=".*"; global=1 }
    gffirst=lcase(first)
    second=nwfeat[2]
    if (ft_type=="F") {
      for (feat in FT_ary) {
        if (match(feat,gffirst)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) {
            PLOT_FT[feat,":",second]=defs[2]
            nothere=1
            }
          if (Var["print_report"])
            printf "Feature "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      if (nothere==0 && !global) {
        FT_ary[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["print_report"])
          printf "No Match found - New Feature: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="G") {
      for (feat in GP_ary) { 
        if (match(feat,first)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) {
            PLOT_FT[feat,":",second]=defs[2]
            nothere=1
            }
          if (Var["print_report"])
            printf "Group "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      if (nothere==0 && !global) {
        GP_ary[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["print_report"])
          printf "No Match found - New Feature: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="S") {
      for (feat in sources) {
        if (match(feat,first)) {
	      if ((feat SUBSEP ":" SUBSEP second) in PLOT_FT) { 
            PLOT_FT[feat,":",second]=defs[2]
	        nothere=1
            }
          if (Var["print_report"])
            printf "Source "STRING,feat,first,(feat":"second),defs[2] | "cat 1>&2"
          }
        }
      if (nothere==0 && !global) {
        sources[gffirst]++
        PLOT_FT[gffirst,":",second]=defs[2]
        if (Var["print_report"])
          printf "No Match found - New Feature: %s : %s=%s\n",first,(feat":"second),defs[2] | "cat 1>&2"   
        }
      }
    else if (ft_type=="L") {
      if (defs[1] in Default) {
        PLOT_LY[defs[1]]=defs[2]
        if (Var["print_report"])
            printf "Layout "STRING,defs[1],first,defs[1],defs[2] | "cat 1>&2"
        }
      }
   }# if not empty or comment line 
   else 
     if ( $1~/^(\#)$/ && $2~/^[LFGS]$/) ft_type=$2
  } # while getline
  close(file) 
# if (first==".*") { for (props in PLOT_FT) if ( }   
# Modifying Vars
  if (Var["print_report"]) printf "\n%s\nCommand-Line Modified options...........\n%s\n\n",BigLINE,BigLINE | "cat 1>&2"
  for (lytdef in Default) {
    dft=Default[lytdef]
    if (dft==Var[lytdef] && PLOT_LY[lytdef]!="") Default[lytdef]=PLOT_LY[lytdef]
      else Default[lytdef]=Var[lytdef]
    if (Var["print_report"]) printf "%s : Default Value=%s Custom File=%s Command-Line=%s : Using=%s\n", lytdef,dft,PLOT_LY[lytdef],Var[lytdef],Default[lytdef] | "sort | cat 1>&2"
    }
    if (OnOff(PLOT_LY["load_customfile"])) Default["load_customfile"]=PLOT_LY["load_customfile"]
  close("sort | cat 1>&2")
 }
function defPSvars() {
 printf "%% BG \& FG colors\n";
 printf "/BGcolor { colordict begin %s end } def\n", Var["BACKGROUND_COLOR"];
 printf "/FGcolor { colordict begin %s end } def\n", Var["FOREGROUND_COLOR"];
 printf "/frm0 { colordict begin %s end } def\n", Default["frame0_color"];
 printf "/frm1 { colordict begin %s end } def\n", Default["frame1_color"];
 printf "/frm2 { colordict begin %s end } def\n", Default["frame2_color"];
 printf "%% page orientation flag\n";
 printf "/flglscape %s def\n", chkpo(Default["page_orientation"]);
 printf "%%%% page size in points used for plot % pgA4 == 595  842\n";
 printf "/Dpage { pagedict begin pg%s flglscape { exch } if end } bdf\n", chkps(Default["page_size"]);
 printf "%% margins (1 cm) (Up Down Left Right - margins are XY independent)\n";
 printf "/UpM %s def\n", chkun(Default["margin_upper"]);
 printf "/DnM %s def\n", chkun(Default["margin_bottom"]);
 printf "/LtM %s def\n", chkun(Default["margin_left"]);
 printf "/RtM %s def\n%%\n", chkun(Default["margin_right"]);
 printf "/TkMrkW %s def %% Defining tickmark-width.\n", chkun(Default["default_scale_width"]);
 printf "/BlckSp %s def %% Defining blocks-spacing\n%%\n", chkun(Default["default_block_spacing_width"]);
 printf "/SeqLen %s def\n", PDIF; 
 printf "/XNucOffSet %s def\n", PORI; 
 printf "/NPages %s def\n", P; 
 printf "/NBlck %s def\n", B; 
 printf "/MaxNuclPage %s def\n", NOFFSET;
 printf "/MaxTick 1000 def\n";
 printf "/MinTick  100 def\n%%\n";
 printf "/tracksize %s def\n", chkun(Default["default_track_width"]);
 printf "/spcrsize  %s def\n", chkun(Default["default_track_spacing_width"]);
 printf "/LnTot  %s def\n", BSize;     # size in points (size is relative here)
 printf "/LnFwd %s def\n", StrSizeFwd; # if they are 0 then not showed
 printf "/LnRvs %s def\n", StrSizeRvs;
 printf "/LnBth %s def\n", NStSize;
 printf "/LnTck %s def\n", cpsc;
 printf "/vectoffset 10 def\n";
 printf "/flpos true def %% flag for showing Seq Xpos for all elements.\n%%\n";
 printf "/Fbline true def %% flag for showing baseline for each method.\n";
 printf "/FgpLbl true def %% flag for showing baseline for each group.\n%%\n";
 printf "/XLftLbl 4 cm  def\n";
 printf "/FLftLbl true  def\n";
 printf "/XRgtLbl 4 cm  def\n";
 printf "/FRgtLbl false  def\n%%\n";
 printf "/XOriTitl 1 cm def\n";
 printf "/YOriTitl 0 cm def\n";
 printf "/YSTitl 1 cm def\n";
 printf "/FlgTitl true def\n";
 printf "%%\n" }
function startPSpage(num,tot) {
 printf "%%%%Page: %s %s\n",num,num;
 printf "%%%%BeginPageSetup\n%%\n";
 printf "%% Saving current page settings\n";
 printf "/pgsave save def\n";
 printf "%% Defining pagenumber\n";
 printf "/PageNumber (Page %s/%s) def\n",num,tot;
 printf "%% Defining page variables\n";
 # printf "/Y YOriBlck def\n";
 printf "%% Setting BGcolor for sheet \n";
 printf "Dpage flglscape { exch } if 0 0 bbox FGcolor 1 tbbox BGcolor scmyk fill\n";
 printf "%% setting coordinate axes for page orientation\n";
 printf "flglscape\n";
 printf " { 90 rotate 1 -1 scale XORI YORI translate }                  %% (0,0) - Ori for landscape pages\n";
 printf " { XORI Dpage exch pop YORI sub translate 1 -1 scale } ifelse  %% (0,0) - Ori for portrait pages\n";
 printf "%% If testing output print bounding_boxes for page elements\n";
 printf "%%tflg { TB } if\n%%\n%% /FGcolor scolor\n%%\n";
 printf "%% Header\n%%\n";
 printf "%%%%EndPageSetup\n";
 printf "%%\n" }
' - $GFF_INPUT_FILES
#### Main GFF2APLOT GNU awk Program DONE.

#
##################### EOF #####################
#
exit 0
