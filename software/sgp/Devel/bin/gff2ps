#!/bin/sh
######################################################################
#                               gff2ps                               #
######################################################################
#
#     Converting GFF files to PostScript.
#
#     Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
#                                 Roderic GUIGO SERRA       
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
######################################################################
#
# Creation Date: 01.03.1999
# Last Update:
#         $Id: gff2ps,v 1.5 1999-04-28 17:54:19 jabril Exp $	
#
# Autor : Josep Francesc ABRIL FERRANDO
# e-mail: jabril@imim.es
#
# ( ./gff2ps samples/mmtag.gff > samples/11.ps ) > & samples/report

##############################################################
#################### PROGRAM DEFINITIONS #####################

# 
# Defining Default Values...
#
Defaults () {
 # 
 # Constants: 
  PROGRAM="gff2ps"
  VERSION="v1.0"
  SHCREATION="01.03.1999"
  SHREVISION="27.04.1999"
  PSPROGRAM="PlotSeqComp.ps"
  PSVERSION="v2.4"
  PSCREATION="02.09.1998"
  PSREVISION="27.04.1999"
  AUTHOR="Josep Francesc ABRIL FERRANDO"
  EMAIL="jabril@imim.es"
  MAIL="%%                  Dept. Informatica Medica
%%          Institut Municipal d'Investigacio Medica
%%                   C./ Doctor Aiguader 80
%%                  08003 - BARCELONA (SPAIN)"
  USAGE=$PROGRAM" [-h][-H <option>] gff_file"
  COLORS="    black | verydarkgrey | darkgrey | grey | lightgrey | verylightgrey | white 
       verydarkgreen | darkgreen | green | lightgreen | verylightgreen 
   verydarkskyblue | darkskyblue | skyblue | lightskyblue | verylightskyblue 
          verydarkblue | darkblue | blue | lightblue | verylightblue 
         verydarkcyan | darkcyan | cyan | lightcyan | verylightcyan 
     verydarkviolet | darkviolet | violet | lightviolet | verylightviolet 
            verydarkred | darkred | red | lightred | verylightred 
     verydarkorange | darkorange | orange | lightorange | verylightorange 
     verydarkyellow | darkyellow | yellow | lightyellow | verylightyellow 
        verydarkbrown | darkbrown | brown | lightbrown | verylightbrown"
 # 
 # Default User-Defined Options: 
  bgcolor="white"
  fgcolor="black"
}

#
# Defining Help...
#
Help () {
#  echo ""
#  echo "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
#  echo "         1         2         3         4         5         6         7         8"
  echo ""
  echo "NAME           $PROGRAM"
  echo "VERSION        $VERSION"
  echo ""
  echo "Creation DATE: $SHCREATION"
  echo "Last REVISION: $SHREVISION"
  echo ""
  echo "SYNOPSIS"
  echo ""
  echo "      $USAGE"
  echo ""
  echo "DESCRIPTION"
  echo ""
  echo "       This program draws color-filled DotPlots"
  echo "       from files with gff-formatted data fields."
  echo "   "
  echo ""
  echo "OPTIONS"
  echo ""
  echo "     -h  Show this help."
  echo "     -H <option> Show only help for the especified option."
  echo ""
  echo "COMMENTS"
  echo ""
  echo "  * Colors Defined are:"
  echo ""
  echo "$COLORS"
  echo ""
  echo "BUGS"
  echo ""
  echo "  Please, report bugs to:"
  echo "       $AUTHOR"
  echo "       e-mail: $EMAIL"
  echo "       Mail  : "
  gawk 'BEGIN{tt=ARGV[1];ARGV[1]="";gsub("\%\%","",tt);printf tt;print}' "$MAIL"
  echo ""
  return
}

ShowHelpLine () {
 Help | gawk 'BEGIN{
  IGNORECASE=1; flg=0; srch=ARGV[1]; ARGV[1]=""
  gsub("-","",srch); srch="\ -"srch"\ " }
  { if ($0~srch) { print $0; flg=1 } }
  END{ if (!flg) printf "\n\tERROR: Option %s is not defined,\n\t\tmake sure which option you need help.\n",srch }' $1 
 echo ""
 return
}

#
# Testing parameters passed by User.
#
CheckColor () {
  gawk 'BEGIN{
    color=ARGV[1]
    if (color!~/^BG$|^FG$|^black$|^white$|^(very)?(light|dark)?(grey|green|(sky)?blue|cyan|violet|red|orange|yellow|brown)$/) {
      printf "\n<<<<ERROR>>>> \" %s \" is not a defined color.\n", color | "cat 1>&2"
      printf "              Default \" black \" is asigned to option.\n" | "cat 1>&2"
      printf "              You can choose one of this colors:\n" | "cat 1>&2"
      print ARGV[3] | "cat 1>&2"
      print "" | "cat 1>&2"
      color=ARGV[2]
      }
    print color
    ARGV[1]=ARGV[2]=ARGV[3]=""
    }' $1 $2 "$COLORS"
  return 0
}

CheckInt () {
  if [ `expr $1 : '[0-9]*'` -eq `expr $1 : '.*'` ]
    then echo "1"; return 0
    else 
      echo "<<<<ERROR>>>> \" $1 \" is not an integer value." 1>&2
      echo "              You must especify an integer value to -$W_OPTION" 1>&2
      echo "              Program will take value from defaults..." 1>&2
      echo "" 1>&2
      echo "0";return 1
    fi
  return 1
}
###################################################################
################## Choosing Options for GFF2PS ####################

#
# Resetting default program variables.
#
Defaults

#
# When no options, no parameters and 
#  no inputstream are given, print USAGE.
#
if [ $# -eq 0 ] 
  then
    echo; echo $USAGE; echo; exit 1
  fi

#
# Asking for Help, output it to screen. 
#
case $1 in
  -h) Help; exit 2;;
  -H) echo; echo $PROGRAM" : Option Definition Help."; echo;
      if [ $# -gt 1 ]; 
        then shift; fi;
      for temp in $@;
        do ShowHelpLine $temp; done;
      exit 2;;
  esac

#
# Processing all options and parameters passed to program.
#
## while getopts

###################################################################
################### Converting to PostScript ######################

#
# Printing PostScript Header...
#
gawk 'BEGIN{ 
 # Find actual date...
 "date" | getline d
 split(d,dt," ")
 date = dt[3] "." dt[2] "." dt[6] " " substr(dt[4],1,5)
 # Finding logged user...
 "whoami" | getline usr
 # Printing PostScript Header...
 bigchain=        "%%\!PS-Adobe-2.0\n"
 bigchain=bigchain"%%%%Title: %s\n"
 bigchain=bigchain"%%\n%%%%User: %s\n"
 bigchain=bigchain"%%%%Date: %s\n"
 bigchain=bigchain"%%\n%%%%Program: %s\n"
 bigchain=bigchain"%%%%Version: %s\n"
 bigchain=bigchain"%%%%CreationDate: %s\n"
 bigchain=bigchain"%%%%LastRevision: %s\n"
 bigchain=bigchain"%%%%Author : %s\n"
 bigchain=bigchain"%%%%e-mail : %s\n"
 bigchain=bigchain"%%%%Mail Adress:\n%s\n%%\n"
 if (ARGV[1]!~"##dflt##") title=ARGV[1]
 else title="GFF to PostScript"
 printf bigchain, title, usr, date, ARGV[2], ARGV[3], ARGV[4], ARGV[5], ARGV[6], ARGV[7], ARGV[8]
 printf "%%\n%% ------------------------------------------------------------------------\n"
 printf "%%                           %s - %s\n",ARGV[2], ARGV[3]
 printf "%% ------------------------------------------------------------------------\n"
  for (i=1;i<=8;i++) ARGV[i]=""
}' "##dflt##" "$PSPROGRAM" "$PSVERSION" "$PSCREATION" "$PSREVISION" "$AUTHOR" "$EMAIL" "$MAIL"

#
# Printing %%Prolog Constant Definitions...
#
cat <<'@@@EndProlog@@@'
%
%          Converting GFF files to PostScript plots.
%
%          Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
%                                      Roderic GUIGO SERRA       
%
%    This program is free software; you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation; either version 2 of the License, or
%    (at your option) any later version.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program; if not, write to the Free Software
%    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
%
% ------------------------------------------------------------------------
%
%%Orientation: Portrait
%%BoundingBox:  0  0  595  842 
%%BeginProlog
%
%   1 cm   = 28.35 points
%   1 inch = 72.00 points
%
%  Paper Sizes  (in points) 
% --------------------------
%
/pgA2           { 1190 1684 } def % Portrait { minor-axes:X major-axes:Y }
/pgA3           {  842 1190 } def
/pgA4           {  595  842 } def
/pgA5           {  420  595 } def
/pgB4           {  708 1003 } def
/pgB5           {  516  729 } def
/pgExecutive    {  540  720 } def
/pgLedger       { 1224  792 } def
/pgLegal        {  612 1008 } def
/pgLetter       {  612  792 } def
/pgTabloid      {  792 1224 } def
/pgUserDefined  {  595 2448 } def
%
%  Fonts Used
% ---------------------------------
%
/coboti   { 3.0 /Courier-Bold } def
/cobost   { 2.0 /Courier-Bold } def
/tickfont { 1.5 /Courier      } def
/trackfont { 2.00 /Courier-Bold } def
/gnlblsize { 2.00 /Courier      } def
%
%  Fixed Color Variables (CMYK)
% ---------------------------------
%
/colordict 54 dict def colordict begin
/black             { 0.00 0.00 0.00 1.00 } def
/verydarkgrey      { 0.00 0.00 0.00 0.90 } def
/darkgrey          { 0.00 0.00 0.00 0.75 } def
/grey              { 0.00 0.00 0.00 0.50 } def
/lightgrey         { 0.00 0.00 0.00 0.25 } def
/verylightgrey     { 0.00 0.00 0.00 0.10 } def
/white             { 0.00 0.00 0.00 0.00 } def
/verydarkgreen     { 0.65 0.00 0.95 0.40 } def
/darkgreen         { 0.90 0.00 0.90 0.10 } def
/green             { 1.00 0.00 1.00 0.00 } def
/lightgreen        { 0.50 0.00 1.00 0.00 } def
/verylightgreen    { 0.25 0.00 0.75 0.00 } def
/verydarkskyblue   { 0.95 0.15 0.00 0.40 } def
/darkskyblue       { 1.00 0.25 0.00 0.15 } def
/skyblue           { 1.00 0.25 0.00 0.00 } def
/lightskyblue      { 0.80 0.20 0.10 0.00 } def
/verylightskyblue  { 0.60 0.15 0.15 0.00 } def
/verydarkblue      { 1.00 1.00 0.00 0.40 } def
/darkblue          { 1.00 1.00 0.00 0.10 } def
/blue              { 1.00 1.00 0.00 0.00 } def
/lightblue         { 0.80 0.80 0.00 0.00 } def
/verylightblue     { 0.50 0.50 0.00 0.00 } def
/verydarkcyan      { 0.65 0.15 0.00 0.25 } def
/darkcyan          { 0.65 0.15 0.00 0.00 } def
/cyan              { 1.00 0.00 0.00 0.00 } def
/lightcyan         { 0.50 0.00 0.00 0.00 } def
/verylightcyan     { 0.25 0.00 0.00 0.00 } def
/verydarkviolet    { 0.40 0.80 0.20 0.00 } def
/darkviolet        { 0.45 0.85 0.00 0.00 } def
/violet            { 0.30 0.60 0.00 0.00 } def
/lightviolet       { 0.15 0.55 0.00 0.00 } def
/verylightviolet   { 0.05 0.45 0.00 0.00 } def
/verydarkred       { 0.00 0.90 0.90 0.30 } def
/darkred           { 0.00 0.80 0.90 0.10 } def
/red               { 0.00 1.00 1.00 0.00 } def
/lightred          { 0.05 0.80 0.90 0.00 } def
/verylightred      { 0.15 0.40 0.60 0.00 } def
/verydarkorange    { 0.00 0.60 1.00 0.00 } def
/darkorange        { 0.00 0.55 0.90 0.00 } def
/orange            { 0.00 0.50 0.70 0.00 } def
/lightorange       { 0.00 0.30 0.85 0.00 } def
/verylightorange   { 0.00 0.30 0.55 0.00 } def
/verydarkyellow    { 0.00 0.10 0.85 0.25 } def
/darkyellow        { 0.00 0.10 0.85 0.00 } def
/yellow            { 0.00 0.00 1.00 0.00 } def
/lightyellow       { 0.00 0.00 0.50 0.00 } def
/verylightyellow   { 0.00 0.00 0.25 0.00 } def
/verydarkbrown     { 0.00 0.85 1.00 0.70 } def
/darkbrown         { 0.00 0.75 1.00 0.60 } def
/brown             { 0.00 0.70 1.00 0.40 } def
/lightbrown        { 0.30 0.60 0.70 0.00 } def
/verylightbrown    { 0.15 0.45 0.55 0.00 } def
end
% true setpacking
true setstrokeadjust
0.125 setlinewidth
0 setlinejoin
0 setlinecap
%%EndProlog
%%BeginSetup
@@@EndProlog@@@

#
# Printing %%Prolog User-Defined Variables...
#
# gawk -v CUSTOMFILE=$CFDIR/.gff2aplot.rc -v PARAMETERS="$APLOToptions" 'BEGIN{
#
# printf "colordict begin /BGcolor colordict /%s get def /FGcolor colordict /%s get def end\n",BGcolorname,FGcolorname

#
# Printing Main PostScript Routines...

cat <<'@@@EndProcs@@@'
/cm { 28.35 mul } bind def
%%%% page orientation flag
/flglscape true def
%/flglscape false def
%%%% page size in points used for plot % pgA4 == 595  842
/Dpage { pgA4 flglscape { exch } if } bind def
%%%% offset defines non printable paper area on portrait pages
/VUpOS 0.25 cm def
/VDnOS 0.25 cm def
/HLtOS 0.25 cm def
/HRtOS 0.25 cm def
%%%% margins (1 cm) (Up Down Left Right - margins are XY independent)
/UpM 1 cm def
/DnM 1 cm def
/LtM 1 cm def
/RtM 1 cm def
%%%% checking if margins are within the defined offset
flglscape {
UpM HLtOS lt { /UpM HLtOS def } if % Checking margins for flglscape mode
DnM HRtOS lt { /DnM HRtOS def } if
LtM VDnOS lt { /LtM VDnOS def } if
RtM VUpOS lt { /RtM VUpOS def } if
} {
UpM VUpOS lt { /UpM VUpOS def } if % Checking margins for portrait mode
DnM VDnOS lt { /DnM VDnOS def } if
LtM HLtOS lt { /LtM HLtOS def } if
RtM HRtOS lt { /RtM HRtOS def } if
} ifelse
%%%%  defining pagelimits and X - Y scales (Xlim Ylim)
/pglim { Dpage pop LtM RtM add sub Dpage exch pop UpM DnM add sub } def
% /pgXsc { pglim pop 100 div } def
% /pgYsc { pglim exch pop 100 div } def
%%%% Defining starting point on page.
/XORI LtM def
/YORI UpM def
%
% ---------------------------------
%     EndVariableDefinitions
% ---------------------------------
%
% ---------------------------------
%     BeginProcedureDefinitions
% ---------------------------------
%
%  Global Calculus Procedures
% ---------------------------------
%
% <--- num num .min
/min { 2 copy gt { exch } if pop } bind def 
% <--- num num .max
/max { 2 copy lt { exch } if pop } bind def
% <--- num .function
% /Xscm { Xscale mul } bind def /Xscme { Xscm exch } bind def
% /Yscm { Yscale mul } bind def /Yscme { Yscm exch } bind def
% /fmt { Yscme Xscme moveto } bind def /flt { Yscme Xscme lineto } bind def

%
%  Global Drawing Procedures
% ---------------------------------
%
% <--- /colorname .scolor
/scolor { colordict exch get exec setcmykcolor } bind def 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% <--- score gcolor (must be defined also a inicolor, endcolor, maxscore, minscore for gradient).
% <--- startcolor endcolor maxscore minscore .defgradsets % also useful on degradates from color to white
% /gradsets 6 dict def
% /defgradsets { gradsets begin /mnsc def /mxsc def /ecol def /scol def /sdif mxsc mnsc sub def end } def
% /gcolor { gradsets begin /sc exch mnsc sub def ecol scol 4 { 5 -1 roll sub abs sdif div sc mul 4 1 roll } repeat setcmykcolor end } def
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% <--- x1 y1 x2 y2 .bbox
/bbox { 4 copy 3 1 roll exch 6 2 roll 8 -2 roll moveto lineto lineto lineto closepath } bind def
% <--- (x2-x1) score x1 y1 .DB
% /db { matrix currentmatrix 5 1 roll XS YS scale moveto 1 index 0 rlineto 0 exch rlineto neg 0 rlineto closepath setmatrix } bind def
% <--- width height xori yori .box
/box { moveto 1 index 0 rlineto 0 exch rlineto neg 0 rlineto closepath } bind def
%
%  Text Procedures
% ---------------------------------
%
% <--- size font .sfont
/sfont { findfont exch scalefont setfont } bind def
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% <--- size font .sfont
% /fntmtrx matrix def
% /savegmtrx fntmtrx currentmatrix def
% /sfont { /savemtrx fntmtrx currentmatrix def savegmtrx setmatrix findfont exch scalefont setfont savemtrx setmatrix } bind def
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Page Structuring Procedures
% ---------------------------------
%
% /header
% { 5 0 translate
%   1 0 0 100 -5 box
%   -1.5  2.5 PageTitle coboti FGcolor 0 textshow
%   putpage 1 eq
%   { -3 97.5 PageNumber cobost FGcolor 2 textshow
%     } if
%   putdate 1 eq
%   { -1 97.5 PageDate cobost FGcolor 2 textshow
%     } if
%   blockYscale 1 scale
%   Reverse 1 ne Forward 1 ne or
%   { 2 1 scale 
%     Forward 0 eq
%     { HlfWdth neg 10 translate
%       } { % Reverse==0
%           0 10 translate 
%           } ifelse
%     } { HlfWdth neg 10 translate
%         } ifelse
%   } bind def
%
%  Gene Drawing Procedures
% ---------------------------------
%
%%EndSetup
%
%%Page: 1 1
%%BeginPageSetup
/PageNumber (Page 1/1) def
/pgsave save def
%%EndPageSetup
%
% filling for BGcolor page
% colordict begin /BGcolor colordict /blue get def /FGcolor colordict /yellow get def end
Dpage flglscape { exch } if 0 0 box gsave stroke grestore /BGcolor scolor fill
%%%% setting coordinate axes for page orientation
flglscape 
 { 90 rotate 1 -1 scale XORI YORI translate }                  % CTM for landscape pages
 { XORI Dpage exch pop YORI sub translate 1 -1 scale } ifelse  % CTM for portrait pages
%%%%
% pglim 0 0 box gsave stroke grestore /BGcolor scolor fill
%
/FGcolor scolor
% 0.125 setlinewidth 
2 setlinewidth 
pglim 0 0 box gsave stroke grestore /lightskyblue scolor fill
pgsave restore
showpage
% header
%
@@@EndProcs@@@

##############################################################
############### Main GFF2PS GNU awk Program... ###############
#
# (cat <<'@@@EndPROGRAM@@@') |
# @@@EndPROGRAM@@@
# gawk -v CUSTOMFILE=$CFDIR/.gff2aplot.rc -f - "$@"

gawk 'BEGIN{
  ############ INITIALITATION ############

  # defaults
  MINSCORE=0.25;
  MAXSCORE=1.00;
  BigLINE="########################################"

  # gff data structure
  seqname  = 1;
  source   = 2;
  feature  = 3;
  start    = 4;
  end      = 5;
  score    = 6;
  strand   = 7;
  frame    = 8;
  group    = 9;

  # gff strand codification
  strands["+"]=strands["-"]=strands["."]=1;

  # Find actual date...
  "date" | getline d
  split(d,dt," ")
  date = dt[3] "." dt[2] "." dt[6] " " substr(dt[4],1,5)

  # Finding logged user...
  "whoami" | getline usr

  # Finding current process...
  "echo $$" | getline IDP

# Option Definitions
  Var["PrintReport"]=1
  Var["LoadCustomFile"]=0

# Layout Properties
  Default["page_size"]="a4"
  Default["page_orientation"]="landscape"
  Default["margin_left"]="1cm"
  Default["margin_right"]="1cm"
  Default["margin_upper"]="1cm"
  Default["margin_bottom"]="1cm"
  Default["foreground_color"]="FGcolor"
  Default["background_color"]="BGcolor"
  Default["block_number"]=1
  Default["strand_show_forward"]="on"
  Default["strand_show_reverse"]="on"
  Default["strand_show_independent"]="on"
# General Properties
  Default["text_color"]=Default["foreground_color"]
  Default["label"]="none"
# Features Properties
  # Default["fillcolor"]=Default["background_color"]
  FT_PROP["label"]="default" # none , default , "user-def"
  FT_PROP["color"]=Default["foreground_color"]
  FT_PROP["shape"]="box"
  FT_PROP["layer"]=0
  FT_PROP["show"]="on"
# Group Properties
  GR_PROP["label"]="default" # none , default , "user-def"
  GR_PROP["rank"]="0:1"
  GR_PROP["join_align"]="center"
  GR_PROP["join_color"]=Default["foreground_color"]
  GR_PROP["join_linetype"]="solid"
  GR_PROP["join_show"]="off"
# Lines (Method-Source) Properties
  SO_PROP["label"]="default" # none , default , "user-def"
  SO_PROP["baseline_align"]="center"
  SO_PROP["baseline_color"]=Default["foreground_color"]
  SO_PROP["baseline_linetype"]="dotted"
  SO_PROP["baseline_show"]="off"
  SO_PROP["bbox_color"]=Default["foreground_color"]
  SO_PROP["bbox_show"]="off"
  SO_PROP["scale"]=1
  SO_PROP["rule_scale"]="nucleotide"
  SO_PROP["rule_rel"]="none"
  SO_PROP["rule_abs"]="none"
# Default[""]=

 # Data for upper-case to lower-case function #lcase()#
 CM["A"]="a";CM["B"]="b";CM["C"]="c";CM["D"]="d";CM["E"]="e";
 CM["F"]="f";CM["G"]="g";CM["H"]="h";CM["I"]="i";CM["J"]="j";
 CM["K"]="k";CM["L"]="l";CM["M"]="m";CM["N"]="n";CM["O"]="o";
 CM["P"]="p";CM["Q"]="q";CM["R"]="r";CM["S"]="s";CM["T"]="t";
 CM["U"]="u";CM["V"]="v";CM["W"]="w";CM["X"]="x";CM["Y"]="y";
 CM["Z"]="z";CM["Ñ"]="ñ";CM["Ç"]="ç"

 if (Var["PrintReport"]) 
   printf "\n%s\nInput File...\n%s\n",BigLINE,BigLINE | "cat 1>&2"
 }
{ ############ READING .GFF FILES  ############

  # skips those empty lines or comments "#"
  #
  while ($0~/^( )*$|^(\#)+/) { 
    if (Var["PrintReport"]) 
      printf "%10s :: Not Read :: %s\n", NR, $0 | "cat 1>&2"
    if (getline<=0) break
    }

  # Printing Input Lines
  #
  if (Var["PrintReport"]) 
   printf "%10s : %s\n", NR, $0 | "cat 1>&2"

  # read gff element within source and strand
  #
  sources[$source]++;  
  n[$source,$strand]++;
  $feature=lcase($feature);
  element[$source,$strand,n[$source,$strand],feature] = $feature; 
  if (!($feature in FT_ary) && $feature!~/\./) FT_ary[$feature]=$feature;
  element[$source,$strand,n[$source,$strand],start]   = $start;
  element[$source,$strand,n[$source,$strand],end]     = $end;
  element[$source,$strand,n[$source,$strand],frame]   = $frame;  
  element[$source,$strand,n[$source,$strand],group]   = $group; 
  if (!($group in GP_ary) && $group!~/\./) GP_ary[$group]=$group;
  if ($NF>group) {
    for (i=(group+1);i<=$NF;i++) {
      if ($i~"Label")
        element[$source,$strand,n[$source,$strand],$i]= $(i+1);  
    }
  }

  # recompute scores between MINSCORE and MAXSCORE
  #
  if ($score < MINSCORE)
    element[$source,$strand,n[$source,$strand],score]  = MINSCORE;
  else if ($score > MAXSCORE)
    element[$source,$strand,n[$source,$strand],score]  = MAXSCORE;

  # place gff element in sort array by acceptor position
  #
  ns=n[$source,$strand]-1;
  while ($start < element[$source,$strand,S[$source,$strand,ns],start]) {
    S[$source,$strand,ns+1]=S[$source,$strand,ns];
    ns--;
  }
  S[$source,$strand,ns+1]=n[$source,$strand]

}
END{

  # Printing elements sorted
  #
  if (Var["PrintReport"]) {
   printf "\n%s\ngff elements are sorted...\n%s\n",BigLINE,BigLINE | "cat 1>&2"
   for (sc in sources) 
    for (s in strands) 
     for (i=1;i<=n[sc,s];i++)
      printf "%10s %s\n", S[sc,s,i],showelemS(sc,s,S[sc,s,i]) | "sort | cat 1>&2"
   close("sort | cat 1>&2")
   }

  # Defining Object Properties
  #
  CreateProps(0)
  if (Var["LoadCustomFile"]) RCFile(CFILE)

  # make groups. assumes elements sorted by increasing acceptor position
  #
  if (Var["PrintReport"]) printf "\n%s\nMaking Groups...............\n%s\n",BigLINE,BigLINE | "cat 1>&2"
  for (sc in sources) {
    for (s in strands) {
      for (i=1;i<=n[sc,s];i++) {
	tgr=element[sc,s,S[sc,s,i],group];
	if (!grouping[sc,s,tgr,start]) {
	  grouping[sc,s,tgr,start]= element[sc,s,S[sc,s,i],start];
	  ng[sc,s]++;
	  group_[sc,s,ng[sc,s]]=tgr
          }
####################
#        grouping[sc,s,tgr,end]= element[sc,s,S[sc,s,i],end];
#
#        # for gene mode. try to recompute relative frame and remainder
#        start_=element[sc,s,S[sc,s,i],start];
#        end_=element[sc,s,S[sc,s,i],end];
#        feature_=element[sc,s,S[sc,s,i],feature];
#
#        frame_[sc,s,tgr]= element[sc,s,S[sc,s,i],frame];
#
#        if (feature_=="First" || feature_=="Single") 
#          frame_[sc,s,tgr]=0;
#        else if (feature_=="Internal" || feature_=="Terminal" )
#          frame_[sc,s,tgr]=remainder_[sc,s,tgr];
#
#        remainder_[sc,s,tgr]=(3-(end_-(start_+frame_[sc,s,tgr])+1)%3)%3;
#
#        grouping[sc,s,tgr,group] = sprintf("%s %d %d %s %d %d %5.3f", grouping[sc,s,tgr,group], element[sc,s,S[sc,s,i],start], element[sc,s,S[sc,s,i],end], psc_feature[element[sc,s,S[sc,s,i],feature]], frame_[sc,s,tgr] ,remainder_[sc,s,tgr],  element[sc,s,S[sc,s,i],score]);
##################### 
	if (element[sc,s,S[sc,s,i],end]>grouping[sc,s,tgr,end]) {
	  grouping[sc,s,tgr,end]= element[sc,s,S[sc,s,i],end];
          }
#################
   if (Var["PrintReport"]) {
    print grouping[sc,s,tgr,start]," :",sc,s,tgr,start, showelem(sc,s) | "cat 1>&2"
    print grouping[sc,s,tgr,end]," :",sc,s,tgr,end, showelem(sc,s) | "cat 1>&2"
    for (prop in FT_PROP) {
      printf "\t%-10s : %-8s %s \n",element[sc,s,S[sc,s,i],feature],prop,PLOT_FT[element[sc,s,S[sc,s,i],feature],":",prop] | "cat 1>&2"
      }
    }
#################
      }
    }
  }

  # make plotlines. Put non-overlapping groups into the same plotting line.
  #
  if (Var["PrintReport"]) printf "\n%s\nPrinting Lines...............\n%s\n",BigLINE,BigLINE | "cat 1>&2"
  for (sc in sources) {
    for (s in strands) {
      for (i=1;i<=ng[sc,s];i++) {
	g=group_[sc,s,i];
	for (j=1;j<=nl[sc,s] && grouping[sc,s,g,start] < endline[sc,s,j];j++);
	nl[sc,s] = j==nl[sc,s]+1 ? j : nl[sc,s];
        endline[sc,s,j]=grouping[sc,s,g,end];
	# plot group in file
	if (Var["PrintReport"]) printf "GROUP : %-10s : %s %10d %10d \n", g, s, grouping[sc,s,g,start], grouping[sc,s,g,end] | " sort +6 | cat 1>&2";
        }
     }
  }
  if (Var["PrintReport"]) close(" sort +6 | cat 1>&2")

  # Object Properties Report...
  #
  if (Var["PrintReport"]) {
    printf "\n%s\nDefining Object Properties..........\n%s\n",BigLINE,BigLINE | "cat 1>&2"
    CreateProps(1)
    }

}
function lcase(string) {
  for (chr in CM) gsub(chr,CM[chr],string)
  return string
}
function CreateProps(flag) {
  ############ Create Properties Index for Objects ############
  if (flag) { 
    printf "#\n# L ############PAGE LAYOUT############\n#\n" | "cat 1>&2"
    for (feat in Default) printf "%s=%s\n", feat, Default[feat] | "sort | cat 1>&2"
    }
  if (flag) {
    close("sort | cat 1>&2")
    printf "#\n# F ############GENOMIC FEATURES############\n#\n" | "cat 1>&2"
    }
  for (feat in FT_ary) {
    for (prop in FT_PROP) {
      if (flag)
	printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] | "sort | cat 1>&2"
      else PLOT_FT[feat,":",prop]=FT_PROP[prop]
      }
    }
  if (flag) { 
    close("sort | cat 1>&2")
    printf "#\n# G ############GROUP FEATURES############\n#\n" | "cat 1>&2"
    }
  for (feat in GP_ary) {
    for (prop in GR_PROP) {
      if (flag)
	printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] | "sort | cat 1>&2"
      else PLOT_FT[feat,":",prop]=GR_PROP[prop]
      }
    if (flag)
      printf "# %s:%s=%s\n#\n", feat, "feature_number", Nfeat[feat,":","feature_number"] | "cat 1>&2"
    }
  if (flag) { 
    close("sort | cat 1>&2")
    printf "#\n# S ############SOURCE FEATURES############\n#\n" | "cat 1>&2"
    }
  for (feat in sources) {
    for (prop in SO_PROP) {
      if (flag)
	printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] | "sort | cat 1>&2"
      else PLOT_FT[feat,":",prop]=SO_PROP[prop]
      }
    if (flag)
      printf "# %s:%s=%s\n#\n", feat, "group_number", Ngroup[feat,":","group_number"] | "cat 1>&2"
    }
    if (flag) close("sort | cat 1>&2")
}
function RCFile(file) { ############ Read CustomFile
  while ((getline < file) > 0 ) {
    ChckLn(file)
    nothere=0
    split($0,defs,"=")
    split(defs[1],nwfeat,":")
    first=nwfeat[1]
    if (first=="*") first=".*" 
    gffirst=lcase(first)
    second=nwfeat[2]
    for (feat in FT_ary) {
      if (match(feat,gffirst)) {
        if (Var["PrintReport"]) print "Feature Match between: " feat " & " first | "cat 1>&2"
	if ((feat,":",second) in PLOT_FT) {
          PLOT_FT[feat,":",second]=defs[2]
     	  nothere=1
        }
      }
    }
    for (feat in GP_ary) { 
      if (match(feat,first)) {
        if (Var["PrintReport"]) print "Group Match between: " feat " & " first | "cat 1>&2"
	if ((feat,":",second) in PLOT_FT) {
          PLOT_FT[feat,":",second]=defs[2]
	  nothere=1
        }
      }
    }
    for (feat in sources) {
      if (match(feat,first)) {
        if (Var["PrintReport"]) print "Source Match between: " feat " & " first | "cat 1>&2"
	if ((feat,":",second) in PLOT_FT) { 
          PLOT_FT[feat,":",second]=defs[2]
	  nothere=1
        }
      }
    }
    # print ">>>New Feature>>>" $0
    if (nothere==0) {
      if (Var["PrintReport"]) print "No Match found: " first | "cat 1>&2"   
      FT_ary[gffirst]=gffirst
      PLOT_FT[gffirst,":",second]=defs[2]
    }
  }
  close(file)  
}
function showelemS(s,p,q){
  string=" : "
  string=string" "element[s,p,q,feature]" "
  string=string" "element[s,p,q,start]" "
  string=string" "element[s,p,q,end]" "
  string=string" "element[s,p,q,frame]" "
  string=string" "element[s,p,q,group]
  return string
 }
function showelem(a,b){
  string=" : "
  string=string" "element[a,b,n[a,b],feature]" "
  string=string" "element[a,b,n[a,b],start]" "
  string=string" "element[a,b,n[a,b],end]" "
  string=string" "element[a,b,n[a,b],frame]" "
  string=string" "element[a,b,n[a,b],group]
  return string
 }
' "$@"

##############################################################
############ Main GFF2APLOT GNU awk Program DONE. ############
#

#
# PostScript end of page...
# 
cat <<'@@@EndTrailer@@@'
%%Trailer
%
%%EOF
@@@EndTrailer@@@

#
##################### EOF #####################
#
exit 0
