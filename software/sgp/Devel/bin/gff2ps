#!/bin/sh
######################################################################
#                               gff2ps                               #
######################################################################
#
#     Converting GFF files to PostScript.
#
#     Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
#                                 Roderic GUIGO SERRA       
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
######################################################################
#
# Creation Date: 01.03.1999
# Last Update:
#         $Id: gff2ps,v 1.7 1999-05-03 04:11:18 jabril Exp $	
#
# Autor : Josep Francesc ABRIL FERRANDO
# e-mail: jabril@imim.es
#
# ( ./gff2ps -v samples/mmtag.gff > samples/11.ps ) > & samples/report
#

##############################################################
#################### PROGRAM DEFINITIONS #####################
# 
# Defining Default Values...
#
Defaults () {
 # 
 # Constants: 
  PROGRAM="gff2ps"
  VERSION="v1.0"
  SHCREATION="01.03.1999"
  SHREVISION="27.04.1999"
  PSPROGRAM="PlotSeqComp.ps"
  PSVERSION="v2.4"
  PSCREATION="02.09.1998"
  PSREVISION="27.04.1999"
  AUTHOR="Josep Francesc ABRIL FERRANDO"
  EMAIL="jabril@imim.es"
  MAIL="%%                  Dept. Informatica Medica
%%          Institut Municipal d'Investigacio Medica
%%                   C./ Doctor Aiguader 80
%%                  08003 - BARCELONA (SPAIN)"
  USAGE=$PROGRAM" [-h][-H <option>] gff_file"
  COLORS="    black | verydarkgrey | darkgrey | grey | lightgrey | verylightgrey | white 
       verydarkgreen | darkgreen | green | lightgreen | verylightgreen 
   verydarkskyblue | darkskyblue | skyblue | lightskyblue | verylightskyblue 
          verydarkblue | darkblue | blue | lightblue | verylightblue 
         verydarkcyan | darkcyan | cyan | lightcyan | verylightcyan 
     verydarkviolet | darkviolet | violet | lightviolet | verylightviolet 
            verydarkred | darkred | red | lightred | verylightred 
     verydarkorange | darkorange | orange | lightorange | verylightorange 
     verydarkyellow | darkyellow | yellow | lightyellow | verylightyellow 
        verydarkbrown | darkbrown | brown | lightbrown | verylightbrown"
 # 
 # Default User-Defined Options: 
  CFDIR=`pwd`
  bgcolor="white"
  fgcolor="black"
  v01="0"; n01="Load_CustomFile"
  v02=" "; n02="CustomFile_Name"
  v03="$CFDIR/.gff2psrc"; n03="Default_CustomFile_Name"
  v04="0"; n04="Exist_Default_CustomFile"
  v05="0"; n05="Print_Report"
}

#
# Defining Help...
#
Help () {
#  echo ""
#  echo "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
#  echo "         1         2         3         4         5         6         7         8"
  echo ""
  echo "NAME           $PROGRAM"
  echo "VERSION        $VERSION"
  echo ""
  echo "Creation DATE: $SHCREATION"
  echo "Last REVISION: $SHREVISION"
  echo ""
  echo "SYNOPSIS"
  echo ""
  echo "      $USAGE"
  echo ""
  echo "DESCRIPTION"
  echo ""
  echo "       This program draws color-filled DotPlots"
  echo "       from files with gff-formatted data fields."
  echo "   "
  echo ""
  echo "OPTIONS"
  echo ""
  echo "     -h  Show this help."
  echo "     -H <option> Show only help for the especified option."
  echo ""
  echo "COMMENTS"
  echo ""
  echo "  * Colors Defined are:"
  echo ""
  echo "$COLORS"
  echo ""
  echo "BUGS"
  echo ""
  echo "  Please, report bugs to:"
  echo "       $AUTHOR"
  echo "       e-mail: $EMAIL"
  echo "       Mail  : "
  gawk 'BEGIN{tt=ARGV[1];ARGV[1]="";gsub("\%\%","",tt);printf tt;print}' "$MAIL"
  echo ""
  return
}

ShowHelpLine () {
 Help | gawk 'BEGIN{
  IGNORECASE=1; flg=0; srch=ARGV[1]; ARGV[1]=""
  gsub("-","",srch); srch="\ -"srch"\ " }
  { if ($0~srch) { print $0; flg=1 } }
  END{ if (!flg) printf "\n\tERROR: Option %s is not defined,\n\t\tmake sure which option you need help.\n",srch }' $1 
 echo ""
 return
}

##############################################################
################# POSTSCRIPT MAIN FUNCTIONS ##################
#
# Printing %%Prolog Constant Definitions...
#
MAINPSPROLOG () {
cat <<'@@@EndProlog@@@'
%
%          Converting GFF files to PostScript plots.
%
%          Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
%                                      Roderic GUIGO SERRA       
%
%    This program is free software; you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation; either version 2 of the License, or
%    (at your option) any later version.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program; if not, write to the Free Software
%    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
%
% ------------------------------------------------------------------------
%
%%Orientation: Portrait
%%BoundingBox:  0  0  595  842 
%%BeginProlog
%
%   1 cm   = 28.35 points
%   1 inch = 72.00 points
%
%  Paper Sizes  (in points) 
% --------------------------
%
/pgA2           { 1190 1684 } def % Portrait { minor-axes:X major-axes:Y }
/pgA3           {  842 1190 } def
/pgA4           {  595  842 } def
/pgA5           {  420  595 } def
/pgB4           {  708 1003 } def
/pgB5           {  516  729 } def
/pgExecutive    {  540  720 } def
/pgLedger       { 1224  792 } def
/pgLegal        {  612 1008 } def
/pgLetter       {  612  792 } def
/pgTabloid      {  792 1224 } def
/pgUserDefined  {  595 2448 } def
%
%  Fonts Used
% ---------------------------------
%
/coboti   { 3.0 /Courier-Bold } def
/cobost   { 2.0 /Courier-Bold } def
/tickfont { 1.5 /Courier      } def
/trackfont { 2.00 /Courier-Bold } def
/gnlblsize { 2.00 /Courier      } def
%
%  Fixed Color Variables (CMYK)
% ---------------------------------
%
/colordict 54 dict def colordict begin
/black             { 0.00 0.00 0.00 1.00 } def
/verydarkgrey      { 0.00 0.00 0.00 0.90 } def
/darkgrey          { 0.00 0.00 0.00 0.75 } def
/grey              { 0.00 0.00 0.00 0.50 } def
/lightgrey         { 0.00 0.00 0.00 0.25 } def
/verylightgrey     { 0.00 0.00 0.00 0.10 } def
/white             { 0.00 0.00 0.00 0.00 } def
/verydarkgreen     { 0.65 0.00 0.95 0.40 } def
/darkgreen         { 0.90 0.00 0.90 0.10 } def
/green             { 1.00 0.00 1.00 0.00 } def
/lightgreen        { 0.50 0.00 1.00 0.00 } def
/verylightgreen    { 0.25 0.00 0.75 0.00 } def
/verydarkskyblue   { 0.95 0.15 0.00 0.40 } def
/darkskyblue       { 1.00 0.25 0.00 0.15 } def
/skyblue           { 1.00 0.25 0.00 0.00 } def
/lightskyblue      { 0.80 0.20 0.10 0.00 } def
/verylightskyblue  { 0.60 0.15 0.15 0.00 } def
/verydarkblue      { 1.00 1.00 0.00 0.40 } def
/darkblue          { 1.00 1.00 0.00 0.10 } def
/blue              { 1.00 1.00 0.00 0.00 } def
/lightblue         { 0.80 0.80 0.00 0.00 } def
/verylightblue     { 0.50 0.50 0.00 0.00 } def
/verydarkcyan      { 0.65 0.15 0.00 0.25 } def
/darkcyan          { 0.65 0.15 0.00 0.00 } def
/cyan              { 1.00 0.00 0.00 0.00 } def
/lightcyan         { 0.50 0.00 0.00 0.00 } def
/verylightcyan     { 0.25 0.00 0.00 0.00 } def
/verydarkviolet    { 0.40 0.80 0.20 0.00 } def
/darkviolet        { 0.45 0.85 0.00 0.00 } def
/violet            { 0.30 0.60 0.00 0.00 } def
/lightviolet       { 0.15 0.55 0.00 0.00 } def
/verylightviolet   { 0.05 0.45 0.00 0.00 } def
/verydarkred       { 0.00 0.90 0.90 0.30 } def
/darkred           { 0.00 0.80 0.90 0.10 } def
/red               { 0.00 1.00 1.00 0.00 } def
/lightred          { 0.05 0.80 0.90 0.00 } def
/verylightred      { 0.15 0.40 0.60 0.00 } def
/verydarkorange    { 0.00 0.60 1.00 0.00 } def
/darkorange        { 0.00 0.55 0.90 0.00 } def
/orange            { 0.00 0.50 0.70 0.00 } def
/lightorange       { 0.00 0.30 0.85 0.00 } def
/verylightorange   { 0.00 0.30 0.55 0.00 } def
/verydarkyellow    { 0.00 0.10 0.85 0.25 } def
/darkyellow        { 0.00 0.10 0.85 0.00 } def
/yellow            { 0.00 0.00 1.00 0.00 } def
/lightyellow       { 0.00 0.00 0.50 0.00 } def
/verylightyellow   { 0.00 0.00 0.25 0.00 } def
/verydarkbrown     { 0.00 0.85 1.00 0.70 } def
/darkbrown         { 0.00 0.75 1.00 0.60 } def
/brown             { 0.00 0.70 1.00 0.40 } def
/lightbrown        { 0.30 0.60 0.70 0.00 } def
/verylightbrown    { 0.15 0.45 0.55 0.00 } def
end
% true setpacking
true setstrokeadjust
0.125 setlinewidth
0 setlinejoin
0 setlinecap
%%EndProlog
%%BeginSetup
/cm { 28.35 mul } bind def
%%%% test flag
/tflg true def
%%%% page orientation flag
/flglscape true def
%/flglscape false def
%%%% page size in points used for plot % pgA4 == 595  842
/Dpage { pgA4 flglscape { exch } if } bind def
%%%% filling for BGcolor page
colordict begin
 /BGcolor colordict /white get def
 /FGcolor colordict /black get def 
end
%%%% offset defines non printable paper area on portrait pages
/VUpOS 0.25 cm def
/VDnOS 0.25 cm def
/HLtOS 0.25 cm def
/HRtOS 0.25 cm def
%%%% margins (1 cm) (Up Down Left Right - margins are XY independent)
/UpM 1 cm def
/DnM 1 cm def
/LtM 1 cm def
/RtM 1 cm def
%%%% checking if margins are within the defined offset
flglscape {
 UpM HLtOS lt { /UpM HLtOS def } if % Checking margins for flglscape mode
 DnM HRtOS lt { /DnM HRtOS def } if
 LtM VDnOS lt { /LtM VDnOS def } if
 RtM VUpOS lt { /RtM VUpOS def } if
 } {
  UpM VUpOS lt { /UpM VUpOS def } if % Checking margins for portrait mode
  DnM VDnOS lt { /DnM VDnOS def } if
  LtM HLtOS lt { /LtM HLtOS def } if
  RtM HRtOS lt { /RtM HRtOS def } if
  } ifelse
%%%%  defining pagelimits and X - Y scales (Xlim Ylim)
/pglim { Dpage pop LtM RtM add sub Dpage exch pop UpM DnM add sub } def
% /pgXsc { pglim pop 100 div } def
% /pgYsc { pglim exch pop 100 div } def
%%%% Defining starting point on page.
/XORI LtM def
/YORI UpM def
%%%% Defining page layout.
/XOriTitl 1 cm def
/YOriTitl 0 cm def
/XSTitl pglim pop XOriTitl 2 mul sub def
/YSTitl 1 cm def
/FlgTitl true def
/BlckSp 0.25 cm def
/NBlck  1 def
/XSBlck pglim pop def
/YSBlck pglim exch pop YSTitl BlckSp NBlck mul add YOriTitl add sub NBlck div def
/XOriBlck 0 def
/YOriBlck YOriTitl YSTitl BlckSp add add def
/XLftLbl 4 cm  def
/FLftLbl true  def
/XRgtLbl 4 cm  def
/FRgtLbl true  def
/XSPlot { XSBlck FLftLbl { XLftLbl sub } if FRgtLbl { XRgtLbl sub } if } def
/XOriPlot XOriBlck XLftLbl add def
%%%% defining groups and lines
%/LnFwd 3 def % groups for each strand
%/LnBth 3 def
%/LnRvs 3 def
@@@EndProlog@@@
}
#### End of MAINPSPROLOG function

#
# Printing Main PostScript Routines...
#
MAINPSPROCS () { 
cat <<'@@@MAINProcs@@@'
/LnTot LnFwd LnBth LnRvs add add def
/YSLine YSBlck LnTot div def
/YSFwd LnFwd LnTot div YSBlck mul def
/YOriFwd YOriBlck def
/YSBth LnBth LnTot div YSBlck mul def
/YOriBth YOriFwd YSFwd add def
/YSRvs LnRvs LnTot div YSBlck mul def
/YOriRvs YOriBth YSBth add def
%
% ---------------------------------
%     EndVariableDefinitions
% ---------------------------------
%
% ---------------------------------
%     BeginProcedureDefinitions
% ---------------------------------
%
%  Global Calculus Procedures
% ---------------------------------
%
% <--- num num .min
/min { 2 copy gt { exch } if pop } bind def 
% <--- num num .max
/max { 2 copy lt { exch } if pop } bind def
% <--- num .function
% /Xscm { Xscale mul } bind def /Xscme { Xscm exch } bind def
% /Yscm { Yscale mul } bind def /Yscme { Yscm exch } bind def
% /fmt { Yscme Xscme moveto } bind def /flt { Yscme Xscme lineto } bind def
%
%  Global Drawing Procedures
% ---------------------------------
%
% <--- /colorname .scolor
/scolor { colordict exch get exec setcmykcolor } bind def 
% <--- /colorname linewidth .tbbox
/tbbox { tflg { gsave setlinewidth scolor stroke grestore } { pop pop } ifelse } def
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% <--- score gcolor (must be defined also a inicolor, endcolor, maxscore, minscore for gradient).
% <--- startcolor endcolor maxscore minscore .defgradsets % also useful on degradates from color to white
% /gradsets 6 dict def
% /defgradsets { gradsets begin /mnsc def /mxsc def /ecol def /scol def /sdif mxsc mnsc sub def end } def
% /gcolor { gradsets begin /sc exch mnsc sub def ecol scol 4 { 5 -1 roll sub abs sdif div sc mul 4 1 roll } repeat setcmykcolor end } def
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% <--- x1 y1 x2 y2 .bbox
/bbox { 4 copy 3 1 roll exch 6 2 roll 8 -2 roll moveto lineto lineto lineto closepath } bind def
% <--- (x2-x1) score x1 y1 .DB
% /db { matrix currentmatrix 5 1 roll XS YS scale moveto 1 index 0 rlineto 0 exch rlineto neg 0 rlineto closepath setmatrix } bind def
% <--- width height xori yori .box
/box { moveto 1 index 0 rlineto 0 exch rlineto neg 0 rlineto closepath } bind def
% <--- .TB % Printing bounding boxes for all page elements.
/TB { pglim 0 0 box /FGcolor 2 tbbox /BGcolor scolor fill  %%%% pglimit box
    FlgTitl { XSTitl  YSTitl XOriTitl            YOriTitl box /green  1.0  tbbox newpath } if  %%%% title box
              XSBlck  YSBlck XOriBlck            YOriBlck box /violet 2.0  tbbox newpath       %%%% block box
    FLftLbl { XLftLbl YSBlck XOriBlck            YOriBlck box /red    0.5  tbbox newpath } if  %%%% left labels box
    FRgtLbl { XRgtLbl YSBlck XOriPlot XSPlot add YOriBlck box /red    0.5  tbbox newpath } if  %%%% right labels box
              XSPlot  YSBlck XOriPlot            YOriBlck box /cyan   0.5  tbbox newpath       %%%% plot box 
 LnFwd 0 gt { XSPlot  YSFwd  XOriPlot            YOriFwd  box /green  0.25 tbbox newpath } if  %%%% Forward  box
 LnBth 0 gt { XSPlot  YSBth  XOriPlot            YOriBth  box /blue   0.25 tbbox newpath } if  %%%% NoStrand box
 LnRvs 0 gt { XSPlot  YSRvs  XOriPlot            YOriRvs  box /green  0.25 tbbox newpath } if  %%%% Reverse  box
 LnTot 0 gt {
  1 1 LnTot { 1 sub YSLine mul YOriBlck add
              XSPlot  YSLine XOriPlot           4 -1 roll box /black  0.125 tbbox newpath      %%%% Lines box
              } for } if } bind def
%
%  Text Procedures
% ---------------------------------
%
% <--- size font .sfont
/sfont { findfont exch scalefont setfont } bind def
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% <--- size font .sfont
% /fntmtrx matrix def
% /savegmtrx fntmtrx currentmatrix def
% /sfont { /savemtrx fntmtrx currentmatrix def savegmtrx setmatrix findfont exch scalefont setfont savemtrx setmatrix } bind def
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Page Structuring Procedures
% ---------------------------------
%
% /header
% { 5 0 translate
%   1 0 0 100 -5 box
%   -1.5  2.5 PageTitle coboti FGcolor 0 textshow
%   putpage 1 eq
%   { -3 97.5 PageNumber cobost FGcolor 2 textshow
%     } if
%   putdate 1 eq
%   { -1 97.5 PageDate cobost FGcolor 2 textshow
%     } if
%   blockYscale 1 scale
%   Reverse 1 ne Forward 1 ne or
%   { 2 1 scale 
%     Forward 0 eq
%     { HlfWdth neg 10 translate
%       } { % Reverse==0
%           0 10 translate 
%           } ifelse
%     } { HlfWdth neg 10 translate
%         } ifelse
%   } bind def
%
%  Gene Drawing Procedures
% ---------------------------------
%
%%EndSetup
%
@@@MAINProcs@@@
} 
#### End of MAINPSPROCS function

#
# PostScript end of page... 
# 
MAINPSTRAILER () {
cat <<'@@@EndTrailer@@@'
%%Trailer
%
%%EOF
@@@EndTrailer@@@
} 
#### End of MAINPSTRAILER function

##############################################################
####################### PROGRAM FUNCTIONS ####################
#
# Testing parameters passed by User: Colors.
#
CheckColor () {
  gawk 'BEGIN{
    color=ARGV[1]
    if (color!~/^BG$|^FG$|^black$|^white$|^(very)?(light|dark)?(grey|green|(sky)?blue|cyan|violet|red|orange|yellow|brown)$/) {
      printf "\n<<<<ERROR>>>> \" %s \" is not a defined color.\n", color | "cat 1>&2"
      printf "              Default \" black \" is asigned to option.\n" | "cat 1>&2"
      printf "              You can choose one of this colors:\n" | "cat 1>&2"
      print ARGV[3] | "cat 1>&2"
      print "" | "cat 1>&2"
      color=ARGV[2]
      }
    print color
    ARGV[1]=ARGV[2]=ARGV[3]=""
    }' $1 $2 "$COLORS"
  return 0
}

#
# Testing parameters passed by User: Integer Numbers.
#
CheckInt () {
  if [ `expr $1 : '[0-9]*'` -eq `expr $1 : '.*'` ]
    then echo "1"; return 0
    else 
      echo "<<<<ERROR>>>> \" $1 \" is not an integer value." 1>&2
      echo "              You must especify an integer value to -$W_OPTION" 1>&2
      echo "              Program will take value from defaults..." 1>&2
      echo "" 1>&2
      echo "0";return 1
    fi
  return 1
}

###################################################################
################## MAIN GFF2PS SHELL SCRIPT #######################
#
###################################################################
################## Choosing Options for GFF2PS ####################
#
# Resetting default program variables.
#
Defaults

#
# Checking if default custom file exists
#  else switch on flag to create.
#
if [ ! -f $CFDIR/.gff2psrc ]
  then v04="0"
       echo "Warning: Default Custom File does not exist." 1>&2 
       echo "         Program is going to write a Local Custom File." 1>&2 
  else v04="1" # Exist_Default_CustomFile
       echo "Report: Using Default Custom File ($CFDIR/.gff2psrc)." 1>&2 
  fi

#
# When no options, no parameters and 
#  no inputstream are given, print USAGE.
#
if [ $# -eq 0 ] 
  then
    echo; echo $USAGE; echo; exit 1
  fi

#
# Asking for Help, output it to screen. 
#
case $1 in
  -h) Help; exit 2;;
  -H) echo; echo $PROGRAM" : Option Definition Help."; echo;
      if [ $# -gt 1 ]; 
        then shift; fi;
      for temp in $@;
        do ShowHelpLine $temp; done;
      exit 2;;
  esac

#
# Processing all options and parameters passed to program.
#
while getopts :C:vHh W_OPTION
  do
    case $W_OPTION in
      H|h) Help; exit 2;;
      C) if [ ! -f $CFDIR/$OPTARG ];    # Load_CustomFile CustomFile_Name
           then v01="0";
                echo "Error: Custom File $OPTARG does not exist...Not Loaded." 1>&2 ;
           else v01="1";
	        echo "Report: Adding $OPTARG Custom File to Default (.gff2psrc)." 1>&2 ;
                v02="$CFDIR/$OPTARG";
         fi;;
      v) v05="1";;                      # Print_Report
       :) ShowHelpLine $1; exit 2;;
      \?) ShowHelpLine $1; exit 2;;
    esac # case $W_OPTION
  done   # while getopts

#
# Shifting all options tested before,
# without removing files passed to shell...
#
 incr=1
 while [ $OPTIND -gt $incr ]
   do shift; incr=`expr $incr + 1`; done

#
# Defining PLOToptions STRING for GNU awk programs.
#
   P=$n01":="$v01"::"$n02":="$v02"::"$n03":="$v03"::"$n04":="$v04"::"$n05":="$v05
 PLOToptions=$P
 if [ $v05 -eq 1 ]
   then
     echo "********************************************" 1>&2
     echo ">>>>> Option String Passed to Program <<<<<<" 1>&2
     echo "*****************************************" 1>&2
     echo "" 1>&2
     echo $PLOToptions 1>&2
     echo "" 1>&2
   fi

###################################################################
############### CONVERTING GFF TO POSTSCRIPT ######################
#
# Printing PostScript Header...
#
gawk 'BEGIN{ 
 # Find actual date...
 "date" | getline d
 split(d,dt," ")
 date = dt[3] "." dt[2] "." dt[6] " " substr(dt[4],1,5)
 # Finding logged user...
 "whoami" | getline usr
 # Printing PostScript Header...
 bigchain=        "%%\!PS-Adobe-2.0\n"
 bigchain=bigchain"%%%%Title: %s\n"
 bigchain=bigchain"%%\n%%%%User: %s\n"
 bigchain=bigchain"%%%%Date: %s\n"
 bigchain=bigchain"%%\n%%%%Program: %s\n"
 bigchain=bigchain"%%%%Version: %s\n"
 bigchain=bigchain"%%%%CreationDate: %s\n"
 bigchain=bigchain"%%%%LastRevision: %s\n"
 bigchain=bigchain"%%%%Author : %s\n"
 bigchain=bigchain"%%%%e-mail : %s\n"
 bigchain=bigchain"%%%%Mail Adress:\n%s\n%%\n"
 if (ARGV[1]!~"##dflt##") title=ARGV[1]
 else title="GFF to PostScript"
 printf bigchain, title, usr, date, ARGV[2], ARGV[3], ARGV[4], ARGV[5], ARGV[6], ARGV[7], ARGV[8]
 printf "%%\n%% ------------------------------------------------------------------------\n"
 printf "%%                           %s - %s\n",ARGV[2], ARGV[3]
 printf "%% ------------------------------------------------------------------------\n"
  for (i=1;i<=8;i++) ARGV[i]=""
}' "##dflt##" "$PSPROGRAM" "$PSVERSION" "$PSCREATION" "$PSREVISION" "$AUTHOR" "$EMAIL" "$MAIL"

#
# Printing PostScript Prolog...
#
  MAINPSPROLOG

#
# Main GFF2PS GNU awk Program...
#
# (cat <<'@@@EndPROGRAM@@@') |
# @@@EndPROGRAM@@@
# gawk -v CUSTOMFILE=$CFDIR/.gff2aplot.rc -f - "$@"
#
MAINPSPROCS |
gawk 'BEGIN{
  ############ INITIALITATION ############

  # defaults
  MINSCORE=0.25;
  MAXSCORE=1.00;
  BigLINE="########################################"

  # gff data structure
  seqname  = 1;
  source   = 2;
  feature  = 3;
  start    = 4;
  end      = 5;
  score    = 6;
  strand   = 7;
  frame    = 8;
  group    = 9;

  # gff strand codification
  strands["+"]=strands["-"]=strands["."]=1;

  # Find actual date...
  "date" | getline d
  split(d,dt," ")
  date = dt[3] "." dt[2] "." dt[6] " " substr(dt[4],1,5)
  # Finding logged user...
  "whoami" | getline usr
  # Finding current process...
  "echo $$" | getline IDP

  # Loading PSMainProgram
  psline=1
  while ((getline < ARGV[1])>0) PSMAIN[psline++]=$0;
  ARGV[1]=""

 ############## Defining pre-variables by CommandLine ############ 
 "echo $PLOToptions" | getline d
 npar=split(d,parm,"::") 
 for (r=1;r<=npar;r++) {
   split(parm[r],elem,":=")
   if (elem[2]!="##dflt##") {
     if (elem[1]~/COLOR\$/) {
       ecolor=elem[2]
       if (ChkColor(ecolor)) {
         if (ecolor~/^BG\$|(##DEFAULT##)/) { elem[2]=Pre["BACKGROUND_COLOR"] }
         else if (ecolor~/^FG\$/) { elem[2]=Pre["FOREGROUND_COLOR"] }
         }
       else { elem[2]=Pre["BACKGROUND_COLOR"] }
       }
     Pre[elem[1]]=elem[2]
     }
   }
  for (v in Pre) Var[v]=Pre[v]

# Layout Properties
  Default["page_size"]="a4"
  Default["page_orientation"]="landscape"
  Default["margin_left"]="1cm"
  Default["margin_right"]="1cm"
  Default["margin_upper"]="1cm"
  Default["margin_bottom"]="1cm"
  Default["foreground_color"]="FGcolor"
  Default["background_color"]="BGcolor"
  Default["block_number"]=1
  Default["strand_show_forward"]="on"
  Default["strand_show_reverse"]="on"
  Default["strand_show_independent"]="on"
# General Properties
  Default["text_color"]=Default["foreground_color"]
  Default["label"]="none"
# Features Properties
  # Default["fillcolor"]=Default["background_color"]
  FT_PROP["label"]="default" # none , default , "user-def"
  FT_PROP["color"]=Default["foreground_color"]
  FT_PROP["shape"]="box"
  FT_PROP["layer"]=0
  FT_PROP["show"]="on"
# Group Properties
  GR_PROP["label"]="default" # none , default , "user-def"
  GR_PROP["rank"]="0:1" # rank of lower-upper scores
  GR_PROP["join_align"]="center"
  GR_PROP["join_color"]=Default["foreground_color"]
  GR_PROP["join_linetype"]="solid"
  GR_PROP["join_show"]="off"
# Lines (Method-Source) Properties
  SO_PROP["label"]="default" # none , default , "user-def"
  SO_PROP["baseline_align"]="center"
  SO_PROP["baseline_color"]=Default["foreground_color"]
  SO_PROP["baseline_linetype"]="dotted"
  SO_PROP["baseline_show"]="off"
  SO_PROP["bbox_color"]=Default["foreground_color"]
  SO_PROP["bbox_show"]="off"
  SO_PROP["scale"]=2
  SO_PROP["rule_scale"]="nucleotide"
  SO_PROP["rule_rel"]="none"
  SO_PROP["rule_abs"]="none"
# Default[""]=

 # Data for upper-case to lower-case function #lcase()#
 CM["A"]="a";CM["B"]="b";CM["C"]="c";CM["D"]="d";CM["E"]="e";
 CM["F"]="f";CM["G"]="g";CM["H"]="h";CM["I"]="i";CM["J"]="j";
 CM["K"]="k";CM["L"]="l";CM["M"]="m";CM["N"]="n";CM["O"]="o";
 CM["P"]="p";CM["Q"]="q";CM["R"]="r";CM["S"]="s";CM["T"]="t";
 CM["U"]="u";CM["V"]="v";CM["W"]="w";CM["X"]="x";CM["Y"]="y";
 CM["Z"]="z";CM["Ñ"]="ñ";CM["Ç"]="ç"

 if (Var["Print_Report"]) 
   printf "\n%s\nInput File...\n%s\n",BigLINE,BigLINE | "cat 1>&2"
 }
{ ############ READING .GFF FILES  ############

  # skips those empty lines or comments "#"
  #
  while ($0~/^( )*$|^(\#)+/) { 
    if (Var["Print_Report"]) 
      printf "%10s :: Not Read :: %s\n", NR, $0 | "cat 1>&2"
    if (getline<=0) break
    }

  # Printing Input Lines
  #
  if (Var["Print_Report"]) 
   printf "%10s : %s\n", NR, $0 | "cat 1>&2"

  # read gff element within source and strand
  #
  sources[$source]++;  
  n[$source,$strand]++;
  $feature=lcase($feature);
  element[$source,$strand,n[$source,$strand],feature] = $feature; 
  if (!($feature in FT_ary) && $feature!~/\./) FT_ary[$feature]++;
  element[$source,$strand,n[$source,$strand],start]   = $start;
  element[$source,$strand,n[$source,$strand],end]     = $end;
  element[$source,$strand,n[$source,$strand],frame]   = $frame;  
  element[$source,$strand,n[$source,$strand],group]   = $group; 
  if (!($group in GP_ary) && $group!~/\./) GP_ary[$group]++;
  if ($NF>group) {
    for (i=(group+1);i<=$NF;i++) {
      if ($i~"Label")
        element[$source,$strand,n[$source,$strand],$i]= $(i+1);  
    }
  }

  # recompute scores between MINSCORE and MAXSCORE
  #
  if ($score < MINSCORE)
    element[$source,$strand,n[$source,$strand],score]  = MINSCORE;
  else if ($score > MAXSCORE)
    element[$source,$strand,n[$source,$strand],score]  = MAXSCORE;

  # place gff element in sort array by acceptor position
  #
  ns=n[$source,$strand]-1;
  while ($start < element[$source,$strand,S[$source,$strand,ns],start]) {
    S[$source,$strand,ns+1]=S[$source,$strand,ns];
    ns--;
  }
  S[$source,$strand,ns+1]=n[$source,$strand]

}
END{

  # Printing elements sorted
  #
  if (Var["Print_Report"]) {
   printf "\n%s\ngff elements are sorted...\n%s\n",BigLINE,BigLINE | "cat 1>&2"
   for (sc in sources) 
    for (s in strands) 
     for (i=1;i<=n[sc,s];i++)
      printf "%10s %s\n", S[sc,s,i],showelemS(sc,s,S[sc,s,i]) | "sort | cat 1>&2"
   close("sort | cat 1>&2")
   }

  # Defining Object Properties
  #
  CreateProps(0)
  if (Var["Load_CustomFile"]) RCFile(CFILE)

  # make groups. assumes elements sorted by increasing acceptor position
  #
  if (Var["Print_Report"]) printf "\n%s\nMaking Groups...............\n%s\n",BigLINE,BigLINE | "cat 1>&2"
  cntstr_fwd=cntstr_bth=cntstr_rvs=0
  for (sc in sources) {
    for (s in strands) {
      for (i=1;i<=n[sc,s];i++) {
	tgr=element[sc,s,S[sc,s,i],group];
	if (!grouping[sc,s,tgr,start]) {
	  grouping[sc,s,tgr,start]= element[sc,s,S[sc,s,i],start];
	  ng[sc,s]++;
	  group_[sc,s,ng[sc,s]]=tgr
          }
####################
#        grouping[sc,s,tgr,end]= element[sc,s,S[sc,s,i],end];
#
#        # for gene mode. try to recompute relative frame and remainder
#        start_=element[sc,s,S[sc,s,i],start];
#        end_=element[sc,s,S[sc,s,i],end];
#        feature_=element[sc,s,S[sc,s,i],feature];
#
#        frame_[sc,s,tgr]= element[sc,s,S[sc,s,i],frame];
#
#        if (feature_=="First" || feature_=="Single") 
#          frame_[sc,s,tgr]=0;
#        else if (feature_=="Internal" || feature_=="Terminal" )
#          frame_[sc,s,tgr]=remainder_[sc,s,tgr];
#
#        remainder_[sc,s,tgr]=(3-(end_-(start_+frame_[sc,s,tgr])+1)%3)%3;
#
#        grouping[sc,s,tgr,group] = sprintf("%s %d %d %s %d %d %5.3f", grouping[sc,s,tgr,group], element[sc,s,S[sc,s,i],start], element[sc,s,S[sc,s,i],end], psc_feature[element[sc,s,S[sc,s,i],feature]], frame_[sc,s,tgr] ,remainder_[sc,s,tgr],  element[sc,s,S[sc,s,i],score]);
##################### 
	if (element[sc,s,S[sc,s,i],end]>grouping[sc,s,tgr,end]) {
	  grouping[sc,s,tgr,end]= element[sc,s,S[sc,s,i],end];
          }
#################
   if (Var["Print_Report"]) {
    print grouping[sc,s,tgr,start]," :",sc,s,tgr,start, showelem(sc,s) | "cat 1>&2"
    print grouping[sc,s,tgr,end]," :",sc,s,tgr,end, showelem(sc,s) | "cat 1>&2"
    for (prop in FT_PROP) {
      printf "\t%-10s : %-8s %s \n",element[sc,s,S[sc,s,i],feature],prop,PLOT_FT[element[sc,s,S[sc,s,i],feature],":",prop] | "cat 1>&2"
      }
    }
#################
      } # for i
    }   # for s
    # Percent of plot area for each strand
    if (ng[sc,"+"]>0) cntstr_fwd+=PLOT_FT[sc,":","scale"]
    if (ng[sc,"."]>0) cntstr_bth+=PLOT_FT[sc,":","scale"]
    if (ng[sc,"-"]>0) cntstr_rvs+=PLOT_FT[sc,":","scale"]
  }     # for sc
  cntstr_TOT=cntstr_fwd+cntstr_bth+cntstr_rvs
  printf "/LnFwd %s def %% groups for each strand\n/LnBth %s def\n/LnRvs %s def\n", cntstr_fwd/cntstr_TOT, cntstr_bth/cntstr_TOT, cntstr_rvs/cntstr_TOT

  # PostSCript Main Procs.
  #
  for (i=1;i<psline;i++) print PSMAIN[i]; 

  # PostSCript PageSetup.
  #
  startPSpage(1,1)

  # make plotlines. Put non-overlapping groups into the same plotting line.
  #
  if (Var["Print_Report"]) printf "\n%s\nPrinting Lines...............\n%s\n",BigLINE,BigLINE | "cat 1>&2"
  for (sc in sources) {
    for (s in strands) {
      for (i=1;i<=ng[sc,s];i++) {
	g=group_[sc,s,i];
	for (j=1;j<=nl[sc,s] && grouping[sc,s,g,start] < endline[sc,s,j];j++);
	nl[sc,s] = j==nl[sc,s]+1 ? j : nl[sc,s];
        endline[sc,s,j]=grouping[sc,s,g,end];
	# plot group in file
	if (Var["Print_Report"]) printf "GROUP : %-10s : %s %10d %10d \n", g, s, grouping[sc,s,g,start], grouping[sc,s,g,end] | " sort +6 | cat 1>&2";
        }
     }
  }
  if (Var["Print_Report"]) close(" sort +6 | cat 1>&2")

  # PostSCript Page Trailer.
  #
  endPSpage()

  # Object Properties Report...
  #
  if (Var["Print_Report"]) {
    printf "\n%s\nDefining Object Properties..........\n%s\n",BigLINE,BigLINE | "cat 1>&2"
    CreateProps(1) | "cat 1>&2"
    }

  # If not exist, create custom file (.gff2psrc)
  #
  if (!Var["Exist_Default_CustomFile"]) CreateProps(1) > Var["Default_CustomFile_Name"]

}
function min(a,b) { if (a<=b) return a; else return b }
function max(a,b) { if (a>=b) return a; else return b }
function ChkXlim(o,e) { if (o>=ESQ1 || e<=OSQ1) return 0; else return 1 } # Still not adapted.
function ChkYlim(o,e) { if (o>=ESQ2 || e<=OSQ2) return 0; else return 1 } # Still not adapted.
function OnOff(value) { if (value~/^1\$|^ON\$|^Y(ES)?\$|^T(RUE)?\$/) return 1; else return 0 }
function ChkColor(ncolor) {
 if (ncolor~/^FG\$|^black\$|^white\$|^(very)?(light|dark)?(grey|green|(sky)?blue|cyan|violet|red|orange|yellow|brown)\$/)
   return 1
 else return 0 # also when ncolor == ^BG\$|(##DEFAULT##)
 }
function tick(nm) { # Still not adapted.
 end1=ESQ1-OSQ1; if (end1==0) end1=10000
 end2=ESQ2-OSQ2; if (end2==0) end2=10000
 wy=max(end1,end2);
 y=wy/nm;
 ylog=(log(y)/log(10));
 yfloor=int(ylog);
 y1=y/(10^yfloor);
 y2=int(y1);
 t=y2*(10^yfloor);
 return t
 }
function lcase(string) {
  for (chr in CM) gsub(chr,CM[chr],string)
  return string
}
function CreateProps(flag) {
  ############ Create Properties Index for Objects ############
  if (flag) { 
    printf "#\n# L ############PAGE LAYOUT############\n#\n"
    for (feat in Default) printf "%s=%s\n", feat, Default[feat] | "sort"
    }
  if (flag) {
    close("sort")
    printf "#\n# F ############GENOMIC FEATURES############\n#\n"
    }
  for (feat in FT_ary) {
    for (prop in FT_PROP) {
      if (flag)
	printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] | "sort"
      else PLOT_FT[feat,":",prop]=FT_PROP[prop]
      }
    }
  if (flag) { 
    close("sort")
    printf "#\n# G ############GROUP FEATURES############\n#\n"
    }
  for (feat in GP_ary) {
    for (prop in GR_PROP) {
      if (flag)
	printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] | "sort"
      else PLOT_FT[feat,":",prop]=GR_PROP[prop]
      }
    if (flag)
      printf "# %s:%s=%s\n#\n", feat, "feature_number", FT_ary[feat]
    }
  if (flag) { 
    close("sort | cat 1>&2")
    printf "#\n# S ############SOURCE FEATURES############\n#\n"
    }
  for (feat in sources) {
    for (prop in SO_PROP) {
      if (flag)
	printf "%s:%s=%s\n", feat, prop, PLOT_FT[feat,":",prop] | "sort"
      else PLOT_FT[feat,":",prop]=SO_PROP[prop]
      }
    if (flag)
      printf "# %s:%s=%s\n#\n", feat, "group_number", GP_ary[feat]
    }
    if (flag) close("sort")
}
function RCFile(file) { ############ Read CustomFile
  while ((getline < file) > 0 ) {
    ChckLn(file)
    nothere=0
    split($0,defs,"=")
    split(defs[1],nwfeat,":")
    first=nwfeat[1]
    if (first=="*") first=".*" 
    gffirst=lcase(first)
    second=nwfeat[2]
    for (feat in FT_ary) {
      if (match(feat,gffirst)) {
        if (Var["Print_Report"]) print "Feature Match between: " feat " & " first | "cat 1>&2"
	if ((feat,":",second) in PLOT_FT) {
          PLOT_FT[feat,":",second]=defs[2]
     	  nothere=1
        }
      }
    }
    for (feat in GP_ary) { 
      if (match(feat,first)) {
        if (Var["Print_Report"]) print "Group Match between: " feat " & " first | "cat 1>&2"
	if ((feat,":",second) in PLOT_FT) {
          PLOT_FT[feat,":",second]=defs[2]
	  nothere=1
        }
      }
    }
    for (feat in sources) {
      if (match(feat,first)) {
        if (Var["Print_Report"]) print "Source Match between: " feat " & " first | "cat 1>&2"
	if ((feat,":",second) in PLOT_FT) { 
          PLOT_FT[feat,":",second]=defs[2]
	  nothere=1
        }
      }
    }
    # print ">>>New Feature>>>" $0
    if (nothere==0) {
      if (Var["Print_Report"]) print "No Match found: " first | "cat 1>&2"   
      FT_ary[gffirst]=gffirst
      PLOT_FT[gffirst,":",second]=defs[2]
    }
  }
  close(file)  
}
function showelemS(s,p,q){
  string=" : "
  string=string" "element[s,p,q,feature]" "
  string=string" "element[s,p,q,start]" "
  string=string" "element[s,p,q,end]" "
  string=string" "element[s,p,q,frame]" "
  string=string" "element[s,p,q,group]
  return string
 }
function showelem(a,b){
  string=" : "
  string=string" "element[a,b,n[a,b],feature]" "
  string=string" "element[a,b,n[a,b],start]" "
  string=string" "element[a,b,n[a,b],end]" "
  string=string" "element[a,b,n[a,b],frame]" "
  string=string" "element[a,b,n[a,b],group]
  return string
 }
function startPSpage(num,tot){
 printf "%%%%Page: %s %s\n",num,num
 printf "%%%%BeginPageSetup\n%%\n"
 printf "%% Saving current page settings\n"
 printf "/pgsave save def\n"
 printf "%% Defining pagenumber\n"
 printf "/PageNumber (Page %s/%s) def\n",num,tot
 printf "%% Setting BGcolor for sheet \n"
 printf "Dpage flglscape { exch } if 0 0 box /FGcolor 1 tbbox /BGcolor scolor fill\n"
 printf "%% setting coordinate axes for page orientation\n"
 printf "flglscape\n"
 printf " { 90 rotate 1 -1 scale XORI YORI translate }                  %% (0,0) - Ori for landscape pages\n"
 printf " { XORI Dpage exch pop YORI sub translate 1 -1 scale } ifelse  %% (0,0) - Ori for portrait pages\n"
 printf "%% If testing output print bounding_boxes for page elements\n"
 printf "tflg { TB } if\n%%\n%% /FGcolor scolor\n%%\n"
 printf "%% Header\n%%\n"
 printf "%%%%EndPageSetup\n%%\n"
 }
function endPSpage(){
 printf "%%\npgsave restore\nshowpage\n%%\n"
 }
' - "$@"
#### Main GFF2APLOT GNU awk Program DONE.

#
# PostScript end of page (Trailer)
# 
  MAINPSTRAILER

#
##################### EOF #####################
#
exit 0
